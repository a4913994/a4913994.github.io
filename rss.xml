<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title></title>
        <link>undefined</link>
        <description>undefined</description>
        <lastBuildDate>Wed, 21 Dec 2022 03:55:30 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>Joplin Pages Publisher</generator>
        <item>
            <title><![CDATA[eBPF复杂性]]></title>
            <guid>006498407dcc4a5e90998ae265d7c1cd</guid>
            <pubDate>Wed, 21 Dec 2022 03:36:48 GMT</pubDate>
            <content:encoded><![CDATA[<h3 id="跨内核版本的可移植性">跨内核版本的可移植性</h3>
<p>eBPF 程序可以访问内核数据结构，这些数据结构可能会随着不同的内核版本而改变。结构本身是在构成 Linux 源代码一部分的头文件中定义的。过往，你必须针对与要运行这些程序的内核兼容的正确头文件集来编译 eBPF 程序。</p>
<h3 id="bcc-可移植性方法">BCC 可移植性方法</h3>
<p>为了解决跨内核的可移植性，BCC1（BPF Compiler Collection）项目采用了在运行时在目标机器上编译 eBPF 代码的方法。 这意味着编译工具链需要安装到代码运行的每台目标机器上2，并且你必须等待编译完成才能启动工具。你还必须保证内核头文件存在于文件系统上（但并非总是如此）。接着我们进入 BPF CO-RE。</p>
<h3 id="co-re">CO-RE</h3>
<p>CO-RE（一次编译，到处运行）方法包含几个元素：</p>
<h4 id="btf-bpf-type-format">BTF (BPF Type Format)</h4>
<p>这是一种表达数据结构和函数签名布局的格式。现代 Linux 内核支持 BTF，因此你可以从正在运行的系统生成一个名为 vmlinux.h 的头文件，其中包含 BPF 程序可能需要的有关内核的所有数据结构信息。</p>
<h4 id="libbpf-bpf-库">libbpf, BPF 库</h4>
<p>一方面，libbpf 提供了加载 eBPF 程序和 map 到内核的函数。但它在可移植性方面也起着重要作用：依据 BTF 信息来调整 eBPF 代码，以补偿编译时存在的数据结构与目标机器上的数据结构之间的任何差异。</p>
<h4 id="编译器支持">编译器支持</h4>
<p>clang 编译器得到了增强，因此当它编译 eBPF 程序时，它包括所谓的 BTF 重定向（relocations），这是 libbpf 在加载 BPF 程序和 map 到内核时用来知道要调整哪些内容。</p>
<h4 id="可选的-bpf-脚手架">可选的 BPF 脚手架</h4>
<p>可以使用 bpftool gen skeleton 从编译的 BPF 目标文件中自动生成脚手架，其中包含辅助函数，用户空间代码可以调用这些辅助函数来管理 BPF 程序的生命周期——将其加载到内核中，附加到事件等等。这些函数是更高级别的抽象，对开发人员来说比直接使用 libbpf 更方便。</p>
<p>有关 CO-RE 的更详细说明，请阅读 Andrii Nakryiko 详细的<a title="https://nakryiko.com/posts/bpf-portability-and-co-re/" href="https://nakryiko.com/posts/bpf-portability-and-co-re/">讲解</a>。</p>
<p>vmlinux 文件形式的 BTF 信息自 5.4 版起已包含在 Linux 内核中，但也可以为较旧的内核生成 libbpf 可以使用的原始 BTF 数据。<a title="https://github.com/aquasecurity/btfhub" href="https://github.com/aquasecurity/btfhub">BTF Hub</a> 上有关于如何生成 BTF 文件的信息，以及用于各种 Linux 发行版的文件存档。</p>
<p>BPF CO-RE 方法使 eBPF 程序员比过去更容易让他们的代码在任何 Linux 发行版上运行——或者至少在任何新的 Linux 发行版上运行，以支持程序使用的任何 eBPF 功能集。但这并不能使 eBPF 编程轻松自如：其本质上仍然是内核编程。</p>
<h3 id="linux-内核知识">Linux 内核知识</h3>
<p>很快你会认识到，你仍然需要关于 Linux 内核的领域知识才能编写更高级的工具。你需要了解可以访问的数据结构，这取决于调用 eBPF 代码的上下文。并非每个应用程序开发人员都有解析网络数据包、访问套接字缓冲区或处理系统调用参数的经验。</p>
<p>内核将如何响应 eBPF 代码的行为？正如你在第 2 章中所了解的，内核由数百万行代码组成。它的文档可能很少，因此你可能会发现自己必须阅读内核源代码才能弄清楚某些东西是如何工作的。</p>
<p>你还需要弄清楚 <strong>eBPF 代码应该附加到哪些事件上</strong>。如果可以选择将 kprobe 附加到整个内核中的任何函数入口点，这可能不是一个容易的决定。在某些情况下，这很简单，例如如果你想访问传入的网络数据包，那么在合适的网络接口进行 XDP 挂钩是一个明显的选择。如果你想提供对特定内核事件的可观察性，在内核代码中找到适当的附加点可能并不难。</p>
<p>但在其他情况下，选择可能并不带明确。例如，仅使用 kprobes 挂钩构成内核系统调用接口的函数的工具可能会受到称为 time-of-check to time-of-use (TOCTTOU) 的安全漏洞的影响。攻击者有一个很小的机会窗口，他们可以在 eBPF 代码读取参数之后，但在被复制到内核内存之前更改系统调用的参数。Rex Guo 和 Junyuan Zeng 在 DEF CON 29 上对此进行了精彩的<a title="https://www.youtube.com/watch?v=yaAdM8pWKG8" href="https://www.youtube.com/watch?v=yaAdM8pWKG8">演示</a>。一些最广泛使用的 eBPF 工具是以非常初级的方式编写的，并且容易受到这种攻击。这并不是一个容易的利用，并且有一些方法可以减轻这些攻击，但是如果你要保护高度敏感的数据免受老练的对手的攻击，请深入了解你使用的工具是否会受到影响。</p>
<p>你已经看到了 BPF CO-RE 如何使 eBPF 程序在不同的内核版本上工作，但它只考虑了数据结构布局的变化，而不考虑内核行为的更广泛的变化。例如，如果想将 eBPF 程序附加到内核中的特定函数或跟踪点，你可能需要一个计划 B，如果该函数或跟踪点不存在于不同的内核版本中该怎么办。</p>
<h3 id="多-ebpf-程序协调">多 eBPF 程序协调</h3>
<p>现在可用的许多基于 eBPF 的工具都提供了一套可观察性功能，通过将 eBPF 程序挂钩到一组内核事件来实现。其中大部分是由 Brendan Gregg 和其他人在 BCC 和 bpftrace 工具中所研发。当前这代（通常是商业的）工具可能会提供更漂亮的图形和 UI，但他们利用的 eBPF 程序高度基于这些原来的工具。</p>
<p>当你想要编写协调不同类型事件之间交互的代码时，事情会变得相当复杂。例如，Cilium 通过内核的网络栈在多个点查看网络数据包，并根据来自 Kubernetes CNI（容器网络接口）的有关 Kubernetes Pod 的信息来处理流量。构建这个系统需要 Cilium 开发人员深入了解内核如何处理网络流量，以及 “Pod” 和 “Container” 的用户空间概念如何映射到 cgroup 和 namespace 等内核概念。在实践中，几个 Cilium 维护者也是内核开发人员，致力于增强 eBPF 和网络支持；因此，他们拥有这些知识。</p>
<p>底线是，尽管 eBPF 提供了一个非常高效和强大的平台来连接内核，但对于没有丰富内核经验的普通开发人员来说，这不是一件容易的事。如果你有兴趣亲身体验 eBPF 编程，我强烈建议你将其作为练习学习；在这一领域积累经验可能非常有价值，因为它必将在未来几年继续成为广受欢迎的专业技能。但实际上，大多数组织不太可能在内部构建大量定制的 eBPF 工具，而是会利用来自专业 eBPF 社区的项目和产品。</p>
<blockquote>
<ol>
<li>Cilium 文档 描述了附加到不同网络钩子的 eBPF 程序如何组合以实现复杂的网络功能 .</li>
<li>有关更多信息，请参阅 Andrii Nakryiko 的 IO Visor <a title="https://lists.iovisor.org/g/iovisor-dev/message/1966" href="https://lists.iovisor.org/g/iovisor-dev/message/1966">帖子</a></li>
</ol>
</blockquote>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[eBPF程序]]></title>
            <guid>9179edc8a10440259cfed3172dc96a04</guid>
            <pubDate>Wed, 21 Dec 2022 02:24:37 GMT</pubDate>
            <content:encoded><![CDATA[<h3 id="定制程序附加到事件">定制程序附加到事件</h3>
<p>eBPF程序本身通常用C或Rust编写并编译成目标文件。目标文件是一个标准的 ELF（可执行和可链接格式）文件，可以使用 <code>readelf</code> 等工具进行检查，它包含程序字节码和<code> map</code> 的定义。</p>
<p><img src="/_resources/0b877c2c038c4686badaade0eaddcde1.png" /></p>
<p>一旦你将 eBPF 程序加载到内核中，它就必须附加到一个事件上。每当事件发生时，相关的 eBPF 程序就会被触发执行。</p>
<h3 id="进入或退出函数">进入或退出函数</h3>
<p>你可以附加一个 eBPF 程序，在进入或退出内核函数时触发。当前许多 eBPF 示例都使用 kprobes（附加到内核函数入口点）和 kretprobes（函数退出）的机制。在最近的内核版本中，有一个更有效的替代方案，称为 fentry/fexit</p>
<p>你还可以使用 uprobes 和 uretprobes 将 eBPF 程序附加到用户空间函数</p>
<h3 id="tracepoint">Tracepoint</h3>
<p>你也可以将eBPF程序附加到内核内定义的 tracepoints4。通过在 /sys/kernel/debug/tracing/events 下查找机器上的事件</p>
<h3 id="perf-事件">Perf 事件</h3>
<p>Perf 是一个用于收集性能数据的子系统。你可以将 eBPF 程序挂接到所有收集 perf 数据的地方，这可以通过在机器上运行 perf list 来确定。</p>
<h3 id="linux安全模块接口linux-security-module-interface">Linux安全模块接口（Linux Security Module Interface）</h3>
<p>LSM 接口允许在内核允许某些操作之前检查安全策略。你可能遇到过使用此接口的 AppArmor 或 SELinux。使用 eBPF，你可以将自定义程序附加到相同的检查点，从而实现灵活、动态的安全策略和运行时安全工具的一些新方法</p>
<h3 id="网络接口-xdpexpress-data-path">网络接口 XDP（eXpress Data Path）</h3>
<p><code>XDP（eXpress Data Path)</code> 允许将 eBPF 程序附加到网络接口，每当收到数据包就会触发 eBPF 执行。XDP 可以检查甚至修改数据包，eBPF 程序的退出代码用于通知内核如何处理该数据包：传递、丢弃或重定向。 这可以构成一些非常有效的网络功能的基础。</p>
<h3 id="套接字和其他网络-hook">套接字和其他网络 Hook</h3>
<p>你可以附加 eBPF 程序以在应用程序打开在网络套接字上执行操作、以及在发送或接收消息时运行 eBPF 程序。 在内核的网络栈中还有称为 traffic control 或 tc 的 Hook，eBPF 程序可以在初始数据包处理后运行</p>
<p>有些功能可以单独使用 eBPF 程序来实现，但在许多情况下，我们希望 eBPF 代码从用户空间应用程序接收信息或将数据传递给用户空间应用程序。 允许数据在 eBPF 程序和用户空间之间或不同 eBPF 程序之间传递的机制称为<code> maps</code></p>
<h3 id="ebpf-map">eBPF Map</h3>
<p>Map 功能的添加是 eBPF 首字母缩写词中 e 代表 扩展 的显着标志之一。</p>
<p>Map 是与 eBPF 程序一起定义的数据结构。Map 有多种不同类型的，但它们本质上都是键值存储。eBPF 程序及用户空间代码可以读取和写入数据。Map 的常见用途包括：</p>
<ul>
<li>一个 eBPF 程序编写有关事件的指标和其他数据，供用户空间代码稍后查询；</li>
<li>用户空间代码编写配置信息，以便 eBPF 程序读取并相应地执行；</li>
<li>一个 eBPF 将数据写入 map，供另一个 eBPF 程序读取，这种方式允许跨多个内核事件同步信息；</li>
</ul>
<p>如果内核和用户空间代码都将访问同一个 map，他们将需要对存储在 mmap 中的数据结构达成共识。这可以通过在用户空间和内核代码中包含定义这些数据结构的头文件来完成，但如果两者是通过不相同的语言编写，你将需要仔细创建字节结构定义字节对齐兼容。</p>
<p>我们已经讨论了 eBPF 工具的主要组成部分：在内核中运行的 eBPF 程序、加载程序并与之交互的用户空间代码，以及允许程序共享数据的 map。为了更好理解，我们通过一个例子演示。</p>
<h3 id="opensnoop-样例">Opensnoop 样例</h3>
<p>对于 eBPF 程序示例，我选择了实用的工具 opensnoop，其可用于显示任何进程打开了哪些文件。该实用程序的原始版本是 Brendan Gregg 最初在 BCC 项目中编写的众多 BPF 工具之一，你可以在 GitHub 上找到该项目。后来该工具使用 libbpf 重写（你将在下一章中看到），在这个例子中，我使用的是 libbpf-tools 目录下的较新版本。</p>
<p>当运行 opensnoop 时，你将看到的输出很大程度上取决于当时虚拟机上发生的情况，但它应该看起来像这样：</p>
<div><pre class="hljs"><code>PID    COMM FD ERR PATH
93965  cat     3   0 /etc/ld.so.cache
93965  cat     3   0 /lib/x86_64-linux-gnu/libc.so.6
93965  cat     3   0 /usr/lib/locale/locale-archive
93965  cat     3   0 /usr/share/locale/locale.alias
...</code></pre></div>
<p>每一行输出表示一个进程打开（或试图打开）一个文件。这些列显示了进程 ID、正在运行的命令、文件描述符、任何错误代码的指示以及被打开文件的路径。</p>
<p>Opensnoop 的工作方式是将 eBPF 程序附加到 open() 和 openat() 系统调用上，任何应用程序都必须通过这些调用来要求内核打开一个文件。让我们深入了解一下这一点是如何实现的。为了简洁起见，我们并不看每一行代码，但我希望这足以让你了解它是如何工作的。(如果你对这么深的内容不感兴趣的话，请跳到下一章！）。</p>
<p>每行输出表明一个进程打开（或试图打开）一个文件。 这些列显示进程 ID、正在运行的命令、文件描述符、任何错误代码以及正在打开的文件的路径。</p>
<p>Opensnoop 通过将 eBPF 程序附加到 open() 和 openat() 系统调用上工作，任何应用程序都必须进行这些调用以请求内核打开文件。 接着，我们将深入了解其实现。为简洁起见，我们不会查看代码的每一行，但我希望它足以让你了解其工作原理。（如果你对深入研究不感兴趣，请随意跳到下一章！）</p>
<h3 id="opensnoop-ebpf-代码">Opensnoop eBPF 代码</h3>
<p>eBPF 代码是用 C 语言编写的，位于文件 opensnoop.bpf.c 中。在该文件的头部附近，你可以看到两个 eBPF map 的定义 start 和 event：</p>
<div><pre class="hljs"><code>    <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
        __uint(type, BPF_MAP_TYPE_HASH);
        __uint(max_entries, <span class="hljs-number">10240</span>);
        __type(key, u32);
        __type(value, <span class="hljs-keyword">struct</span> <span class="hljs-type">args_t</span>);
    } start <span class="hljs-title function_">SEC</span><span class="hljs-params">(<span class="hljs-string">".maps"</span>)</span>;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
        __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);
        __uint(key_size, <span class="hljs-keyword">sizeof</span>(u32));
        __uint(value_size, <span class="hljs-keyword">sizeof</span>(u32));
    } events <span class="hljs-title function_">SEC</span><span class="hljs-params">(<span class="hljs-string">".maps"</span>)</span>;</code></pre></div>
<p>当创建 ELF 目标文件时，它包含每个 map 和要加载到内核中的每个程序的区块（section），通过 SEC() 宏定义。</p>
<p>当我们查看程序时，你将看到，start map 用于在处理系统调用时临时存储系统调用的参数（包括正在打开的文件的名称）。events map 7 用于将事件信息从内核中的 eBPF 代码传递到用户空间可执行文件。 如图 3-2 所示。<br />
<img src="/_resources/b933858157824a2fb9af347c7d5608bf.png" /></p>
<p>在 opensnoop.bpf.c 文件的后面，你会发现两个非常相似的函数：</p>
<div><pre class="hljs"><code>SEC(<span class="hljs-string">"tracepoint/syscalls/sys_enter_open"</span>)
    <span class="hljs-type">int</span> <span class="hljs-title function_">tracepoint__syscalls__sys_enter_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span>
        trace_event_raw_sys_enter* ctx)</span></code></pre></div>
<p>和</p>
<div><pre class="hljs"><code>    SEC(<span class="hljs-string">"tracepoint/syscalls/sys_enter_openat"</span>)
    <span class="hljs-type">int</span> <span class="hljs-title function_">tracepoint__syscalls__sys_enter_openat</span><span class="hljs-params">(<span class="hljs-keyword">struct</span>
    trace_event_raw_sys_enter* ctx)</span></code></pre></div>
<p>打开文件有两种不同的系统调用：8 openat() 和 open()。两者功能相同，只是 openat() 有一个额外的目录文件描述符参数，并且要打开的文件的路径名是相对于该目录的。同样，除了处理参数中的差异外，opensnoop 中对应的两个处理函数是相同。</p>
<p>如你所见，它们都采用指向 trace_event_raw_sys_enter 的结构的指针参数。你可以在运行的特定内核生成的 vmlinux 头文件中找到此结构的定义。 编写 eBPF 程序的包括计算程序接收到的结构作为其上下文，以及如何访问其中的信息。</p>
<p>这两个函数使用 BPF 辅助函数来获取到请求系统调用的进程的 ID：</p>
<div><pre class="hljs"><code>u64 id = bpf_get_current_pid_tgid();</code></pre></div>
<p>后续代码得到了文件名和传递给系统调用的标志，并把它们放在一个叫做 args 的结构中：</p>
<div><pre class="hljs"><code>args.fname = (<span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *)ctx-&gt;args[<span class="hljs-number">0</span>];
             args.flags = (<span class="hljs-type">int</span>)ctx-&gt;args[<span class="hljs-number">1</span>];</code></pre></div>
<p>该结构使用当前程序 ID 作为 key 保存到 start map 中。</p>
<div><pre class="hljs"><code>bpf_map_update_elem(&amp;start, &amp;pid, &amp;args, <span class="hljs-number">0</span>);</code></pre></div>
<p>这就是 eBPF 程序在进入系统调用时所做的全部。但是在 opensnoop.bpf.c 中定义的另一对 eBPF 程序会在系统调用退出时触发：</p>
<div><pre class="hljs"><code>SEC(<span class="hljs-string">"tracepoint/syscalls/sys_exit_open"</span>)
<span class="hljs-type">int</span> tracepoint__syscalls__sys_exit_open</code></pre></div>
<p>该程序及其函数 openat() 共享函数 trace_exit() 中的公共代码。你有没有注意到 eBPF 程序调用的所有函数都以静态 __always_inline 为前缀？这指示编译器将函数的指令内联，这是因为在旧版本内核中，不允许 BPF 程序跳转到单独的函数。较新的内核和 LLVM 版本中已经可以支持非内联函数调用，但是设置 <code>__always_inline</code> 可确保 BPF 验证器保能够更好工作。（现在还有 BPF 尾调用的概念，即执行从一个 BPF 程序跳转到另一个。你可以在 eBPF 文档中阅读有关 BPF 函数调用和尾部调用的更多信息。）</p>
<p>在 trace_exit() 函数中创建一个空的事件结构：</p>
<div><pre class="hljs"><code>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">event</span> <span class="hljs-title">event</span> =</span> {};</code></pre></div>
<p>这将填充有关即将结束的 open/openat 系统调用的信息，并通过 event map 发送到用户空间。</p>
<p>在开始的 start hash_map 中应该有一个对应于当前进程 ID 的条目：</p>
<div><pre class="hljs"><code>ap = bpf_map_lookup_elem(&amp;start, &amp;pid);</code></pre></div>
<p>这包含有关在 sys_enter_open(at) 调用期间先前写入的文件名和 flags 的信息。 flags 字段是一个直接存储在结构体中的整数，所以直接从结构体中读取就可以了：</p>
<div><pre class="hljs"><code>    event.flags = ap-&gt;flags;</code></pre></div>
<p>相反，文件名被写入用户空间内存中的一些字节数，验证器需要确保此 eBPF 程序从内存中的该位置读取该字节数是安全的。这是使用另一个辅助函数 bpf_probe_read_user_str() 完成的：</p>
<div><pre class="hljs"><code>    bpf_probe_read_user_str(&amp;event.fname, <span class="hljs-keyword">sizeof</span>(event.fname), ap-&gt;fname);</code></pre></div>
<p>当前的命令行名称（即进行 open(at) 系统调用的可执行文件的名称）也被复制到事件结构中，使用另一个 BPF 辅助函数：</p>
<div><pre class="hljs"><code>bpf_get_current_comm(&amp;event.comm, <span class="hljs-keyword">sizeof</span>(event.comm));</code></pre></div>
<p>event 结构被写入事件 perf 缓冲区 map ：</p>
<div><pre class="hljs"><code>bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU, &amp;event, <span class="hljs-keyword">sizeof</span>(event));</code></pre></div>
<p>用户空间代码从该 map 中读取事件信息。在我们讨论这个问题之前，让我们简要地看一下 Makefile。</p>
<h3 id="libbpf-tools-makefile">libbpf-tools Makefile</h3>
<p>当构建 eBPF 代码时，你会得到一个包含 eBPF 程序和 map 的二进制定义的目标文件。你还需要额外的一个用户空间可执行文件，它将这些程序和 map 加载到内核中，并充当用户接口。 让我们看看构建 opensnoop 的 Makefile，是如何创建 eBPF 目标文件和可执行文件的。</p>
<p>Makefiles 由一组规则组成，这些规则的语法可能有点不透明（opaque），所以如果你不熟悉 Makefiles 并且不是特别关心细节，请随意跳过本节！</p>
<p>我们正在查看的 opensnoop 示例是诸多样例工具之一，这些样例工具共同使用一个 Makefile 构建，你可以在 libbpf-tools 目录中找到该 Makefile。 此文件中的所有内容并非都特别令人感兴趣，但我想强调一些规则。第一个是使用 bpf.c 文件并使用 clang 编译器创建 BPF 目标对象文件的规则：</p>
<div><pre class="hljs"><code>**$(OUTPUT)/%.bpf.o**: **%.bpf.c** $(LIBBPF_OBJ) $(wildcard %.h) $(AR.. $(call msg,BPF,$@)
$(Q)$(**CLANG**) $(CFLAGS) **-target bpf** -D__TARGET_ARCH_$(ARCH) \
-I$(ARCH)/ $(INCLUDES) -c $(filter %.c,$^) -o $@ &amp;&amp; \
    $(LLVM_STRIP) -g $@</code></pre></div>
<p>因此，opensnoop.bpf.c 被编译成 $(OUTPUT)/open snoop.bpf.o。这个对象文件包含将被载入内核的 eBPF 程序和 map。</p>
<p>另一条规则使用 bpftool gen skeleton 从 bpf.o 对象文件中包含的映射和程序定义创建一个脚手架头文件。</p>
<p>因此，opensnoop.bpf.c 被编译成 $(OUTPUT)/open snoop.bpf.o。该目标文件包含将加载到内核中的 eBPF 程序和 map。</p>
<p>另一个规则使用 bpftool gen 脚手架从该 bpf.o 目标文件中包含的 map 和程序定义创建脚手架头文件：</p>
<div><pre class="hljs"><code>**$(OUTPUT)/%.skel.h: $(OUTPUT)/%.bpf.o** | $(OUTPUT) $(call msg,GEN-SKEL,$@)
$(Q)$(**BPFTOOL**) **gen skeleton** $&lt; &gt; $@</code></pre></div>
<p>opensnoop.c 用户空间代码包含这个 opensnoop.skel.h 头文件，以获取它与内核中的 eBPF 程序共享的 map 的定义。这允许用户空间和内核代码了解存储在这些 map 中的数据结构的布局。</p>
<p>以下规则将用户空间代码从 opensnoop.c 编译成一个名为 $(OUTPUT)/opensnoop.o 的二进制对象：</p>
<div><pre class="hljs"><code>**$(OUTPUT)/%.o**: %.c $(wildcard %.h) $(LIBBPF_OBJ) | $(OUTPUT) $(call msg,CC,$@)
$(Q)$(**CC**) $(CFLAGS) $(INCLUDES) -c $(filter %.c,$^) -o $@</code></pre></div>
<p>最后，有一个规则使用 cc 将用户空间应用程序对象（在我们的例子中，opensnoop.o）链接到一组可执行文件中：</p>
<div><pre class="hljs"><code>$(APPS): %: $(OUTPUT)/%.o $(LIBBPF_OBJ) $(COMMON_OBJ) | $(OUT... $(call msg,BINARY,$@)
$(Q)$ (**CC**) $(CFLAGS) $^ $(LDFLAGS) -lelf -lz -o $@</code></pre></div>
<p>现在你已经了解了如何分别生成 eBPF 和用户空间程序，接着让我们看看对应的用户空间代码。</p>
<h3 id="opensnoop-用户空间代码">Opensnoop 用户空间代码</h3>
<p>正如我所提到的，与 eBPF 代码交互的用户空间代码几乎可以用任何编程语言编写。我们将在本节讨论的示例是用 C 编写的，但如果你有兴趣，可以将其与用 Python 编写的原始 BCC 版本进行比较，你可以在 bcc/tools 中找到它。</p>
<p>用户空间代码在 opensnoop.c 文件中。文件的前半部分有 #include 指令（其中一个是自动生成的 opensnoop.skel.h 文件）、各种定义以及处理不同命令行选项的代码，我们不会在这里详述。让我们也略过诸如 print_event() 之类的函数，它将有关事件的信息写入屏幕。从 eBPF 的角度来看，所有有趣的代码都在 main() 函数中。</p>
<p>你将看到诸如 <code>opensnoop_bpf__open()</code>、<code>open snoop_bpf__load()</code> 和 <code>opensnoop_bpf__attach()</code> 之类的函数。这些都是在<code> bpftool gen</code> 脚手架创建的自动生成代码中定义的。10 自动生成的代码处理在 eBPF 目标文件中定义的所有单独的 eBPF 程序、map 和附加点。</p>
<p>一旦 opensnoop 启动并运行，其工作就是监听事件 perf 缓冲区并将事件中包含的信息写入屏幕。首先，它打开与 perf 缓冲区关联的文件描述符，并将 handle_event() 设置为新事件到达时的调用的函数：</p>
<div><pre class="hljs"><code>     pb = perf_buffer__new(bpf_map__fd(obj-&gt;maps.events),
         PERF_BUFFER_PAGES, handle_event, handle_lost_events,
         <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);</code></pre></div>
<p>然后程序轮询缓冲区事件，直到达到时间限制，或者用户中断程序：</p>
<div><pre class="hljs"><code>     <span class="hljs-keyword">while</span> (!exiting) {
              err = perf_buffer__poll(pb, PERF_POLL_TIMEOUT_MS);
       ... 
     }</code></pre></div>
<p>传递给 handle_event() 的数据参数指向 eBPF 程序为该事件写入 map 的事件结构。用户空间代码可以获取此信息，对其进行格式化并将供用户查看。</p>
<p>正如你所见，opensnoop 注册了 eBPF 程序，每次任何应用程序调用 open() 或 openat() 系统调用时都会调用 eBPF 程序。这些在内核中运行的 eBPF 程序收集有关该系统调用的上下文的信息——可执行文件名称和进程 ID——以及有关正在打开的文件的信息。此信息被写入 map，用户空间可以从中读取它并将其显示给用户。</p>
<p>你可以在 libbpf-tools 目录中找到数十个类似的 eBPF 工具示例，每个示例通常检测一个系统调用或一系列相关的系统调用，如 open() 和 openat()。</p>
<p>系统调用是一个稳定的内核接口，它们提供了一种非常强大的方式来观察（虚拟）机器上发生的事情。但不要误以为 eBPF 编程开始和结束于拦截系统调用。除此之外，还有很多其他稳定的接口用于附加 eBPF 程序，包括 LSM 和网络栈中的各个挂载点。如果愿意冒险或解决内核版本之间的更改，那么你可以附加 eBPF 程序的地方范围将会非常广泛。</p>
<blockquote>
<ol>
<li>请参阅 <a title="https://docs.cilium.io/en/stable/bpf/#instruction-set" href="https://docs.cilium.io/en/stable/bpf/#instruction-set">BPF 指令集文档</a>。</li>
<li>Brendan Gregg 的网站是一个很好的关于<a title="https://www.brendangregg.com/perf.html" href="https://www.brendangregg.com/perf.html">perf event</a>的信息来源。<br />
如果你有兴趣看到一个具体的例子，你可能想看我在 <a title="https://oreil.ly/K6jLs" href="https://oreil.ly/K6jLs">2021 年 eBPF 峰会</a>上的演讲，我在几分钟内实现了一个非常基本的负载均衡器，作为我们如何使用的说明 eBPF 改变内核处理网络数据包的方式<br />
在撰写本文时，此代码为事件 map 使用 perf 缓冲区。如果今天为最近的内核编写此代码，你将从 <a title="https://nakryiko.com/posts/bpf-ringbuf/#bpf-ringbuf-vs-bpf-perfbuf" href="https://nakryiko.com/posts/bpf-ringbuf/#bpf-ringbuf-vs-bpf-perfbuf">ring buffer</a> 缓冲区获得更好的性能，这是一种较新的替代方案<br />
参见 Andrii Nakryiko 描述 BPF 脚手架代码生成的<a title="https://lwn.net/Articles/806328/" href="https://lwn.net/Articles/806328/">帖子</a></li>
</ol>
</blockquote>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[K8s Code-Generator工具概览]]></title>
            <guid>7f35bf7cd74c4c79afbbb5e0a9bd1b5e</guid>
            <pubDate>Fri, 16 Dec 2022 07:38:37 GMT</pubDate>
            <content:encoded><![CDATA[<blockquote>
<p><a title="https://github.com/kubernetes/code-generator" href="https://github.com/kubernetes/code-generator">Code-Generator工具</a> 生成Kubernets风格的API类型</p>
</blockquote>
<p><code>k8s.io/client-go</code>提供了对k8s原生资源的informer和clientset等等，但对于自定义资源的操作则相对低效，需要使用 rest api 和 dynamic client 来操作，并自己实现反序列化等功能。</p>
<p><code>code-generator</code> 提供了以下工具用于为k8s中的资源生成相关代码，可以更加方便的操作自定义资源：</p>
<ul>
<li><code>deepcopy-gen</code>: 生成深度拷贝对象方法
<ul>
<li>在文件中添加注释<code>// +k8s:deepcopy-gen=package</code></li>
<li>为单个类型添加自动生成<code>// +k8s:deepcopy-gen=true</code></li>
<li>为单个类型关闭自动生成<code>// +k8s:deepcopy-gen=false</code></li>
</ul>
</li>
<li><code>client-gen</code>: 为资源生成标准的操作方法(get;list;watch;create;update;patch;delete) 在<code>pkg/apis/${GROUP}/${VERSION}/types.go</code>中使用，使用<code>// +genclient</code>标记对应类型生成的客户端，如果与该类型相关联的资源不是命名空间范围的(例如PersistentVolume), 则还需要附加<code>// + genclient：nonNamespaced</code>标记
<ul>
<li><code>// +genclient</code>:  生成默认的客户端动作函数（create, update, delete, get, list, update, patch, watch以及 是否生成updateStatus取决于.Status字段是否存在）</li>
<li><code>// +genclient:nonNamespaced</code>: 所有动作函数都是在没有名称空间的情况下生成</li>
<li><code>// +genclient:onlyVerbs=create,get</code>: 指定的动作函数被生成</li>
<li><code>// +genclient:skipVerbs=watch</code>: 生成watch以外所有的动作函数</li>
<li><code>// +genclient:noStatus</code>: 即使.Status字段存在也不生成updateStatus动作函数</li>
</ul>
</li>
<li><code>informer-gen</code>: 生成informer，提供事件机制(AddFunc,UpdateFunc,DeleteFunc)来响应kubernetes的event</li>
<li><code>lister-gen</code>: 为get和list方法提供只读缓存层</li>
<li><code>conversion-gen</code>: 是用于自动生成在内部和外部类型之间转换的函数的工具<br />
一般的转换代码生成任务涉及三套程序包：
<ul>
<li>一套包含内部类型的程序包</li>
<li>一套包含外部类型的程序包</li>
<li>单个目标程序包（即，生成的转换函数所在的位置，以及开发人员授权的转换功能所在的位置）, 包含内部类型的包在Kubernetes的常规代码生成框架中扮演着称为<code>peer package</code>的角色<br />
使用方法</li>
<li><code>// +k8s:conversion-gen=&lt;import-path-of-internal-package&gt;</code>: 标记转换内部软件包</li>
<li><code>// +k8s:conversion-gen-external-types=&lt;import-path-of-external-package&gt;</code>: 标记转换外部软件包</li>
<li><code>// +k8s:conversion-gen=false</code>: 标记不转换对应注释或结构</li>
</ul>
</li>
<li><code>defaulter-gen</code>: 用于生产Defaulter函数
<ul>
<li><code>// +k8s:defaulter-gen=&lt;field-name-to-flag&gt;</code>: 为包含字段的所有类型创建defaulters</li>
<li><code>// +k8s:defaulter-gen=true|false</code>: 所有都生成</li>
</ul>
</li>
<li><code>go-to-protobuf</code>: 通过go struct生成pb idl</li>
<li><code>import-boss</code>: 在给定存储库中强制执行导入限制</li>
<li><code>openapi-gen</code>: 生成openAPI定义<br />
使用方法：
<ul>
<li><code>+k8s:openapi-gen=true</code>: 为指定包或方法开启</li>
<li><code>+k8s:openapi-gen=false</code>: 指定包关闭</li>
</ul>
</li>
<li><code>register-gen</code>: 生成register</li>
<li><code>set-gen</code><br />
code-generator整合了这些gen，使用脚本<a title="https://github.com/kubernetes/code-generator/blob/master/generate-groups.sh" href="https://github.com/kubernetes/code-generator/blob/master/generate-groups.sh">generate-groups.sh</a>和<a title="https://github.com/kubernetes/code-generator/blob/master/generate-internal-groups.sh" href="https://github.com/kubernetes/code-generator/blob/master/generate-internal-groups.sh">generate-internal-groups.sh</a>可以为自定义资源生产相关代码。</li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Code-Generator 生成crd的clientset、informer、listers]]></title>
            <guid>be1a77beec5a4d11a3a886d59e7cea33</guid>
            <pubDate>Fri, 16 Dec 2022 07:35:50 GMT</pubDate>
            <content:encoded><![CDATA[<blockquote>
<p><a title="https://github.com/kubernetes/code-generator" href="https://github.com/kubernetes/code-generator">Code-Generator工具</a> 生成Kubernets风格的API类型</p>
</blockquote>
<p><code>k8s.io/client-go</code>提供了对k8s原生资源的informer和clientset等等，但对于自定义资源的操作则相对低效，需要使用 rest api 和 dynamic client 来操作，并自己实现反序列化等功能。</p>
<p><code>code-generator</code> 提供了以下工具用于为k8s中的资源生成相关代码，可以更加方便的操作自定义资源：</p>
<ul>
<li><code>deepcopy-gen</code>: 生成深度拷贝对象方法
<ul>
<li>在文件中添加注释<code>// +k8s:deepcopy-gen=package</code></li>
<li>为单个类型添加自动生成<code>// +k8s:deepcopy-gen=true</code></li>
<li>为单个类型关闭自动生成<code>// +k8s:deepcopy-gen=false</code></li>
</ul>
</li>
<li><code>client-gen</code>: 为资源生成标准的操作方法(get;list;watch;create;update;patch;delete) 在<code>pkg/apis/${GROUP}/${VERSION}/types.go</code>中使用，使用<code>// +genclient</code>标记对应类型生成的客户端，如果与该类型相关联的资源不是命名空间范围的(例如PersistentVolume), 则还需要附加<code>// + genclient：nonNamespaced</code>标记
<ul>
<li><code>// +genclient</code>:  生成默认的客户端动作函数（create, update, delete, get, list, update, patch, watch以及 是否生成updateStatus取决于.Status字段是否存在）</li>
<li><code>// +genclient:nonNamespaced</code>: 所有动作函数都是在没有名称空间的情况下生成</li>
<li><code>// +genclient:onlyVerbs=create,get</code>: 指定的动作函数被生成</li>
<li><code>// +genclient:skipVerbs=watch</code>: 生成watch以外所有的动作函数</li>
<li><code>// +genclient:noStatus</code>: 即使.Status字段存在也不生成updateStatus动作函数</li>
</ul>
</li>
<li><code>informer-gen</code>: 生成informer，提供事件机制(AddFunc,UpdateFunc,DeleteFunc)来响应kubernetes的event</li>
<li><code>lister-gen</code>: 为get和list方法提供只读缓存层</li>
<li><code>conversion-gen</code>: 是用于自动生成在内部和外部类型之间转换的函数的工具<br />
一般的转换代码生成任务涉及三套程序包：
<ul>
<li>一套包含内部类型的程序包</li>
<li>一套包含外部类型的程序包</li>
<li>单个目标程序包（即，生成的转换函数所在的位置，以及开发人员授权的转换功能所在的位置）, 包含内部类型的包在Kubernetes的常规代码生成框架中扮演着称为<code>peer package</code>的角色<br />
使用方法</li>
<li><code>// +k8s:conversion-gen=&lt;import-path-of-internal-package&gt;</code>: 标记转换内部软件包</li>
<li><code>// +k8s:conversion-gen-external-types=&lt;import-path-of-external-package&gt;</code>: 标记转换外部软件包</li>
<li><code>// +k8s:conversion-gen=false</code>: 标记不转换对应注释或结构</li>
</ul>
</li>
<li><code>defaulter-gen</code>: 用于生产Defaulter函数
<ul>
<li><code>// +k8s:defaulter-gen=&lt;field-name-to-flag&gt;</code>: 为包含字段的所有类型创建defaulters</li>
<li><code>// +k8s:defaulter-gen=true|false</code>: 所有都生成</li>
</ul>
</li>
<li><code>go-to-protobuf</code>: 通过go struct生成pb idl</li>
<li><code>import-boss</code>: 在给定存储库中强制执行导入限制</li>
<li><code>openapi-gen</code>: 生成openAPI定义<br />
使用方法：
<ul>
<li><code>+k8s:openapi-gen=true</code>: 为指定包或方法开启</li>
<li><code>+k8s:openapi-gen=false</code>: 指定包关闭</li>
</ul>
</li>
<li><code>register-gen</code>: 生成register</li>
<li><code>set-gen</code><br />
code-generator整合了这些gen，使用脚本<a title="https://github.com/kubernetes/code-generator/blob/master/generate-groups.sh" href="https://github.com/kubernetes/code-generator/blob/master/generate-groups.sh">generate-groups.sh</a>和<a title="https://github.com/kubernetes/code-generator/blob/master/generate-internal-groups.sh" href="https://github.com/kubernetes/code-generator/blob/master/generate-internal-groups.sh">generate-internal-groups.sh</a>可以为自定义资源生产相关代码。</li>
</ul>
<h2 id="kubebuilder">kubebuilder</h2>
<blockquote>
<p>Kubebuilder是用于使用 <a title="https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/" href="https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/">自定义资源定义（CRD）</a> 构建Kubernetes API的框架。</p>
<p>类似于Ruby on Rails和SpringBoot之类的Web开发框架，Kubebuilder可以提高速度并降低开发人员管理的复杂性，以便在Go中快速构建和发布Kubernetes API。它建立在用于构建核心Kubernetes API的规范技术的基础之上，以提供减少样板和麻烦的简单抽象。</p>
<p>Resource + Controller = Operator，可以利用Kubebuilder编写自定义资源的Operator。</p>
</blockquote>
<h3 id="结合背景">结合背景</h3>
<p><code>Kubebuilder</code> 与 <code>code-generator</code> 都可以为CRD生成Kubernetes API相关代码，从代码生成层面来讲， 两者的区别在于</p>
<ul>
<li>Kubebuilder不会生成informers、listers、clientsets，而code-generator会。</li>
<li>Kubebuilder会生成Controller、Admission Webhooks，而code-generator不会。</li>
<li>Kubebuilder会生成manifests yaml，而code-generator不会。</li>
<li>Kubebuilder还带有一些其他便利性设施。</li>
</ul>
<p>使用Kubebuilder可以快捷生成CRD以及相关的控制器框架，然而由于Kubebuilder不会生成clientset等包，当别的服务想要操作CRD时将会很麻烦。</p>
<p>两者结合后可以使用Kubebuilder生成CRD和一整套控制器架构，再使用code-generator生成informers、listers、clientsets等。</p>
<h3 id="初始化项目">初始化项目</h3>
<h4 id="创建一个项目">创建一个项目</h4>
<div><pre class="hljs"><code>[root@kubebuilder ~]<span class="hljs-comment"># mkdir -p $GOPATH/src/my.domain/example</span>
[root@kubebuilder ~]<span class="hljs-comment"># cd $GOPATH/src/my.domain/example</span>
[root@kubebuilder example]<span class="hljs-comment"># kubebuilder init --domain my.domain </span>
[root@kubebuilder example]<span class="hljs-comment"># tree -CL 2</span>
.
├── config
│   ├── default
│   ├── manager
│   ├── prometheus
│   └── rbac
├── Dockerfile
├── go.mod
├── go.sum
├── hack
│   └── boilerplate.go.txt
├── main.go
├── Makefile
└── PROJECT</code></pre></div>
<h4 id="创建一个api">创建一个api</h4>
<div><pre class="hljs"><code>[root@kubebuilder example]<span class="hljs-comment"># kubebuilder create api --group example --version v1 --kind Guestbook</span>
Create Resource [y/n]
y
Create Controller [y/n]
y
...

[root@kubebuilder example]<span class="hljs-comment"># tree -CL 3</span>
.
├── api
│   └── v1
│       ├── groupversion_info.go
│       ├── guestbook_types.go
│       └── zz_generated.deepcopy.go
├── bin
│   └── controller-gen
├── config
│   ├── crd
│   │   ├── kustomization.yaml
│   │   ├── kustomizeconfig.yaml
│   │   └── patches
│   ├── default
│   │   ├── kustomization.yaml
│   │   ├── manager_auth_proxy_patch.yaml
│   │   └── manager_config_patch.yaml
│   ├── manager
│   │   ├── controller_manager_config.yaml
│   │   ├── kustomization.yaml
│   │   └── manager.yaml
│   ├── prometheus
│   │   ├── kustomization.yaml
│   │   └── monitor.yaml
│   ├── rbac
│   │   ├── auth_proxy_client_clusterrole.yaml
│   │   ├── auth_proxy_role_binding.yaml
│   │   ├── auth_proxy_role.yaml
│   │   ├── auth_proxy_service.yaml
│   │   ├── guestbook_editor_role.yaml
│   │   ├── guestbook_viewer_role.yaml
│   │   ├── kustomization.yaml
│   │   ├── leader_election_role_binding.yaml
│   │   ├── leader_election_role.yaml
│   │   ├── role_binding.yaml
│   │   └── service_account.yaml
│   └── samples
│       └── example_v1_guestbook.yaml
├── controllers
│   ├── guestbook_controller.go
│   └── suite_test.go
├── Dockerfile
├── go.mod
├── go.sum
├── hack
│   └── boilerplate.go.txt
├── main.go
├── Makefile
└── PROJECT</code></pre></div>
<p>注意：<br />
如果修改了<code>api/v1/guestbook_types.go</code>，需要执行以下命令来更新代码和manifests：</p>
<div><pre class="hljs"><code>make &amp;&amp; make manifests</code></pre></div>
<h4 id="使用code-generator">使用code-generator</h4>
<h5 id="更新依赖版本">更新依赖版本</h5>
<p>初始化项目后的go.mod：</p>
<div><pre class="hljs"><code>[root@kubebuilder example]<span class="hljs-comment"># cat go.mod</span>
module my.domain

go 1.16

require (
    github.com/onsi/ginkgo v1.14.1
    github.com/onsi/gomega v1.10.2
    k8s.io/apimachinery v0.20.2
    k8s.io/client-go v0.20.2
    sigs.k8s.io/controller-runtime v0.8.3
)</code></pre></div>
<p>需要将初始化的k8s库更新到要使用的版本，如：</p>
<div><pre class="hljs"><code>[root@kubebuilder example]<span class="hljs-comment"># K8S_VERSION=v0.18.6</span>
[root@kubebuilder example]<span class="hljs-comment"># go get k8s.io/client-go@$K8S_VERSION</span>
[root@kubebuilder example]<span class="hljs-comment"># go get k8s.io/apimachinery@$K8S_VERSION</span></code></pre></div>
<h5 id="安装code-generator">安装code-generator</h5>
<p>k8s的版本号与 go.mod 中的 k8s.io/client-go 的版本保持一致即可。</p>
<p>**注意：**需要将依赖复制到vendor中</p>
<div><pre class="hljs"><code>最新版本已经不包含， github.com/googleapis/gnostic/OpenAPIv2 ，如果不改版本会报如下错误
...
    github.com/googleapis/gnostic/OpenAPIv2: module github.com/googleapis/gnostic@latest found (v0<span class="hljs-number">.5</span><span class="hljs-number">.5</span>), but does not contain <span class="hljs-keyword">package</span> github.com/googleapis/gnostic/OpenAPIv2
Error: failed to create API: unable to run post-scaffold tasks of <span class="hljs-string">"base.go.kubebuilder.io/v3"</span>: exit status <span class="hljs-number">1</span>
...
[root@kubebuilder example]# <span class="hljs-keyword">go</span> get github.com/googleapis/gnostic@v0<span class="hljs-number">.4</span><span class="hljs-number">.0</span>

[root@kubebuilder example]# <span class="hljs-keyword">go</span> get k8s.io/code-generator@$K8S_VERSION
[root@kubebuilder example]# <span class="hljs-keyword">go</span> mod vendor</code></pre></div>
<h5 id="创建修改所需文件">创建&amp;修改所需文件</h5>
<p>需要在api目录下创建code-generator所需的文件，并添加相关注释。</p>
<ul>
<li>新增 <code>api/v1/doc.go</code>,<br />
<strong>注意</strong>: 修改groupName，package与api的version保持一致。</li>
</ul>
<div><pre class="hljs"><code>[root@kubebuilder example]# cat api/v1/doc.<span class="hljs-keyword">go</span>
<span class="hljs-comment">// +k8s:deepcopy-gen=package</span>
 
<span class="hljs-comment">// Package v1 is the v1alpha1 version of the API.</span>
<span class="hljs-comment">// +groupName=example.my.domain</span>
<span class="hljs-keyword">package</span> v1</code></pre></div>
<ul>
<li>新增<code>api/v1/register.go</code><br />
<strong>注意</strong>: package与api的version保持一致</li>
</ul>
<div><pre class="hljs"><code>[root@kubebuilder example]# cat api/v1/register.<span class="hljs-keyword">go</span>
<span class="hljs-keyword">package</span> v1
  
<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"k8s.io/apimachinery/pkg/runtime/schema"</span>
)
  
<span class="hljs-comment">// SchemeGroupVersion is group version used to register these objects.</span>
<span class="hljs-keyword">var</span> SchemeGroupVersion = GroupVersion
  
<span class="hljs-comment">// Resource takes an unqualified resource and returns a Group qualified GroupResource</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Resource</span><span class="hljs-params">(resource <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">schema</span>.<span class="hljs-title">GroupResource</span></span> {
    <span class="hljs-keyword">return</span> SchemeGroupVersion.WithResource(resource).GroupResource()
}</code></pre></div>
<ul>
<li>修改<code>api/v1/{crd}_types.go</code>文件，添加注释<code> // +genclient</code></li>
</ul>
<div><pre class="hljs"><code>[root@kubebuilder example]# cat api/v1/guestbook_types.<span class="hljs-keyword">go</span>
...
<span class="hljs-comment">// +genclient</span>
<span class="hljs-comment">//+kubebuilder:object:root=true</span>

<span class="hljs-comment">// GuestbookList contains a list of Guestbook</span>
<span class="hljs-keyword">type</span> GuestbookList <span class="hljs-keyword">struct</span> {
...</code></pre></div>
<h5 id="准备脚本">准备脚本</h5>
<p>在项目 <code>hack</code> 目录下准备以下文件：</p>
<ul>
<li><code>hack/tools.go</code></li>
</ul>
<div><pre class="hljs"><code>[root@kubebuilder example]# cat hack/tools.<span class="hljs-keyword">go</span>
<span class="hljs-comment">// +build tools</span>
  
<span class="hljs-keyword">package</span> tools
  
<span class="hljs-keyword">import</span> _ <span class="hljs-string">"k8s.io/code-generator"</span></code></pre></div>
<ul>
<li><code>hack/update-codegen.sh</code><br />
<code>MODULE</code> 和 <code>go.mod</code> 保持一致<br />
<code>API_PKG=api</code>，和 <code>api</code> 目录保持一致<br />
<code>OUTPUT_PKG=generated/example</code>，与生成Resource时指定的group保持一致<br />
<code>GROUP=example</code>， 和生成Resource时指定的group 保持一致<br />
<code>VERSION=v1</code>， 和生成Resource时指定的version保持一致</li>
</ul>
<div><pre class="hljs"><code>[root@kubebuilder example]<span class="hljs-comment"># cat ./hack/update-codegen.sh</span>
<span class="hljs-comment">#!/usr/bin/env bash</span>
<span class="hljs-comment">#表示有报错即退出 跟set -e含义一样</span>
<span class="hljs-built_in">set</span> -o errexit
<span class="hljs-comment">#执行脚本的时候，如果遇到不存在的变量，Bash 默认忽略它 ,跟 set -u含义一样</span>
<span class="hljs-built_in">set</span> -o nounset
<span class="hljs-comment"># 只要一个子命令失败，整个管道命令就失败，脚本就会终止执行 </span>
<span class="hljs-built_in">set</span> -o pipefail
  
<span class="hljs-comment">#kubebuilder项目的MODULE</span>
MODULE=my.domain/example
  
<span class="hljs-comment">#api包</span>
APIS_PKG=api
  
<span class="hljs-comment">#代码生出输出，生成Resource时指定的group一样</span>
OUTPUT_PKG=generated/example
  
<span class="hljs-comment"># group-version such as cronjob:v1</span>
GROUP=example
VERSION=v1
GROUP_VERSION=<span class="hljs-variable">$GROUP</span>:<span class="hljs-variable">$VERSION</span>
  
SCRIPT_ROOT=$(dirname <span class="hljs-string">"<span class="hljs-variable">${BASH_SOURCE[0]}</span>"</span>)/..
CODEGEN_PKG=<span class="hljs-variable">${CODEGEN_PKG:-$(cd "<span class="hljs-variable">${SCRIPT_ROOT}</span>"; ls -d -1 ./vendor/k8s.io/code-generator 2&gt;/dev/null || echo ../code-generator)}</span>
  
<span class="hljs-comment"># kubebuilder2.3.2版本生成的api目录结构code-generator无法直接使用</span>
rm -rf <span class="hljs-string">"<span class="hljs-variable">${APIS_PKG}</span>/<span class="hljs-variable">${GROUP}</span>"</span> &amp;&amp; mkdir -p <span class="hljs-string">"<span class="hljs-variable">${APIS_PKG}</span>/<span class="hljs-variable">${GROUP}</span>"</span> &amp;&amp; cp -r <span class="hljs-string">"<span class="hljs-variable">${APIS_PKG}</span>/<span class="hljs-variable">${VERSION}</span>/"</span> <span class="hljs-string">"<span class="hljs-variable">${APIS_PKG}</span>/<span class="hljs-variable">${GROUP}</span>"</span>
  
<span class="hljs-comment"># generate the code with:</span>
<span class="hljs-comment"># --output-base    because this script should also be able to run inside the vendor dir of</span>
<span class="hljs-comment">#                  k8s.io/kubernetes. The output-base is needed for the generators to output into the vendor dir</span>
<span class="hljs-comment">#                  instead of the $GOPATH directly. For normal projects this can be dropped.</span>
<span class="hljs-comment">#client,informer,lister(注意: code-generator 生成的deepcopy不适配 kubebuilder 所生成的api)</span>
bash <span class="hljs-string">"<span class="hljs-variable">${CODEGEN_PKG}</span>"</span>/generate-groups.sh <span class="hljs-string">"client,informer,lister"</span> \
  <span class="hljs-variable">${MODULE}</span>/<span class="hljs-variable">${OUTPUT_PKG}</span> <span class="hljs-variable">${MODULE}</span>/<span class="hljs-variable">${APIS_PKG}</span> \
  <span class="hljs-variable">${GROUP_VERSION}</span> \
  --go-header-file <span class="hljs-string">"<span class="hljs-variable">${SCRIPT_ROOT}</span>"</span>/hack/boilerplate.go.txt
<span class="hljs-comment">#  --output-base "${SCRIPT_ROOT}"</span>
<span class="hljs-comment">#  --output-base "${SCRIPT_ROOT}/../../.."</span></code></pre></div>
<p><strong>注意</strong>:</p>
<ul>
<li>
<p>kubebuilder2.3.2版本生成的api目录结构code-generator无法直接使用，需要在sh脚本中进行处理。</p>
</li>
<li>
<p>修改脚本执行参数可以选择生成的代码，如：“client,informer,lister”。</p>
</li>
<li>
<p>无需再次生成deepcopy：code-generator 生成的deepcopy不适配 kubebuilder 所生成的api。</p>
</li>
<li>
<p><code>Makefile</code>添加生成命令</p>
</li>
</ul>
<div><pre class="hljs"><code>[root@kubebuilder example]<span class="hljs-comment"># chmod +x hack/update-codegen.sh </span>
[root@kubebuilder example]<span class="hljs-comment"># vim Makefile</span>
 71 update-codegen: <span class="hljs-comment">## generetor clientset informer inderx code</span>
 72         ./hack/update-codegen.sh</code></pre></div>
<h5 id="生成代码">生成代码</h5>
<p>项目根目录下执行<code>make update-codegen</code>即可，将生成如下代码结构：</p>
<div><pre class="hljs"><code>[root@kubebuilder example]<span class="hljs-comment"># tree  generated/</span>
generated/
└── example
    ├── clientset
    │   └── versioned
    │       ├── clientset.go
    │       ├── doc.go
    │       ├── fake
    │       │   ├── clientset_generated.go
    │       │   ├── doc.go
    │       │   └── register.go
    │       ├── scheme
    │       │   ├── doc.go
    │       │   └── register.go
    │       └── typed
    │           └── example
    │               └── v1
    │                   ├── doc.go
    │                   ├── example_client.go
    │                   ├── fake
    │                   │   ├── doc.go
    │                   │   ├── fake_example_client.go
    │                   │   └── fake_guestbook.go
    │                   ├── generated_expansion.go
    │                   └── guestbook.go
    ├── informers
    │   └── externalversions
    │       ├── example
    │       │   ├── interface.go
    │       │   └── v1
    │       │       ├── guestbook.go
    │       │       └── interface.go
    │       ├── factory.go
    │       ├── generic.go
    │       └── internalinterfaces
    │           └── factory_interfaces.go
    └── listers
        └── example
            └── v1
                ├── expansion_generated.go
                └── guestbook.go</code></pre></div>
<p>之后便可以通过clientset等包对自定义资源对象进行操作。</p>
<p><strong>注意事项：</strong><br />
<code>kubebuilder2.3.2</code>版本生成的api目录结构为 <code>api/v1</code>，而<code>code-generator</code>需要的api目录结构为 <code>api/example/v1</code>，相比较增加了<code>group</code>这一层。</p>
<ul>
<li><code>hack/update-codegen.sh</code> 脚本会自动根据kubebuilder的api生成code-generator所需目录结构。</li>
<li><code>code-generator</code> 生成的deepcopy不适配 kubebuilder 所生成的api。</li>
<li><code>code-generator</code> 生成代码后再次使用make操作时可能由于生成的代码影响命令正常执行，例如： <code>make manifests</code> 在生成CRD模版时，需先删除api以及generated目录中为code-generator生成的代码，才可正常生成CRD模版。</li>
<li>使用时kubebuilder正常使用 <code>api/v1</code> 中的types，而code-generator生成的clientset等则需要使用 <code>api/example/v1</code> 中的types。</li>
</ul>
]]></content:encoded>
        </item>
    </channel>
</rss>