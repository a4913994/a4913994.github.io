<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title></title>
        <link>undefined</link>
        <description>undefined</description>
        <lastBuildDate>Tue, 31 Jan 2023 14:48:16 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>Joplin Pages Publisher</generator>
        <item>
            <title><![CDATA[BTFGen: 让 eBPF 程序可移植发布更近一步]]></title>
            <guid>f14b5b38df1f4a5d8ad1745dbfde1eb1</guid>
            <pubDate>Fri, 06 Jan 2023 02:28:46 GMT</pubDate>
            <content:encoded><![CDATA[<nav class="table-of-contents"><ul><li><a href="#1-问题所在">1. 问题所在</a></li><li><a href="#2-co-re-一次编译-到处运行">2. CO-RE (一次编译 - 到处运行)</a></li><li><a href="#3-btfhub">3. BTFHub</a></li><li><a href="#4-btfgen">4. BTFGen</a><ul><li><a href="#41-内部实现细节">4.1 内部实现细节</a></li></ul></li><li><a href="#42-如何使用">4.2 如何使用?</a><ul><li><a href="#安装-bpftool-工具">安装 bpftool 工具</a></li><li><a href="#从-bfthub-获取内核对应的-btf-文件">从 BFThub 获取内核对应的 BTF 文件</a></li><li><a href="#下载-修改和编译-bcc-libbpf-工具">下载、修改和编译 BCC libbpf 工具</a></li><li><a href="#生成-精简版-btf-文件">生成 “精简版” BTF 文件</a></li><li><a href="#验证">验证</a></li><li><a href="#43-集成样例">4.3 集成样例</a><ul><li><a href="#inspektor-gadget">Inspektor Gadget</a></li><li><a href="#tracee">Tracee</a></li></ul></li><li><a href="#44-限制">4.4 限制</a></li><li><a href="#45-未来发展">4.5 未来发展</a><ul><li><a href="#与其他项目的整合">与其他项目的整合</a></li><li><a href="#删除重复的文件">删除重复的文件</a></li><li><a href="#在线-api">在线 API</a></li></ul></li></ul></li><li><a href="#5-更多信息">5. 更多信息</a></li><li><a href="#6-致谢">6. 致谢</a></li></ul></nav><p>eBPF 是一项广为人知的技术，已经在可观测、网络和安全领域领域得到广泛应用。Linux 操作系统提供了虚拟机，可用于安全和高效的方式运行 eBPF 程序【译者注：如果是 JIT 模式则会直接翻译成本地 CPU 指令，则不需要虚拟机】。eBPF 程序挂载在操作系统提供的钩子上，使其能够在内核中发生特定事件时过滤和提取感兴趣的信息。</p>
<p>在本文中，我们将介绍助力 eBPF 程序移植的工具 BTFGen，以及其如何被集成到其他项目中，主要的内容如下：</p>
<ul>
<li>在不同的目标机器上运行 eBPF 程序的挑战；</li>
<li>传统上如何通过在加载程序之前通过编译解决的；</li>
<li>解决挑战对应的的机制/工具（如 CO-RE 一次编译 - 到处运行）；</li>
<li>BTFHub 工具如何尝试解决这些挑战。</li>
</ul>
<h2 id="1-问题所在">1. 问题所在</h2>
<p>eBPF 程序需要访问内核结构来获取需要的数据，因此依赖于内核结构的布局。为特定内核版本编译的 eBPF 程序通常不能在另一个内核版本上工作，这是因为相关的内核数据结构布局可能会发生了变化：比如字段添加、删除，或类型被改变，甚至内核编译配置的改变也会改变整个结构布局。例如，禁用 <code>CONFIG_THREAD_INFO_IN_TASK</code> 会改变 <a title="https://github.com/torvalds/linux/blob/v5.16/include/linux/sched.h#L723" href="https://github.com/torvalds/linux/blob/v5.16/include/linux/sched.h#L723">task_struct</a> 的所有成员变量的偏移：</p>
<div><pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> {</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_THREAD_INFO_IN_TASK</span>
    <span class="hljs-comment">/*
     * For reasons of header soup (see current_thread_info()), this
     * must be the first element of task_struct.
     */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_info</span>		<span class="hljs-title">thread_info</span>;</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>			__state;

<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PREEMPT_RT</span>
    <span class="hljs-comment">/* saved state for "spinlock sleepers" */</span>
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>			saved_state;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
...</code></pre></div>
<p>该问题的解决通常是在目标机器使用内核头文件编译 eBPF 程序并进行加载，<a title="https://github.com/iovisor/bcc/" href="https://github.com/iovisor/bcc/">BCC</a> 项目所使用的正是这种方式。但该方法存在以下问题：</p>
<ol>
<li>必须在目标机器上安装占用大量空间的编译器；</li>
<li>编译程序时需要资源，在某些情况下可能会影响工作负载的调度；</li>
<li>编译需要相当长的时间，因此事件采集会存在一些延迟；</li>
<li>依赖于目标机器上安装内核头文件包。</li>
</ol>
<h2 id="2-co-re-一次编译-到处运行">2. CO-RE (一次编译 - 到处运行)</h2>
<p>CO-RE 机制正是为解决上述问题提出的方案。在该方案中，eBPF 程序一次编译，然后在运行时进行更新（patched）：基于运行的机器的内核结构布局更新运行指令。<a title="https://nakryiko.com/posts/bpf-portability-and-co-re" href="https://nakryiko.com/posts/bpf-portability-and-co-re">BPF CO-RE (Compile Once - Run Everywhere)</a> 介绍了该技术背后的所有细节。对于本文，需要理解的是 CO-RE 需要有目标内核的 BTF 信息（BPF Type Format 类型格式）。BTF 信息由内核本身提供的，这需要在内核编译时设置 <code>CONFIG_DEBUG_INFO_BTF=y</code> 选项 。该选项在<a title="https://github.com/torvalds/linux/commit/e83b9f55448afce3fe1abcd1d10db9584f8042a6" href="https://github.com/torvalds/linux/commit/e83b9f55448afce3fe1abcd1d10db9584f8042a6">Linux 内核 5.2</a> 中引入的，许多流行的 Linux 发行版在其后的部分内核版本才默认启用。这意味着有很多用户运行的内核并没有导出 BTF 信息，因此不能使用基于 CO-RE 的工具。</p>
<h2 id="3-btfhub">3. BTFHub</h2>
<p><a title="https://github.com/aquasecurity/btfhub" href="https://github.com/aquasecurity/btfhub">BTFHub</a> 是 Aqua Security 公司的一个项目，其可为不导出 BTF 信息的流行发行版内核提供BTF 信息补充。目标内核的 BTF 文件可以在运行时下载，然后与加载库（libbpf、cilium/ebpf 或其他）配合，加载库基于 BTF 文件对程序进行相应的更新（patch）。</p>
<p>尽管 BTFHub 做了很大的改进，但是它仍然面临着一些挑战：每个 BTF 文件有数 MB 大小，因此不可能把所有内核的 BTF 文件和应用程序一起打包，因为这可能需要数 GB 的空间占用。另一种方法是在运行时下载当前内核的所需 BTF，但这也带来了一些问题：延迟 eBPF 程序启动，而且在某些情况下，连接到外部主机下载文件也不可行。</p>
<h2 id="4-btfgen">4. BTFGen</h2>
<p>其实，通常我们并不需要提供描述所有内核类型的完整 BTF 文件，因为 eBPF 程序通常只需要访问其中的少数类型。一个 “精简版” 的 BTF 文件，只需要提供程序使用类型的信息就足够了。这就是工具 BTFGen 发挥作用：其可以生成一组 eBPF 程序所需的精简的 BTF ，通过该方式生成的 BTF 文件只有数 KB 大小，将其与应用程序打包交付变成了可能。</p>
<p>BTFGen 并不是单独提供能力的。它需要具有不同 Linux 发行版的所有内核类型的源 BTF 文件（由 BTFHub 提供），并且 CO-RE 机制（在libbpf、Linux内核或另一个加载库中）在加载程序时通过打补丁方式更新 eBPF 程序。</p>
<p>使用 BTFGen 的主要流程如下：</p>
<ol>
<li>开发人员编写<a title="https://nakryiko.com/posts/bpf-core-reference-guide/" href="https://nakryiko.com/posts/bpf-core-reference-guide/">基于 CO-RE</a> 的 eBPF 程序，并通过 llvm/clang 编译成对象文件；</li>
<li>从 BTFHub 或其他来源收集不同 Linux 内核发行版的 BTF 源文件；</li>
<li>使用 BTFGen 生成精简版的 BTF 文件；</li>
<li>将精简版的 BTF 文件与应用程序打包分发。</li>
</ol>
<p><img src="/_resources/74c0a8490488473eaa2b1495f5cb1bf7.png" /></p>
<h3 id="41-内部实现细节">4.1 内部实现细节</h3>
<p>BTFGen 在 bpftool 工具中实现，其使用 libbpf CO-RE 逻辑来解决重定位问题。有了这些信息，它就能挑选出重新定位所涉及的类型来生成 “精简版” 的 BTF 文件。这篇文章的目的不是要解释所有的内部实现细节。如果你想知道更多，你可以查看 BTFHub 仓库中的<a title="https://github.com/aquasecurity/btfhub/blob/main/docs/btfgen-internals.md" href="https://github.com/aquasecurity/btfhub/blob/main/docs/btfgen-internals.md">这个文档</a>或实现它的<a title="https://lore.kernel.org/bpf/164503621150.2935.6634904664671748900.git-patchwork-notify@kernel.org/T/#mdd100ccbc95947c8fe6be74db66002e273a29abd" href="https://lore.kernel.org/bpf/164503621150.2935.6634904664671748900.git-patchwork-notify@kernel.org/T/#mdd100ccbc95947c8fe6be74db66002e273a29abd">补丁</a>。</p>
<h2 id="42-如何使用">4.2 如何使用?</h2>
<p>本节提供了 BTFGen 工具使用的更多细节。在本例中，我们将使用 BTFGen 来实现内核未启用 CONFIG_DEBUG_INFO_BTF 选项的机器上运行特定的 <a title="https://github.com/iovisor/bcc/tree/v0.24.0/libbpf-tools" href="https://github.com/iovisor/bcc/tree/v0.24.0/libbpf-tools">BCC libbpf-tools</a> 工具。其他 eBPF 应用程序集成的方式也是类似。</p>
<p>为了实现上述的目的，我们需要以下流程：</p>
<ol>
<li>下载、编译和安装支持 BTFGen 的 bpftool 版本；</li>
<li>从 BTFHub 下载所需的 BTF 文件；</li>
<li>下载和编译 BCC 工具；</li>
<li>使用 BTFGen 为特定的 BCC 工具生成 “精简版” BTF 文件；</li>
<li>调整 BCC 工具代码，使其可以从自定义路径加载 BTF 文件；</li>
<li>最后进行验证。</li>
</ol>
<p>首先，我们为该演示创建一个临时目录：</p>
<div><pre class="hljs"><code>$ mkdir /tmp/btfgendemo</code></pre></div>
<h4 id="安装-bpftool-工具">安装 bpftool 工具</h4>
<p>BTFGen 刚刚被合入 bpftool。在 BTFGen 未被包含在不同发行版的软件包之前，我们需要从源代码进行编译：</p>
<div><pre class="hljs"><code>$ <span class="hljs-built_in">cd</span> /tmp/btfgendemo
$ git <span class="hljs-built_in">clone</span> --recurse-submodules https://github.com/libbpf/bpftool.git
$ <span class="hljs-built_in">cd</span> bpftool/src
$ make
$ sudo make install</code></pre></div>
<h4 id="从-bfthub-获取内核对应的-btf-文件">从 BFThub 获取内核对应的 BTF 文件</h4>
<p>这里为简洁起见，我们只考虑 Ubuntu Focal 系统中使用的场景，该方式也完全适用于 BTFHub 支持的其他发行版本。</p>
<div><pre class="hljs"><code>$ <span class="hljs-built_in">cd</span> /tmp/btfgendemo
$ git <span class="hljs-built_in">clone</span> https://github.com/aquasecurity/btfhub-archive
$ <span class="hljs-built_in">cd</span> btfhub-archive/ubuntu/focal/x86_64/
$ <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> *.tar.xz; <span class="hljs-keyword">do</span> tar -xf <span class="hljs-string">"<span class="hljs-variable">$f</span>"</span>; <span class="hljs-keyword">done</span>
$ ls -lhn *.btf | head
-rw-r----- 1 1000 1000 4,5M Sep 29 13:36 5.11.0-1007-azure.btf
-rw-r----- 1 1000 1000 4,8M Aug 10 23:33 5.11.0-1009-aws.btf
-rw-r----- 1 1000 1000 4,8M Jan 22 12:29 5.11.0-1009-gcp.btf
-rw-r----- 1 1000 1000 4,5M Sep 29 13:38 5.11.0-1012-azure.btf
-rw-r----- 1 1000 1000 4,5M Sep 29 13:40 5.11.0-1013-azure.btf
-rw-r----- 1 1000 1000 4,8M Aug 10 23:39 5.11.0-1014-aws.btf
-rw-r----- 1 1000 1000 4,8M Jan 22 12:32 5.11.0-1014-gcp.btf
-rw-r----- 1 1000 1000 4,5M Sep 29 13:43 5.11.0-1015-azure.btf
-rw-r----- 1 1000 1000 4,8M Sep 7 22:52 5.11.0-1016-aws.btf
-rw-r----- 1 1000 1000 4,8M Sep 7 22:57 5.11.0-1017-aws.btf</code></pre></div>
<p>如上述显示，我们可以看到每个内核对应的 BTF 文件的大小约为 4MB。</p>
<div><pre class="hljs"><code>$ find . -name <span class="hljs-string">"*.btf"</span> | xargs du -ch | tail -n 1
944M	total</code></pre></div>
<p>但是汇总起来看，仅 Ubuntu Focal 就有~944MB 的大小，将其与应用程序一起打包显然不太可行。</p>
<h4 id="下载-修改和编译-bcc-libbpf-工具">下载、修改和编译 BCC libbpf 工具</h4>
<p>我们从 BCC v0.24.0 标签上克隆仓库代码：</p>
<div><pre class="hljs"><code>$ <span class="hljs-built_in">cd</span> /tmp/btfgendemo
$ git <span class="hljs-built_in">clone</span> https://github.com/iovisor/bcc -b v0.24.0 --recursive</code></pre></div>
<p>默认情况下，不同的 BCC 工具会尝试从<a title="https://github.com/libbpf/libbpf/blob/22411acc4b2c846868fd570b2d9f3b016d2af2cb/src/btf.c#L4631-L4639" href="https://github.com/libbpf/libbpf/blob/22411acc4b2c846868fd570b2d9f3b016d2af2cb/src/btf.c#L4631-L4639">约定目录</a>中加载 BTF 信息。正常情况下，我们不能直接覆盖对应的文件，因为它们极有可能也会被其他工具所依赖。相反，我们可以修改 BCC 工具源码，让其从一个自定义的路径加载 BTF 文件。我们可以使用 LIBBPF_OPTS() 来声明一个 bpf_object_open_opts 结构，将其中的 btf_custom_path 字段设置为自定义 BTF 所在的路径，并将其传递给 TOOL_bpf__open_opts()函数。我们尝试使用如下的补丁来修改 opennoop、execsnoop 和 bindsnoop 工具。</p>
<p>译者注，约定的加载 BTF 目录如下：</p>
<div><pre class="hljs"><code>    { <span class="hljs-string">"/sys/kernel/btf/vmlinux"</span>, <span class="hljs-literal">true</span> /* raw BTF */ },
    { <span class="hljs-string">"/boot/vmlinux-%1<span class="hljs-variable">$s</span>"</span> },
    { <span class="hljs-string">"/lib/modules/%1<span class="hljs-variable">$s</span>/vmlinux-%1<span class="hljs-variable">$s</span>"</span> },
    { <span class="hljs-string">"/lib/modules/%1<span class="hljs-variable">$s</span>/build/vmlinux"</span> },
    { <span class="hljs-string">"/usr/lib/modules/%1<span class="hljs-variable">$s</span>/kernel/vmlinux"</span> },
    { <span class="hljs-string">"/usr/lib/debug/boot/vmlinux-%1<span class="hljs-variable">$s</span>"</span> },
    { <span class="hljs-string">"/usr/lib/debug/boot/vmlinux-%1<span class="hljs-variable">$s</span>.debug"</span> },
    { <span class="hljs-string">"/usr/lib/debug/lib/modules/%1<span class="hljs-variable">$s</span>/vmlinux"</span> },</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-comment"># /tmp/btfgendemo/bcc.patch</span>
diff --git a/libbpf-tools/bindsnoop.c b/libbpf-tools/bindsnoop.c
index 5d87d484..a336747e 100644
--- a/libbpf-tools/bindsnoop.c
+++ b/libbpf-tools/bindsnoop.c
@@ -187,7 +187,8 @@ int main(int argc, char **argv)
 	libbpf_set_strict_mode(LIBBPF_STRICT_ALL);
 	libbpf_set_print(libbpf_print_fn);

-	obj = bindsnoop_bpf__open();
+	LIBBPF_OPTS(bpf_object_open_opts, opts, .btf_custom_path = <span class="hljs-string">"/tmp/vmlinux.btf"</span>);
+	obj = bindsnoop_bpf__open_opts(&amp;opts);
 	<span class="hljs-keyword">if</span> (!obj) {
 		warn(<span class="hljs-string">"failed to open BPF object\n"</span>);
 		<span class="hljs-built_in">return</span> 1;
diff --git a/libbpf-tools/execsnoop.c b/libbpf-tools/execsnoop.c
index 38294816..9bd0d077 100644
--- a/libbpf-tools/execsnoop.c
+++ b/libbpf-tools/execsnoop.c
@@ -274,7 +274,8 @@ int main(int argc, char **argv)
 	libbpf_set_strict_mode(LIBBPF_STRICT_ALL);
 	libbpf_set_print(libbpf_print_fn);

-	obj = execsnoop_bpf__open();
+	LIBBPF_OPTS(bpf_object_open_opts, opts, .btf_custom_path = <span class="hljs-string">"/tmp/vmlinux.btf"</span>);
+	obj = execsnoop_bpf__open_opts(&amp;opts);
 	<span class="hljs-keyword">if</span> (!obj) {
 		fprintf(stderr, <span class="hljs-string">"failed to open BPF object\n"</span>);
 		<span class="hljs-built_in">return</span> 1;
diff --git a/libbpf-tools/opensnoop.c b/libbpf-tools/opensnoop.c
index 557a63cd..cf2c5db6 100644
--- a/libbpf-tools/opensnoop.c
+++ b/libbpf-tools/opensnoop.c
@@ -231,7 +231,8 @@ int main(int argc, char **argv)
 	libbpf_set_strict_mode(LIBBPF_STRICT_ALL);
 	libbpf_set_print(libbpf_print_fn);

-	obj = opensnoop_bpf__open();
+	LIBBPF_OPTS(bpf_object_open_opts, opts, .btf_custom_path = <span class="hljs-string">"/tmp/vmlinux.btf"</span>);
+	obj = opensnoop_bpf__open_opts(&amp;opts);
 	<span class="hljs-keyword">if</span> (!obj) {
 		fprintf(stderr, <span class="hljs-string">"failed to open BPF object\n"</span>);
 		<span class="hljs-built_in">return</span> 1;
$ <span class="hljs-built_in">cd</span> bcc
$ git apply /tmp/btfgendemo/bcc.patch
$ <span class="hljs-built_in">cd</span> libbpf-tools/
$ make -j$(nproc)</code></pre></div>
<h4 id="生成-精简版-btf-文件">生成 “精简版” BTF 文件</h4>
<p>这里，我们将使用<code> bpftool gen min_core_btf</code> 命令为 BCC 工具中的 bindsnoop、execsnoop 和opensnoop 同时生成精简的 BTF 文件。下述的命令对目录中存在的每个 BTF 文件逐次调用 bpftool 工具进行精简。</p>
<div><pre class="hljs"><code>$ OBJ1=/tmp/btfgendemo/bcc/libbpf-tools/.output/bindsnoop.bpf.o
$ OBJ2=/tmp/btfgendemo/bcc/libbpf-tools/.output/execsnoop.bpf.o
$ OBJ3=/tmp/btfgendemo/bcc/libbpf-tools/.output/opensnoop.bpf.o

$ mkdir -p /tmp/btfgendemo/btfs
$ <span class="hljs-built_in">cd</span> /tmp/btfgendemo/btfhub-archive/ubuntu/focal/x86_64/

$ <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> *.btf; <span class="hljs-keyword">do</span> bpftool gen min_core_btf <span class="hljs-string">"<span class="hljs-variable">$f</span>"</span> \
  /tmp/btfgendemo/btfs/$(basename <span class="hljs-string">"<span class="hljs-variable">$f</span>"</span>) <span class="hljs-variable">$OBJ1</span> <span class="hljs-variable">$OBJ2</span> <span class="hljs-variable">$OBJ3</span>; \
<span class="hljs-keyword">done</span>

$ ls -lhn /tmp/btfgendemo/btfs | head
total 864K
-rw-r--r-- 1 1000 1000 1,1K Feb 8 14:46 5.11.0-1007-azure.btf
-rw-r--r-- 1 1000 1000 1,1K Feb 8 14:46 5.11.0-1009-aws.btf
-rw-r--r-- 1 1000 1000 1,1K Feb 8 14:46 5.11.0-1009-gcp.btf
-rw-r--r-- 1 1000 1000 1,1K Feb 8 14:46 5.11.0-1012-azure.btf
-rw-r--r-- 1 1000 1000 1,1K Feb 8 14:46 5.11.0-1013-azure.btf
-rw-r--r-- 1 1000 1000 1,1K Feb 8 14:46 5.11.0-1014-aws.btf
-rw-r--r-- 1 1000 1000 1,1K Feb 8 14:46 5.11.0-1014-gcp.btf
-rw-r--r-- 1 1000 1000 1,1K Feb 8 14:46 5.11.0-1015-azure.btf
-rw-r--r-- 1 1000 1000 1,1K Feb 8 14:46 5.11.0-1016-aws.btf</code></pre></div>
<p>精简后生成的 BTF 文件大约为 1.1KB，Ubuntu Focal 对应的所有文件的大小为 864KB，将其与程序一起打包完全可行。</p>
<p>如果我们对生成的文件进一步进行压缩，其大小还可以大幅缩减：</p>
<div><pre class="hljs"><code>$ <span class="hljs-built_in">cd</span> /tmp/btfgendemo/btfs
$ tar cvfJ compressed.tar.xz *.btf
$ ls -lhn compressed.tar.xz
-rw-r--r-- 1 1000 1000 2,5K Feb 17 15:19 compressed.tar.xz</code></pre></div>
<p>压缩率如此之高是因为许多生成的文件相同，我们将在下文中进一步讨论。</p>
<h4 id="验证">验证</h4>
<p>为了验证，我们需要运行一台装有 Ubuntu Focal 的机器。这里提供的 Vagrant 文件可以用来创建对应的虚拟机。请注意，Ubuntu Focal 从内核 5.4.0-92-generic 版本开始启用 BTF 支持，所以我们需要运行其早期的版本进行验证。我们使用 <code>bento/ubuntu-20.04 Vagrant</code> 虚拟机中的 <code>202012.21.0</code> 版本，内核为 5.4.0-58-generic。</p>
<p>本文使用 <code>sshfs</code> 在主机和虚拟机之间共享文件，需要我们确保已经安装了 <a title="https://github.com/dustymabe/vagrant-sshfs" href="https://github.com/dustymabe/vagrant-sshfs">vagrant-sshfs</a> 插件。</p>
<div><pre class="hljs"><code>$ sudo vagrant plugin install vagrant-sshfs</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-comment"># /tmp/btfgendemo/Vagrantfile</span>
Vagrant.configure(<span class="hljs-string">"2"</span>) <span class="hljs-keyword">do</span> | config |
  config.vm.box = <span class="hljs-string">"bento/ubuntu-20.04"</span>
  config.vm.box_version = <span class="hljs-string">"= 202012.21.0"</span>
  config.vm.synced_folder <span class="hljs-string">"/tmp/btfgendemo"</span>, <span class="hljs-string">"/btfgendemo"</span>, <span class="hljs-built_in">type</span>: <span class="hljs-string">"sshfs"</span>

  config.vm.provider <span class="hljs-string">"virtualbox"</span> <span class="hljs-keyword">do</span> | vb |
    vb.gui = <span class="hljs-literal">false</span>
    vb.cpus = 4
    vb.memory = <span class="hljs-string">"4096"</span>
  end
end</code></pre></div>
<p>启动虚拟机并使用 ssh 登录：</p>
<div><pre class="hljs"><code>$ vagrant up
$ vagrant ssh</code></pre></div>
<p>后续的命令必须在虚拟机内执行。检查内核版本：</p>
<div><pre class="hljs"><code>$ uname -a
Linux vagrant 5.4.0-58-generic <span class="hljs-comment">#64-Ubuntu SMP Wed Dec 9 08:16:25 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span>
</code></pre></div>
<p>让我们检查内核是否启用了<code>CONFIG_DEBUG_INFO_BTF</code>：</p>
<div><pre class="hljs"><code>$ cat /boot/config-$(uname -r) | grep CONFIG_DEBUG_INFO_BTF
CONFIG_DEBUG_INFO_BTF is not <span class="hljs-built_in">set</span></code></pre></div>
<p>在把 BTF 文件复制到正确路径之前，我们尝试运行以下这些工具：</p>
<div><pre class="hljs"><code>$ sudo /btfgendemo/bcc/libbpf-tools/execsnoop
libbpf: failed to parse target BTF: -2
libbpf: failed to perform CO-RE relocations: -2
libbpf: failed to load object <span class="hljs-string">'execsnoop_bpf'</span>
libbpf: failed to load BPF skeleton <span class="hljs-string">'execsnoop_bpf'</span>: -2
failed to load BPF object: -2</code></pre></div>
<p>正如预期，我们运行工具失败，因为工具不能找到执行 CO-RE 重定位所需的 BTF 信息。</p>
<p>接着，我们将该内核版本的 BTF 文件复制到对应目录：</p>
<div><pre class="hljs"><code>$ cp /btfgendemo/btfs/$(uname -r).btf /tmp/vmlinux.btf</code></pre></div>
<p>将复制 BTF 到指定目录后，工具运行正常：</p>
<div><pre class="hljs"><code>
$ sudo /btfgendemo/bcc/libbpf-tools/execsnoop
PCOMM PID PPID RET ARGS
^C

$ sudo /btfgendemo/bcc/libbpf-tools/bindsnoop
PID COMM RET PROTO OPTS IF PORT ADDR
^C

$ sudo /btfgendemo/bcc/libbpf-tools/opensnoop
PID COMM FD ERR PATH
^C</code></pre></div>
<p>当然这只是为了演示工具工作流程的样例。真正的集成需要负责基于主机的内核版本自动提供对应的 BTF 文件。下面的部分通过两个例子展示了对应的集成。</p>
<h3 id="43-集成样例">4.3 集成样例</h3>
<p>在本节中，我们将介绍 Inspektor Gadget 和 Tracee 项目是如何使用 BTFGen。</p>
<h4 id="inspektor-gadget">Inspektor Gadget</h4>
<p><a title="https://github.com/kinvolk/inspektor-gadget" href="https://github.com/kinvolk/inspektor-gadget">Inspektor Gadget</a> 是一个用于调试/检查 Kubernetes 资源和应用程序的工具集。由于Inspektor Gadget 是以容器镜像的形式发布的，我们选择在其中为不同的 Linux发行版搭载 BTF 文件。我们在 Docker 文件中添加了一个<a title="https://github.com/kinvolk/inspektor-gadget/blob/v0.4.2/gadget.Dockerfile#L42-L46" href="https://github.com/kinvolk/inspektor-gadget/blob/v0.4.2/gadget.Dockerfile#L42-L46">步骤</a>，使其可以在构建容器镜像时生成 BTF 文件：</p>
<div><pre class="hljs"><code>RUN <span class="hljs-built_in">set</span> -ex; \
    <span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">$ENABLE_BTFGEN</span>"</span> = <span class="hljs-literal">true</span> ]; <span class="hljs-keyword">then</span> \
        <span class="hljs-built_in">cd</span> /btf-tools &amp;&amp; \
        LIBBPFTOOLS=/objs BTFHUB=/tmp/btfhub INSPEKTOR_GADGET=/gadget ./btfgen.sh; \
    <span class="hljs-keyword">fi</span></code></pre></div>
<p>辅助脚本 <a title="https://github.com/kinvolk/inspektor-gadget/blob/v0.4.2/tools/btfgen.sh" href="https://github.com/kinvolk/inspektor-gadget/blob/v0.4.2/tools/btfgen.sh">btfgen.sh</a> 调用 bpftool 为 BTFHub 支持的所有内核生成 BTF 文件。</p>
<p>我们修改 <a title="https://github.com/kinvolk/inspektor-gadget/blob/v0.4.2/gadget-container/entrypoint.sh#L149-L154" href="https://github.com/kinvolk/inspektor-gadget/blob/v0.4.2/gadget-container/entrypoint.sh#L149-L154">entrypoint</a> 脚本，在容器文件系统上安装正确的 BTF 文件，使对应的工具都能运行。Inspektor 工具被设计成总是在容器中运行，因此我们可以将 BTF 文件安装在系统路径（<code>/boot/vmlinux-$(uname -r)</code>），而不影响主机。通过这样做，我们还可以避免修改不同的 BCC 工具的源代码（就像我们在上面的例子中做的那样）：</p>
<div><pre class="hljs"><code>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"Kernel provided BTF is not available: Trying shipped BTF files"</span>
SOURCE_BTF=/btfs/<span class="hljs-variable">$ID</span>/<span class="hljs-variable">$VERSION_ID</span>/<span class="hljs-variable">$ARCH</span>/<span class="hljs-variable">$KERNEL</span>.btf
<span class="hljs-keyword">if</span> [-f <span class="hljs-variable">$SOURCE_BTF</span>]; <span class="hljs-keyword">then</span>
        objcopy --input binary --output elf64-little --rename-section .data=.BTF <span class="hljs-variable">$SOURCE_BTF</span> /boot/vmlinux-<span class="hljs-variable">$KERNEL</span>
        <span class="hljs-built_in">echo</span> <span class="hljs-string">"shipped BTF available. Installed at /boot/vmlinux-<span class="hljs-variable">$KERNEL</span>"</span>
<span class="hljs-keyword">else</span>
...</code></pre></div>
<p>PR 完整实现参见 <a title="https://github.com/kinvolk/inspektor-gadget/pull/387" href="https://github.com/kinvolk/inspektor-gadget/pull/387">inspektor-gadget/pull/387</a></p>
<h4 id="tracee">Tracee</h4>
<p><a title="https://github.com/aquasecurity/tracee" href="https://github.com/aquasecurity/tracee">Tracee</a> 是用于 Linux 的运行时安全和取证工具。这里，生成的 BTF 文件可被嵌入到应用程序的二进制文件中。Makefile 有一个 <a title="https://github.com/aquasecurity/tracee/blob/add1efa7934dcf46be67ea2be54ac0d139a94804/Makefile.one#L507" href="https://github.com/aquasecurity/tracee/blob/add1efa7934dcf46be67ea2be54ac0d139a94804/Makefile.one#L507">btfhub</a> 目标，然后调用 <a title="https://github.com/aquasecurity/tracee/blob/add1efa7934dcf46be67ea2be54ac0d139a94804/3rdparty/btfhub.sh#L1" href="https://github.com/aquasecurity/tracee/blob/add1efa7934dcf46be67ea2be54ac0d139a94804/3rdparty/btfhub.sh#L1">btfhub.sh</a>。脚本克隆 BTFHub 仓库，并调用<a title="https://github.com/aquasecurity/tracee/blob/add1efa7934dcf46be67ea2be54ac0d139a94804/3rdparty/btfhub.sh#L112" href="https://github.com/aquasecurity/tracee/blob/add1efa7934dcf46be67ea2be54ac0d139a94804/3rdparty/btfhub.sh#L112">btfgen.sh</a>  来生成 BTF 文件。这些文件被移到 ./dist/btfhub 目录中。</p>
<div><pre class="hljs"><code><span class="hljs-comment"># generate tailored BTFs</span>

[ ! -f ./tools/btfgen.sh ] &amp;&amp; die <span class="hljs-string">"could not find btfgen.sh"</span>
./tools/btfgen.sh -a <span class="hljs-variable">${ARCH}</span> -o <span class="hljs-variable">$TRACEE_BPF_CORE</span>

<span class="hljs-comment"># move tailored BTFs to dist</span>

[ ! -d <span class="hljs-variable">${BASEDIR}</span>/dist ] &amp;&amp; die <span class="hljs-string">"could not find dist directory"</span>
[ ! -d <span class="hljs-variable">${BASEDIR}</span>/dist/btfhub ] &amp;&amp; mkdir <span class="hljs-variable">${BASEDIR}</span>/dist/btfhub

rm -rf <span class="hljs-variable">${BASEDIR}</span>/dist/btfhub/*
mv ./custom-archive/* <span class="hljs-variable">${BASEDIR}</span>/dist/btfhub</code></pre></div>
<p>然后，使用 <a title="https://github.com/aquasecurity/tracee/blob/add1efa7934dcf46be67ea2be54ac0d139a94804/embedded-ebpf.go#L11" href="https://github.com/aquasecurity/tracee/blob/add1efa7934dcf46be67ea2be54ac0d139a94804/embedded-ebpf.go#L11">go:embed</a> 指令将 BTF 文件嵌入到 Go 二进制中。</p>
<div><pre class="hljs"><code><span class="hljs-comment">//go:build ebpf</span>
<span class="hljs-comment">// +build ebpf</span>

<span class="hljs-keyword">package</span> tracee

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"embed"</span>
)

<span class="hljs-comment">//go:embed "dist/tracee.bpf.core.o"</span>
<span class="hljs-comment">//go:embed "dist/btfhub/*"</span>

<span class="hljs-keyword">var</span> BPFBundleInjected embed.FS</code></pre></div>
<p>在运行时，当前内核的对应的 BTF文件被<a title="https://github.com/aquasecurity/tracee/blob/add1efa7934dcf46be67ea2be54ac0d139a94804/cmd/tracee-ebpf/main.go#L367" href="https://github.com/aquasecurity/tracee/blob/add1efa7934dcf46be67ea2be54ac0d139a94804/cmd/tracee-ebpf/main.go#L367">解压</a>，其路径传递给 <a title="https://github.com/aquasecurity/tracee/blob/add1efa7934dcf46be67ea2be54ac0d139a94804/cmd/tracee-ebpf/main.go#L373" href="https://github.com/aquasecurity/tracee/blob/add1efa7934dcf46be67ea2be54ac0d139a94804/cmd/tracee-ebpf/main.go#L373">libbpf-go</a>，用于 CO-RE 重定位。</p>
<h3 id="44-限制">4.4 限制</h3>
<p>内核中的 BTF 支持不仅仅是关于导出 BTF 类型。部分 eBPF 程序如 fentry/fexit 和 LSM 钩子需要内核导出 BTF 信息。这些程序将不能使用 BTFGen，唯一的选择是启用 CONFIG_DEBUG_INFO_BTF 的内核。</p>
<h3 id="45-未来发展">4.5 未来发展</h3>
<p>当然，我们知道 BTFGen 是一个临时的解决方案，直到大多数系统更新到默认导出 BTF 信息的内核版本。然而，我们认为这需要几年的时间，在这期间，BTFGen 可以帮助填补这一空白。</p>
<p>以下是我们可以近期考虑的一些改进。</p>
<h4 id="与其他项目的整合">与其他项目的整合</h4>
<p>部分项目如 BCC 及其基于 libbpf 的工具都可以与 BTFGen 整合获益。 我们提交了一个 <a title="https://github.com/iovisor/bcc/pull/3889" href="https://github.com/iovisor/bcc/pull/3889">PR</a>，通过使用 BTFGen 使上述工具可以在更多的 Linux 发行版中使用。</p>
<h4 id="删除重复的文件">删除重复的文件</h4>
<p>eBPF 程序通常访问很少的内核类型，因此，两个不同的内核版本生成的文件很有可能是相同的，这对于同一 Linux 发行版的小版本内核来说尤其如此。对 BTFGen 的进一步改进是基于此，通过使用符号链接或类似的方法来避免创建重复的文件。</p>
<p>这也可以直接在 BTFHub 上进行，因为有些源 BTF 文件是重复的，就像<a title="https://github.com/aquasecurity/btfhub/issues/17" href="https://github.com/aquasecurity/btfhub/issues/17">这个</a>问题中所指出的那样，但即使在这种情况下，出现重复文件的机会还是较低。</p>
<h4 id="在线-api">在线 API</h4>
<p>BTFHub 仓库体积很大，而且由于新内核的发布，它的规模还在不断增加。Seekret 创建了一个 <a title="https://github.com/seek-ret/btfhub-online" href="https://github.com/seek-ret/btfhub-online">API</a>，使用 BTFGen 和 BTFHub 为用户提供的 eBPF 对象按需生成 “精简版” BTF 文件。</p>
<h2 id="5-更多信息">5. 更多信息</h2>
<p>如果你想了解更多关于 eBPF、BTF、CO-RE、BTFHub 和 BTFGen 的信息，以下资料无疑是优秀的参考：</p>
<ul>
<li><a title="https://nakryiko.com/posts/bpf-core-reference-guide/" href="https://nakryiko.com/posts/bpf-core-reference-guide/">BPF CO-RE参考指南</a>：从开发者的角度解释了如何使用 CO-RE。</li>
<li><a title="https://nakryiko.com/posts/bpf-portability-and-co-re/" href="https://nakryiko.com/posts/bpf-portability-and-co-re/">BPF CO-RE (Compile Once - Run Everywhere)</a>：解释了 CO-RE和该机制中涉及的不同组件。</li>
<li><a title="https://github.com/aquasecurity/btfhub/blob/main/docs/btfgen-internals.md" href="https://github.com/aquasecurity/btfhub/blob/main/docs/btfgen-internals.md">eBPF BTF 生成器：通往真正的可移植 CO-RE eBPF 程序之路</a>：深入探讨 BTFGen 的实现。</li>
<li><a title="https://www.kernel.org/doc/html/latest/bpf/btf.html" href="https://www.kernel.org/doc/html/latest/bpf/btf.html">BPF类型格式(BTF)</a>：BTF的内核文档。</li>
</ul>
<h2 id="6-致谢">6. 致谢</h2>
<p>功能从已经存在的项目中获得了灵感，并由不同的公司联合实现。</p>
<p>首先，我们要感谢 Aqua Security 团队在 BTFHub 上所做的出色工作，这是我们的基础项目。</p>
<p>其次，我们要感谢在这个功能的开发过程中做出贡献的人员。Aqua Security 的 Rafael David Tinoco 和 Elastic 的 Lorenzo Fontana 和 Leonardo Di Donato。</p>
<p>最后，libbpf 的维护者 Andrii Nakryiko 和 Alexei Starovoitov 以及 bpftool 的维护者 Quentin Monnet，他们为实现该功能提供了大量宝贵的反馈和指导。</p>
<blockquote>
<p>原文作者：DavidDi<br />
原文链接：<a title="https://www.ebpf.top/post/btfgen-one-step-closer-to-truly-portable-ebpf-programs/" href="https://www.ebpf.top/post/btfgen-one-step-closer-to-truly-portable-ebpf-programs/">https://www.ebpf.top/post/btfgen-one-step-closer-to-truly-portable-ebpf-programs/</a><br />
版权声明：本作品采用知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</p>
</blockquote>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[eBPF总结]]></title>
            <guid>6659d0caaa3a4ab6a39850daca737519</guid>
            <pubDate>Wed, 21 Dec 2022 05:54:20 GMT</pubDate>
            <content:encoded><![CDATA[<p>我希望这篇简短的报告能让你了解 eBPF 以及它为何如此强大。我真正希望的是你已经准备好自己尝试一些基于 eBPF 的工具了！</p>
<p>如果你想更深入地了解技术方面，一个不错的起点是 <a title="https://ebpf.io/" href="https://ebpf.io/">ebpf.io</a>，你可以在其中找到更多有关该技术和 eBPF 基金会的信息。对于编程示例，<a title="https://github.com/lizrice/ebpf-beginners" href="https://github.com/lizrice/ebpf-beginners">我的 GitHub 上的 ebpf-beginners 存储库</a> 中有一些资源。</p>
<p>要了解其他人如何利用 eBPF 工具，可以参加 <a title="https://twitter.com/ebpfsummit" href="https://twitter.com/ebpfsummit">eBPF 峰会</a> 和 <a title="https://events.linuxfoundation.org/cloud-native-ebpf-day-europe/" href="https://events.linuxfoundation.org/cloud-native-ebpf-day-europe/">云原生 eBPF Day</a> 等活动 ，用户在这里分享他们的成功案例和学习经验。你可以从 <a title="https://ebpf.io/slack" href="https://ebpf.io/slack">ebpf.io/slack</a> 访问一个活动的 Slack 频道。 我希望能在那里看到你！</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[eBPF 工具集]]></title>
            <guid>05fb5135e88749908c4725eced4486be</guid>
            <pubDate>Wed, 21 Dec 2022 05:32:32 GMT</pubDate>
            <content:encoded><![CDATA[<blockquote>
<p>既然你已经了解了 eBPF 是什么，以及 eBPF 程序是如何工作的，那么让我们转向探索一些基于该技术构建的工具，你可能会在生产部署中使用这些工具。我们将考虑一些基于 eBPF 的开源项目示例，这些项目在三个重要领域提供功能：网络、可观察性和安全性。</p>
</blockquote>
<h3 id="网络">网络</h3>
<p>eBPF 程序可以附加到网络接口和内核网络栈中的各个附加点。在每个附加点，eBPF 程序都可以丢弃数据包、将它们发送到不同的目的地，甚至修改内容。这就实现了一些非常强大的功能。让我们看看现在通常使用 eBPF 实现的一些网络功能。</p>
<h4 id="负载均衡">负载均衡</h4>
<p>如果你对网络 eBPF 的可扩展性有任何疑问，要知道它正在 Facebook 大规模使用。他们是 BPF 的早期采用者并在 2018 年引入了 <a title="https://engineering.fb.com/2018/05/22/open-source%E3%80%81open-sourcing-katran-a-scalable-network-load-balancer/" href="https://engineering.fb.com/2018/05/22/open-source%E3%80%81open-sourcing-katran-a-scalable-network-load-balancer/">Katran</a> ，其是一个开源的第 4 层负载均衡器。</p>
<p>另一个高度扩展的负载均衡器示例来自 Cloudflare 的 <a title="https://blog.cloudflare.com/unimog-cloudflares-edge-load-balancer/" href="https://blog.cloudflare.com/unimog-cloudflares-edge-load-balancer/">Unimog</a> 边缘负载均衡器。通过在内核中运行，eBPF 程序可以操作网络数据包并将它们转发到适当的目的地，而无需每个数据包都必须通过网络栈并到达用户空间。</p>
<p>Cilium 项目以 eBPF Kubernetes 网络插件而闻名（稍后我将讨论），但它作为独立的负载均衡器用于大型电信和企业内部署中。同样，在早期阶段处理数据包而不必转换到用户空间的能力使其具有高性能。</p>
<h4 id="kubernetes-网络">Kubernetes 网络</h4>
<p>CNCF 项目 <a title="https://cilium.io/" href="https://cilium.io/">Cilium</a> 是最初的基于 eBPF 的 CNI 实现。它最初是由一群致力于 eBPF 的内核维护者发起的，他们很早认识到其在云原生网络中的应用潜力。Cilium 现在被用作 Google Kubernetes Engine、Amazon EKS Anywhere 和阿里云的默认数据平面。</p>
<p>在云原生世界中，Pod 一直在停止和启动，每个 Pod 都被分配一个 IP 地址。在启用 eBPF 的网络之前，每个节点都必须不断更新一组 iptables 规则，以便在 pod 之间进行路由；而管理这些 iptables 规则在规模上会变得非常不方便。如图 6-1 所示，Cilium 极大地简化了路由，因此它本质上是 eBPF 中的一个简单的表查找，从而使得[显著的性能改进](<a title="https://cilium.io/blog/2021/05/11/cni-benchmark%EF%BC%89%E3%80%82" href="https://cilium.io/blog/2021/05/11/cni-benchmark%EF%BC%89%E3%80%82">https://cilium.io/blog/2021/05/11/cni-benchmark）。</a></p>
<p>除了传统的 iptables 版本之外，另一个添加了 eBPF 实现的 Kubernetes CNI 是 Project <a title="https://github.com/projectcalico/calico" href="https://github.com/projectcalico/calico">Calico</a>。</p>
<p><img src="/_resources/98da9dfc81f14178b40df0080b6200c3.png" /></p>
<h4 id="服务网格-service-mesh">服务网格 Service Mesh</h4>
<p>eBPF 作为更高效的服务网格数据平面的基础也非常有意义。许多服务网格功能在第 7 层即应用程序层运行，并使用 Envoy 等代理组件代表应用程序执行操作。在 Kubernetes 中，这些代理通常部署在 sidecar 模型中，每个 pod 有一个代理容器，以便代理可以访问 pod 的网络命名空间。正如你在第 5 章中所看到的，eBPF 提供了一种比 sidecar 模型更有效的方法。由于内核可以访问所有 pod 命名空间，我们可以使用 eBPF 在 pod 中的应用程序和主机上的单个代理之间建立连接，如图 6-2 所示。</p>
<p><img src="/_resources/f3e6858a87294719b3da17740d59b4ea.png" /></p>
<p>我还有另一篇关于使用 eBPF 实现更高效的服务网格数据平面的文章，<a title="https://www.youtube.com/watch?v=VV3MzbPXyTM" href="https://www.youtube.com/watch?v=VV3MzbPXyTM">Solo.io</a> 也是如此。在撰写本文时，Cilium Service Mesh 处于测试阶段，与传统的 Sidecar 代理方法相比，显示出早期的<a title="https://isovalent.com/blog/post/2021-12-08-ebpf-servicemesh" href="https://isovalent.com/blog/post/2021-12-08-ebpf-servicemesh">性能提升</a> .</p>
<h3 id="可观测">可观测</h3>
<p>正如你在本报告前面所见，eBPF 程序可以了解机器上发生的一切。通过收集有关事件的数据并将它们传递到用户空间，eBPF 启用了一系列强大的可观察性工具，可以向你展示应用程序是执行和表现如何，而无需对这些应用程序进行任何更改。eBPF 还支持整个系统的可观察性，而不仅仅是单个应用程序，因此你可以了解主机的行为。</p>
<p>你在本报告的前面部分已经接触过了 BCC 项目，多年来，Brendan Gregg 在 Netflix 开展了开创性工作，并展示了如何使用这些 eBPF 工具在大规模和高性能常见下观察你感兴趣的<a title="https://www.brendangregg.com/" href="https://www.brendangregg.com/">几乎任何指标</a>。</p>
<p>Kinvolk 的 <a title="https://github.com/inspektor-gadget/inspektor-gadget" href="https://github.com/inspektor-gadget/inspektor-gadget">Inspektor Gadget</a> 将其中一些源自 BCC 的工具引入了 Kubernetes 的世界，这样你就可以轻松地在命令行上观察特定的工作负载。</p>
<p>新一代项目和工具正在这项工作的基础上提供基于 GUI 的可观察性。CNCF 项目 Pixie 允许你运行预先编写或自定义的脚本，并通过强大且具有视觉吸引力的 UI 查看指标和日志。因为其基于 eBPF，这意味着你可以自动检测所有应用程序并获取性能数据，而无需进行任何代码更改或配置。图 6-3 仅显示了 <a title="https://px.dev/" href="https://px.dev/">Pixie</a> 中可用的许多可视化的一个示例。</p>
<p>另一个名为 <a title="https://github.com/parca-dev/parca" href="https://github.com/parca-dev/parca">Parca</a> 的可观察性项目专注于持续分析，使用 eBPF 来有效地采样 CPU 使用率等指标，你可以使用这些指标来检测性能瓶颈。</p>
<p><img src="/_resources/19f8441cc108462fbd4620423198f863.png" /></p>
<p>Cilium 的 Hubble 组件是一个具有命令行界面和 UI（如图 6-4 所示）的可观察性工具，专注于 Kubernetes 集群中的网络流。<br />
<img src="/_resources/9127b2763c794b699e5f4408e819c179.png" /></p>
<p>在云原生环境中，IP 地址不断被动态分配和重新分配，基于 IP 地址的传统网络可观察性工具的用途非常有限。作为 CNI，Cilium 可以访问工作负载身份信息，这意味着 Hubble 可以显示由 Kubernetes pod、服务和命名空间标识的服务地图和流数据。这对于诊断网络问题非常宝贵。</p>
<p>如果可以观察活动，（这是安全工具的基础），你就可以将正在发生的事情与策略或规则进行比较，以了解该活动是预期的还是可疑的。让我们转向一些使用 eBPF 提供云原生安全功能的工具。</p>
<h3 id="安全">安全</h3>
<p>有强大的云原生工具可用，通过使用 eBPF 来检测甚至阻止恶意活动来增强安全性。我将这些分为两类：保护网络活动和保护应用程序在运行时的预期行为。</p>
<h4 id="网络安全">网络安全</h4>
<p>因为 eBPF 允许检查和操作网络数据包，所以它在网络安全方面有很多用途。基本原则是，如果一个网络数据包被认为是恶意的或有问题的，如不符合某些安全验证标准，它可以简单地被丢弃。eBPF 是一种高效的实现方式，因为它可以挂接到内核中网络栈的相关部分，甚至可以挂接到网络接口卡上。这意味着可以丢弃不符合策略或恶意的数据包在产生由网络堆栈处理并传递给用户空间的处理成本之前。</p>
<p>eBPF 在大规模生产中的早期用途之一是用于 [Cloudflare] (<a title="https://blog.cloudflare.com/how-to-drop-10-million-packets/" href="https://blog.cloudflare.com/how-to-drop-10-million-packets/">https://blog.cloudflare.com/how-to-drop-10-million-packets/</a>) 的 DDoS（分布式拒绝服务）保护。 DDoS 攻击者用许多网络消息淹没目标机器，希望目标无法足够快地处理它们，并忙于处理这些消息，以至于它无法做有用的工作。 Cloudflare 工程师使用 eBPF 程序在数据包到达后立即对其进行检查，并快速确定数据包是否是此类攻击的一部分，如果是则将其丢弃。数据包不必通过内核的网络栈，因此处理所需的资源要少得多，并且目标可以应对更高速率的恶意流量。</p>
<p>eBPF 程序还被用作针对“死亡数据包”内核漏洞的动态缓解措施。2攻击者制作网络数据包的方式是利用内核中的一个错误，该错误会阻止它正确处理该数据包。无需等待内核补丁推出，可以通过加载 eBPF 程序来缓解攻击，该程序会查找这些特制数据包并丢弃它们。这样做的真正美妙之处在于，可以动态加载 eBPF 程序，而无需更改机器上的任何内容。</p>
<p>在 Kubernetes 中，<a title="http://networkpolicy.io/" href="http://networkpolicy.io/">网络策略</a> 是一等公民，但它留给网络插件来执行。一些 CNI，包括 Cilium 和 Calico，为更强大的规则提供扩展的网络策略功能，例如允许或禁止流量到由完全限定域名而不是 IP 地址指定的目的地。 <a title="https://app.networkpolicy.io/" href="https://app.networkpolicy.io/">app.networkpolicy.io</a> 有一个很好的工具可以探索网络策略及其影响，如图 6-5 所示。</p>
<p>标准 Kubernetes 网络策略规则适用于进出应用程序 pod 的流量，但由于 eBPF 对所有网络流量具有可见性，它也可用于主机防火墙功能，限制进出主机（虚拟）机器的流量。3</p>
<p>eBPF 也可以用来提供透明加密，无论是通过 WireGuard 还是 IPsec。4这里，透明意味着应用程序不需要任何修改——事实上，应用程序可以完全不知道它的网络流量是加密的.</p>
<p><img src="/_resources/8adbe19aaed640278d890fe558796448.png" /></p>
<h3 id="运行时安全">运行时安全</h3>
<p>eBPF 还被用于构建检测应用程序何时以非预期或恶意方式运行的工具，其中一些工具还可用于防止不良行为。一些可疑行为的示例可能包括意外访问文件、运行可执行程序或试图获得额外权限。</p>
<p>事实上，你可能已经以 seccomp 的形式使用了基于 BPF 的安全实施，这是一种用于限制任何应用程序可以调用的系统调用集的 Linux 特性。</p>
<p>CNCF 项目 <a title="https://falco.org/" href="https://falco.org/">Falco</a> 扩展了限制应用程序可以进行的系统调用的想法。Falco 的规则定义是在 YAML 中创建的，这比 seccomp 配置文件更易于人类阅读和解释。默认的 Falco 驱动程序是一个内核模块，但也有一个附加到“原始系统调用”事件的 eBPF 探针驱动程序。它不会阻止这些系统调用完成，但它可以生成日志或其他通知，以提醒运维人员注意潜在的恶意事件。</p>
<p>正如我们在第 3 章中看到的，可以将 eBPF 程序附加到 LSM 接口以防止恶意行为或缓解已知漏洞。例如，Denis Efremov 编写了一个 <a title="https://github.com/evdenis/lsm_bpf_check_argc0" href="https://github.com/evdenis/lsm_bpf_check_argc0">eBPF 程序</a> 来防止 exec() 系统调用在没有传递任何参数的情况下运行，以减轻 PwnKit* 5 高危漏洞。eBPF 也可用于缓解投机执行 “Spectre” 攻击。</p>
<p><a title="https://github.com/aquasecurity/tracee" href="https://github.com/aquasecurity/tracee">Tracee</a> 是另一个使用 eBPF 实现运行时安全的开源项目。除了基于系统调用的检查外，它还使用了 LSM 接口。这有助于避免在仅检查系统调用时容易受到 <a title="https://lwn.net/Articles/245630/" href="https://lwn.net/Articles/245630/">TOCTTOU</a> 条件竞争的影响。 Tracee 支持 Open Policy Agent 的 Rego 语言中定义的规则，也允许使用 Go 中定义的插件规则。</p>
<p>Cilium 的 <a title="https://github.com/cilium/tetragon" href="https://github.com/cilium/tetragon">Tetragon</a> 组件提供了另一种强大的方法，使用 eBPF 来监控容器安全可观察性的四个黄金信号：进程执行、网络套接字、文件访问和 7 层网络身份。这使得运维可以准确地查看导致任何恶意或可疑事件的原因，直至特定 pod 中的可执行名称和用户身份。例如，如果受到挖矿攻击，你可以准确地看到哪个可执行文件打开了与矿池的网络连接，从哪个 pod 以及何时打开。这些取证对于了解危害是如何发生的以及使构建安全策略以防止将来发生类似攻击变得非常宝贵。</p>
<p>如果你想更深入地研究 eBPF 的安全可观察性主题，请查看 Natália Ivánkó 和 Jed Salazar 的报告7。密切关注云原生 eBPF 空间，因为不久我们就会看到利用 BPF LSM 和其他 eBPF 定制来提供安全实施和可观察性的工具。</p>
<p>我们介绍了几个在网络、可观察性和安全性方面的云原生工具。与此前工具相比，他们使用 eBPF 为他们带来了两个关键优势：</p>
<ol>
<li>
<p>从内核中的优势来看，eBPF 程序对所有进程都有可见性。</p>
</li>
<li>
<p>通过避免内核和用户空间执行之间的转换，eBPF 程序提供了一种非常高效的方式来收集事件数据或处理网络数据包。</p>
</li>
</ol>
<p>这并不意味着我们应该对所有事情都使用 eBPF！在 eBPF 中编写特定于业务的应用程序不太可能有意义，就像我们通常将应用程序编写为内核模块一样。这条规则可能有一些例外，可能是针对高频交易等极高的性能要求。正如我们在本章中所看到的，eBPF 主要是作为工具来检测其他应用程序的。</p>
<blockquote>
<p>请参阅 Cilium 的主机<a title="https://docs.cilium.io/en/stable/gettingstarted/host-firewall/" href="https://docs.cilium.io/en/stable/gettingstarted/host-firewall/">防火墙文档</a>。<br />
Tailscale 有这两种加密协议的<a title="https://tailscale.com/kb/1173/ipsec-vs-wireguard/" href="https://tailscale.com/kb/1173/ipsec-vs-wireguard/">比较</a></p>
</blockquote>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[eBPF 在云原生环境中的应用]]></title>
            <guid>cc36bf9f073844cc89955cf2819ae38f</guid>
            <pubDate>Wed, 21 Dec 2022 04:15:42 GMT</pubDate>
            <content:encoded><![CDATA[<h3 id="每台主机一个内核">每台主机一个内核</h3>
<p>要理解为什么 eBPF 在云原生世界中如此强大，你需要非常清楚一个概念：每台机器（或虚拟机）只有一个内核，并且该机器上运行的所有容器共享同一个内核 ,1 如图 5-1 所示。同一个内核参与并知道在任何给定主机上运行的所有应用程序代码。</p>
<p>通过检测内核，就像在使用 eBPF 时所做的那样，我们可以同时检测在该机器上运行的所有应用程序代码。当我们将 eBPF 程序加载到内核中并将其附加到事件时，无论事件涉及哪个进程，eBPF 程序都会被触发</p>
<p><img src="/_resources/284144fa07954bc0a04ba97697db2143.png" /></p>
<h3 id="ebpf-vs-sidecar-模型">eBPF vs Sidecar 模型</h3>
<p>在 eBPF 之前，大多数 Kubernetes 的可观察性和安全工具都使用 sidecar 模型。此模型允许将检测部署在单独的容器中，但与应用程序位于同一 pod 中。当这种方法被采用时，已经前迈进了一步，因为这意味着你不再需要直接在应用程序中编写检测代码。只需部署 sidecar，它就可以看到同一个 pod 中的其他容器。 注入 sidecar 的过程通常是自动化的，因此这提供了一种机制来确保所有应用程序都被检测。</p>
<p>每个 sidecar 容器都会消耗资源，总量需要乘以注入 sidecar 的 pod 数量。这可能非常重要——例如，如果每个 sidecar 都需要自己的路由信息或策略规则副本，那么这是一种浪费。（关于这方面的更多信息，Thomas Graf 写了一篇 [sidecars 与 eBPF 用于服务网格的比较](<a title="https://isovalent.com/blog/post/2021-12-08-ebpf-servicemesh%EF%BC%89%E3%80%82%EF%BC%89" href="https://isovalent.com/blog/post/2021-12-08-ebpf-servicemesh%EF%BC%89%E3%80%82%EF%BC%89">https://isovalent.com/blog/post/2021-12-08-ebpf-servicemesh）。）</a></p>
<p>Sidecar 的另一个问题是，你不能保证机器上的每个应用程序都已正确检测。想象一下，攻击者设法破坏了一个主机并启动了一个单独的 pod 来运行，例如进行挖矿。他们不太可能礼貌地使用 sidecar 可观察性或安全工具来检测他们的挖矿程序。这时，你需要一个单独的系统来了解相关活动。</p>
<p>但是同一个挖矿 pod 与在该主机上运行的合法 pod 共享内核。 如果你使用基于 eBPF 的工具，如图 5-2 所示，挖矿者会被发现。</p>
<p><img src="/_resources/e0727e9746f34257b0a2179111a5f3c6.png" /></p>
<h3 id="ebpf-和进程隔离">eBPF 和进程隔离</h3>
<p>我主张将功能整合到单个每个节点的基于 eBPF 的代理中，而不是每个 pod 的 sidecar。如果该代理可以访问机器上运行的所有 Pod，这不是安全风险吗？我们是否已经失去了应用程序之间可能会阻止它们相互干扰的隔离？</p>
<p>作为一个花了很多时间在容器安全方面工作的人，我可以理解这些担忧，但重要的是要深入研究底层机制，以真正理解为什么它不是最初可能出现的缺陷。</p>
<p>需要记住的重要一点是，这些 pod 都共享一个内核，并且内核对 pod 或容器没有天生的理解。相反，内核对进程进行操作，并使用 cgroup 和命名空间将进程彼此隔离。这些结构阻止用户空间中的进程能够看到或相互干扰，这是由内核控制的。一旦在内核中处理数据（例如，从磁盘读取或发送到网络），你就依赖于内核的正确行为。例如，只有内核代码说应该尊重文件权限。没有额外的魔法权威层可以阻止内核忽略文件权限，并从它想要访问的任何文件中读取数据 —— 只是内核本身没有被编码为不这样做。</p>
<p>Linux 系统上存在的安全控制假定内核本身是可以信任的。它们可以防止在用户空间中运行的代码出现不良行为。</p>
<p>我们在第 2 章中看到，eBPF 验证器确保任何 eBPF 程序只尝试访问它应该有权访问的内存。验证程序检查程序是否不可能超出其权限，包括确保内存由当前进程拥有或者是当前网络数据包的一部分。这意味着 eBPF 代码比周围的内核代码受到更严格的控制，无需通过任何类型的验证步骤。</p>
<p>如果攻击者将容器化应用程序逃逸到节点上，并且能够提升权限，则该攻击者可以破坏同一节点上的其他应用程序。由于这些逃逸并不为人所知，因此作为容器安全专家，我不建议在没有某种级别的额外安全工具的情况下与不受信任的应用程序或用户一起在共享机器上运行敏感应用程序。对于高度敏感的数据，你甚至可能不想与不受信任的用户在同一裸机上的虚拟机中运行。但是，如果你准备在同一个虚拟机上并行运行应用程序（这在许多不是特别敏感的应用程序中是完全合理的），那么 eBPF 不会通过共享内核增加已经存在的风险。</p>
<p>当然，恶意的 eBPF 程序可能会造成各种破坏，编写恶意 eBPF 代码当然很容易——例如，复制每个网络数据包并将其发送给窃听者。默认情况下，非 root 用户不能加载 eBPF 程序的权限，2 你应该只授予信任用户或软件系统这个权限，就像 root 权限一样。所以，你必须小心运行的代码的出处（并且有一个[倡议]（<a title="https://lwn.net/Articles/853489/%EF%BC%89%E6%AD%A3%E5%9C%A8%E5%8F%91%E6%8C%A5%E4%BD%9C%E7%94%A8%EF%BC%8C%E4%BB%A5%E6%94%AF%E6%8C%81%E5%AF%B9" href="https://lwn.net/Articles/853489/%EF%BC%89%E6%AD%A3%E5%9C%A8%E5%8F%91%E6%8C%A5%E4%BD%9C%E7%94%A8%EF%BC%8C%E4%BB%A5%E6%94%AF%E6%8C%81%E5%AF%B9">https://lwn.net/Articles/853489/）正在发挥作用，以支持对</a> eBPF 程序的签名检查，以帮助解决这种问题）。你还可以使用 eBPF 程序来密切关注其他 eBPF 程序！</p>
<p>现在你已经大致了解了为什么 eBPF 是云原生工具的强大基础，下一章将为你提供一些来自云原生生态系统的 eBPF 工具的具体示例。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[eBPF复杂性]]></title>
            <guid>006498407dcc4a5e90998ae265d7c1cd</guid>
            <pubDate>Wed, 21 Dec 2022 03:36:48 GMT</pubDate>
            <content:encoded><![CDATA[<h3 id="跨内核版本的可移植性">跨内核版本的可移植性</h3>
<p>eBPF 程序可以访问内核数据结构，这些数据结构可能会随着不同的内核版本而改变。结构本身是在构成 Linux 源代码一部分的头文件中定义的。过往，你必须针对与要运行这些程序的内核兼容的正确头文件集来编译 eBPF 程序。</p>
<h3 id="bcc-可移植性方法">BCC 可移植性方法</h3>
<p>为了解决跨内核的可移植性，BCC1（BPF Compiler Collection）项目采用了在运行时在目标机器上编译 eBPF 代码的方法。 这意味着编译工具链需要安装到代码运行的每台目标机器上2，并且你必须等待编译完成才能启动工具。你还必须保证内核头文件存在于文件系统上（但并非总是如此）。接着我们进入 BPF CO-RE。</p>
<h3 id="co-re">CO-RE</h3>
<p>CO-RE（一次编译，到处运行）方法包含几个元素：</p>
<h4 id="btf-bpf-type-format">BTF (BPF Type Format)</h4>
<p>这是一种表达数据结构和函数签名布局的格式。现代 Linux 内核支持 BTF，因此你可以从正在运行的系统生成一个名为 vmlinux.h 的头文件，其中包含 BPF 程序可能需要的有关内核的所有数据结构信息。</p>
<h4 id="libbpf-bpf-库">libbpf, BPF 库</h4>
<p>一方面，libbpf 提供了加载 eBPF 程序和 map 到内核的函数。但它在可移植性方面也起着重要作用：依据 BTF 信息来调整 eBPF 代码，以补偿编译时存在的数据结构与目标机器上的数据结构之间的任何差异。</p>
<h4 id="编译器支持">编译器支持</h4>
<p>clang 编译器得到了增强，因此当它编译 eBPF 程序时，它包括所谓的 BTF 重定向（relocations），这是 libbpf 在加载 BPF 程序和 map 到内核时用来知道要调整哪些内容。</p>
<h4 id="可选的-bpf-脚手架">可选的 BPF 脚手架</h4>
<p>可以使用 bpftool gen skeleton 从编译的 BPF 目标文件中自动生成脚手架，其中包含辅助函数，用户空间代码可以调用这些辅助函数来管理 BPF 程序的生命周期——将其加载到内核中，附加到事件等等。这些函数是更高级别的抽象，对开发人员来说比直接使用 libbpf 更方便。</p>
<p>有关 CO-RE 的更详细说明，请阅读 Andrii Nakryiko 详细的<a title="https://nakryiko.com/posts/bpf-portability-and-co-re/" href="https://nakryiko.com/posts/bpf-portability-and-co-re/">讲解</a>。</p>
<p>vmlinux 文件形式的 BTF 信息自 5.4 版起已包含在 Linux 内核中，但也可以为较旧的内核生成 libbpf 可以使用的原始 BTF 数据。<a title="https://github.com/aquasecurity/btfhub" href="https://github.com/aquasecurity/btfhub">BTF Hub</a> 上有关于如何生成 BTF 文件的信息，以及用于各种 Linux 发行版的文件存档。</p>
<p>BPF CO-RE 方法使 eBPF 程序员比过去更容易让他们的代码在任何 Linux 发行版上运行——或者至少在任何新的 Linux 发行版上运行，以支持程序使用的任何 eBPF 功能集。但这并不能使 eBPF 编程轻松自如：其本质上仍然是内核编程。</p>
<h3 id="linux-内核知识">Linux 内核知识</h3>
<p>很快你会认识到，你仍然需要关于 Linux 内核的领域知识才能编写更高级的工具。你需要了解可以访问的数据结构，这取决于调用 eBPF 代码的上下文。并非每个应用程序开发人员都有解析网络数据包、访问套接字缓冲区或处理系统调用参数的经验。</p>
<p>内核将如何响应 eBPF 代码的行为？正如你在第 2 章中所了解的，内核由数百万行代码组成。它的文档可能很少，因此你可能会发现自己必须阅读内核源代码才能弄清楚某些东西是如何工作的。</p>
<p>你还需要弄清楚 <strong>eBPF 代码应该附加到哪些事件上</strong>。如果可以选择将 kprobe 附加到整个内核中的任何函数入口点，这可能不是一个容易的决定。在某些情况下，这很简单，例如如果你想访问传入的网络数据包，那么在合适的网络接口进行 XDP 挂钩是一个明显的选择。如果你想提供对特定内核事件的可观察性，在内核代码中找到适当的附加点可能并不难。</p>
<p>但在其他情况下，选择可能并不带明确。例如，仅使用 kprobes 挂钩构成内核系统调用接口的函数的工具可能会受到称为 time-of-check to time-of-use (TOCTTOU) 的安全漏洞的影响。攻击者有一个很小的机会窗口，他们可以在 eBPF 代码读取参数之后，但在被复制到内核内存之前更改系统调用的参数。Rex Guo 和 Junyuan Zeng 在 DEF CON 29 上对此进行了精彩的<a title="https://www.youtube.com/watch?v=yaAdM8pWKG8" href="https://www.youtube.com/watch?v=yaAdM8pWKG8">演示</a>。一些最广泛使用的 eBPF 工具是以非常初级的方式编写的，并且容易受到这种攻击。这并不是一个容易的利用，并且有一些方法可以减轻这些攻击，但是如果你要保护高度敏感的数据免受老练的对手的攻击，请深入了解你使用的工具是否会受到影响。</p>
<p>你已经看到了 BPF CO-RE 如何使 eBPF 程序在不同的内核版本上工作，但它只考虑了数据结构布局的变化，而不考虑内核行为的更广泛的变化。例如，如果想将 eBPF 程序附加到内核中的特定函数或跟踪点，你可能需要一个计划 B，如果该函数或跟踪点不存在于不同的内核版本中该怎么办。</p>
<h3 id="多-ebpf-程序协调">多 eBPF 程序协调</h3>
<p>现在可用的许多基于 eBPF 的工具都提供了一套可观察性功能，通过将 eBPF 程序挂钩到一组内核事件来实现。其中大部分是由 Brendan Gregg 和其他人在 BCC 和 bpftrace 工具中所研发。当前这代（通常是商业的）工具可能会提供更漂亮的图形和 UI，但他们利用的 eBPF 程序高度基于这些原来的工具。</p>
<p>当你想要编写协调不同类型事件之间交互的代码时，事情会变得相当复杂。例如，Cilium 通过内核的网络栈在多个点查看网络数据包，并根据来自 Kubernetes CNI（容器网络接口）的有关 Kubernetes Pod 的信息来处理流量。构建这个系统需要 Cilium 开发人员深入了解内核如何处理网络流量，以及 “Pod” 和 “Container” 的用户空间概念如何映射到 cgroup 和 namespace 等内核概念。在实践中，几个 Cilium 维护者也是内核开发人员，致力于增强 eBPF 和网络支持；因此，他们拥有这些知识。</p>
<p>底线是，尽管 eBPF 提供了一个非常高效和强大的平台来连接内核，但对于没有丰富内核经验的普通开发人员来说，这不是一件容易的事。如果你有兴趣亲身体验 eBPF 编程，我强烈建议你将其作为练习学习；在这一领域积累经验可能非常有价值，因为它必将在未来几年继续成为广受欢迎的专业技能。但实际上，大多数组织不太可能在内部构建大量定制的 eBPF 工具，而是会利用来自专业 eBPF 社区的项目和产品。</p>
<blockquote>
<ol>
<li>Cilium 文档 描述了附加到不同网络钩子的 eBPF 程序如何组合以实现复杂的网络功能 .</li>
<li>有关更多信息，请参阅 Andrii Nakryiko 的 IO Visor <a title="https://lists.iovisor.org/g/iovisor-dev/message/1966" href="https://lists.iovisor.org/g/iovisor-dev/message/1966">帖子</a></li>
</ol>
</blockquote>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[eBPF程序]]></title>
            <guid>9179edc8a10440259cfed3172dc96a04</guid>
            <pubDate>Wed, 21 Dec 2022 02:24:37 GMT</pubDate>
            <content:encoded><![CDATA[<h3 id="定制程序附加到事件">定制程序附加到事件</h3>
<p>eBPF程序本身通常用C或Rust编写并编译成目标文件。目标文件是一个标准的 ELF（可执行和可链接格式）文件，可以使用 <code>readelf</code> 等工具进行检查，它包含程序字节码和<code> map</code> 的定义。</p>
<p><img src="/_resources/0b877c2c038c4686badaade0eaddcde1.png" /></p>
<p>一旦你将 eBPF 程序加载到内核中，它就必须附加到一个事件上。每当事件发生时，相关的 eBPF 程序就会被触发执行。</p>
<h3 id="进入或退出函数">进入或退出函数</h3>
<p>你可以附加一个 eBPF 程序，在进入或退出内核函数时触发。当前许多 eBPF 示例都使用 kprobes（附加到内核函数入口点）和 kretprobes（函数退出）的机制。在最近的内核版本中，有一个更有效的替代方案，称为 fentry/fexit</p>
<p>你还可以使用 uprobes 和 uretprobes 将 eBPF 程序附加到用户空间函数</p>
<h3 id="tracepoint">Tracepoint</h3>
<p>你也可以将eBPF程序附加到内核内定义的 tracepoints4。通过在 /sys/kernel/debug/tracing/events 下查找机器上的事件</p>
<h3 id="perf-事件">Perf 事件</h3>
<p>Perf 是一个用于收集性能数据的子系统。你可以将 eBPF 程序挂接到所有收集 perf 数据的地方，这可以通过在机器上运行 perf list 来确定。</p>
<h3 id="linux安全模块接口linux-security-module-interface">Linux安全模块接口（Linux Security Module Interface）</h3>
<p>LSM 接口允许在内核允许某些操作之前检查安全策略。你可能遇到过使用此接口的 AppArmor 或 SELinux。使用 eBPF，你可以将自定义程序附加到相同的检查点，从而实现灵活、动态的安全策略和运行时安全工具的一些新方法</p>
<h3 id="网络接口-xdpexpress-data-path">网络接口 XDP（eXpress Data Path）</h3>
<p><code>XDP（eXpress Data Path)</code> 允许将 eBPF 程序附加到网络接口，每当收到数据包就会触发 eBPF 执行。XDP 可以检查甚至修改数据包，eBPF 程序的退出代码用于通知内核如何处理该数据包：传递、丢弃或重定向。 这可以构成一些非常有效的网络功能的基础。</p>
<h3 id="套接字和其他网络-hook">套接字和其他网络 Hook</h3>
<p>你可以附加 eBPF 程序以在应用程序打开在网络套接字上执行操作、以及在发送或接收消息时运行 eBPF 程序。 在内核的网络栈中还有称为 traffic control 或 tc 的 Hook，eBPF 程序可以在初始数据包处理后运行</p>
<p>有些功能可以单独使用 eBPF 程序来实现，但在许多情况下，我们希望 eBPF 代码从用户空间应用程序接收信息或将数据传递给用户空间应用程序。 允许数据在 eBPF 程序和用户空间之间或不同 eBPF 程序之间传递的机制称为<code> maps</code></p>
<h3 id="ebpf-map">eBPF Map</h3>
<p>Map 功能的添加是 eBPF 首字母缩写词中 e 代表 扩展 的显着标志之一。</p>
<p>Map 是与 eBPF 程序一起定义的数据结构。Map 有多种不同类型的，但它们本质上都是键值存储。eBPF 程序及用户空间代码可以读取和写入数据。Map 的常见用途包括：</p>
<ul>
<li>一个 eBPF 程序编写有关事件的指标和其他数据，供用户空间代码稍后查询；</li>
<li>用户空间代码编写配置信息，以便 eBPF 程序读取并相应地执行；</li>
<li>一个 eBPF 将数据写入 map，供另一个 eBPF 程序读取，这种方式允许跨多个内核事件同步信息；</li>
</ul>
<p>如果内核和用户空间代码都将访问同一个 map，他们将需要对存储在 mmap 中的数据结构达成共识。这可以通过在用户空间和内核代码中包含定义这些数据结构的头文件来完成，但如果两者是通过不相同的语言编写，你将需要仔细创建字节结构定义字节对齐兼容。</p>
<p>我们已经讨论了 eBPF 工具的主要组成部分：在内核中运行的 eBPF 程序、加载程序并与之交互的用户空间代码，以及允许程序共享数据的 map。为了更好理解，我们通过一个例子演示。</p>
<h3 id="opensnoop-样例">Opensnoop 样例</h3>
<p>对于 eBPF 程序示例，我选择了实用的工具 opensnoop，其可用于显示任何进程打开了哪些文件。该实用程序的原始版本是 Brendan Gregg 最初在 BCC 项目中编写的众多 BPF 工具之一，你可以在 GitHub 上找到该项目。后来该工具使用 libbpf 重写（你将在下一章中看到），在这个例子中，我使用的是 libbpf-tools 目录下的较新版本。</p>
<p>当运行 opensnoop 时，你将看到的输出很大程度上取决于当时虚拟机上发生的情况，但它应该看起来像这样：</p>
<div><pre class="hljs"><code>PID    COMM FD ERR PATH
93965  cat     3   0 /etc/ld.so.cache
93965  cat     3   0 /lib/x86_64-linux-gnu/libc.so.6
93965  cat     3   0 /usr/lib/locale/locale-archive
93965  cat     3   0 /usr/share/locale/locale.alias
...</code></pre></div>
<p>每一行输出表示一个进程打开（或试图打开）一个文件。这些列显示了进程 ID、正在运行的命令、文件描述符、任何错误代码的指示以及被打开文件的路径。</p>
<p>Opensnoop 的工作方式是将 eBPF 程序附加到 open() 和 openat() 系统调用上，任何应用程序都必须通过这些调用来要求内核打开一个文件。让我们深入了解一下这一点是如何实现的。为了简洁起见，我们并不看每一行代码，但我希望这足以让你了解它是如何工作的。(如果你对这么深的内容不感兴趣的话，请跳到下一章！）。</p>
<p>每行输出表明一个进程打开（或试图打开）一个文件。 这些列显示进程 ID、正在运行的命令、文件描述符、任何错误代码以及正在打开的文件的路径。</p>
<p>Opensnoop 通过将 eBPF 程序附加到 open() 和 openat() 系统调用上工作，任何应用程序都必须进行这些调用以请求内核打开文件。 接着，我们将深入了解其实现。为简洁起见，我们不会查看代码的每一行，但我希望它足以让你了解其工作原理。（如果你对深入研究不感兴趣，请随意跳到下一章！）</p>
<h3 id="opensnoop-ebpf-代码">Opensnoop eBPF 代码</h3>
<p>eBPF 代码是用 C 语言编写的，位于文件 opensnoop.bpf.c 中。在该文件的头部附近，你可以看到两个 eBPF map 的定义 start 和 event：</p>
<div><pre class="hljs"><code>    <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
        __uint(type, BPF_MAP_TYPE_HASH);
        __uint(max_entries, <span class="hljs-number">10240</span>);
        __type(key, u32);
        __type(value, <span class="hljs-keyword">struct</span> <span class="hljs-type">args_t</span>);
    } start <span class="hljs-title function_">SEC</span><span class="hljs-params">(<span class="hljs-string">".maps"</span>)</span>;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
        __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);
        __uint(key_size, <span class="hljs-keyword">sizeof</span>(u32));
        __uint(value_size, <span class="hljs-keyword">sizeof</span>(u32));
    } events <span class="hljs-title function_">SEC</span><span class="hljs-params">(<span class="hljs-string">".maps"</span>)</span>;</code></pre></div>
<p>当创建 ELF 目标文件时，它包含每个 map 和要加载到内核中的每个程序的区块（section），通过 SEC() 宏定义。</p>
<p>当我们查看程序时，你将看到，start map 用于在处理系统调用时临时存储系统调用的参数（包括正在打开的文件的名称）。events map 7 用于将事件信息从内核中的 eBPF 代码传递到用户空间可执行文件。 如图 3-2 所示。<br />
<img src="/_resources/b933858157824a2fb9af347c7d5608bf.png" /></p>
<p>在 opensnoop.bpf.c 文件的后面，你会发现两个非常相似的函数：</p>
<div><pre class="hljs"><code>SEC(<span class="hljs-string">"tracepoint/syscalls/sys_enter_open"</span>)
    <span class="hljs-type">int</span> <span class="hljs-title function_">tracepoint__syscalls__sys_enter_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span>
        trace_event_raw_sys_enter* ctx)</span></code></pre></div>
<p>和</p>
<div><pre class="hljs"><code>    SEC(<span class="hljs-string">"tracepoint/syscalls/sys_enter_openat"</span>)
    <span class="hljs-type">int</span> <span class="hljs-title function_">tracepoint__syscalls__sys_enter_openat</span><span class="hljs-params">(<span class="hljs-keyword">struct</span>
    trace_event_raw_sys_enter* ctx)</span></code></pre></div>
<p>打开文件有两种不同的系统调用：8 openat() 和 open()。两者功能相同，只是 openat() 有一个额外的目录文件描述符参数，并且要打开的文件的路径名是相对于该目录的。同样，除了处理参数中的差异外，opensnoop 中对应的两个处理函数是相同。</p>
<p>如你所见，它们都采用指向 trace_event_raw_sys_enter 的结构的指针参数。你可以在运行的特定内核生成的 vmlinux 头文件中找到此结构的定义。 编写 eBPF 程序的包括计算程序接收到的结构作为其上下文，以及如何访问其中的信息。</p>
<p>这两个函数使用 BPF 辅助函数来获取到请求系统调用的进程的 ID：</p>
<div><pre class="hljs"><code>u64 id = bpf_get_current_pid_tgid();</code></pre></div>
<p>后续代码得到了文件名和传递给系统调用的标志，并把它们放在一个叫做 args 的结构中：</p>
<div><pre class="hljs"><code>args.fname = (<span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *)ctx-&gt;args[<span class="hljs-number">0</span>];
             args.flags = (<span class="hljs-type">int</span>)ctx-&gt;args[<span class="hljs-number">1</span>];</code></pre></div>
<p>该结构使用当前程序 ID 作为 key 保存到 start map 中。</p>
<div><pre class="hljs"><code>bpf_map_update_elem(&amp;start, &amp;pid, &amp;args, <span class="hljs-number">0</span>);</code></pre></div>
<p>这就是 eBPF 程序在进入系统调用时所做的全部。但是在 opensnoop.bpf.c 中定义的另一对 eBPF 程序会在系统调用退出时触发：</p>
<div><pre class="hljs"><code>SEC(<span class="hljs-string">"tracepoint/syscalls/sys_exit_open"</span>)
<span class="hljs-type">int</span> tracepoint__syscalls__sys_exit_open</code></pre></div>
<p>该程序及其函数 openat() 共享函数 trace_exit() 中的公共代码。你有没有注意到 eBPF 程序调用的所有函数都以静态 __always_inline 为前缀？这指示编译器将函数的指令内联，这是因为在旧版本内核中，不允许 BPF 程序跳转到单独的函数。较新的内核和 LLVM 版本中已经可以支持非内联函数调用，但是设置 <code>__always_inline</code> 可确保 BPF 验证器保能够更好工作。（现在还有 BPF 尾调用的概念，即执行从一个 BPF 程序跳转到另一个。你可以在 eBPF 文档中阅读有关 BPF 函数调用和尾部调用的更多信息。）</p>
<p>在 trace_exit() 函数中创建一个空的事件结构：</p>
<div><pre class="hljs"><code>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">event</span> <span class="hljs-title">event</span> =</span> {};</code></pre></div>
<p>这将填充有关即将结束的 open/openat 系统调用的信息，并通过 event map 发送到用户空间。</p>
<p>在开始的 start hash_map 中应该有一个对应于当前进程 ID 的条目：</p>
<div><pre class="hljs"><code>ap = bpf_map_lookup_elem(&amp;start, &amp;pid);</code></pre></div>
<p>这包含有关在 sys_enter_open(at) 调用期间先前写入的文件名和 flags 的信息。 flags 字段是一个直接存储在结构体中的整数，所以直接从结构体中读取就可以了：</p>
<div><pre class="hljs"><code>    event.flags = ap-&gt;flags;</code></pre></div>
<p>相反，文件名被写入用户空间内存中的一些字节数，验证器需要确保此 eBPF 程序从内存中的该位置读取该字节数是安全的。这是使用另一个辅助函数 bpf_probe_read_user_str() 完成的：</p>
<div><pre class="hljs"><code>    bpf_probe_read_user_str(&amp;event.fname, <span class="hljs-keyword">sizeof</span>(event.fname), ap-&gt;fname);</code></pre></div>
<p>当前的命令行名称（即进行 open(at) 系统调用的可执行文件的名称）也被复制到事件结构中，使用另一个 BPF 辅助函数：</p>
<div><pre class="hljs"><code>bpf_get_current_comm(&amp;event.comm, <span class="hljs-keyword">sizeof</span>(event.comm));</code></pre></div>
<p>event 结构被写入事件 perf 缓冲区 map ：</p>
<div><pre class="hljs"><code>bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU, &amp;event, <span class="hljs-keyword">sizeof</span>(event));</code></pre></div>
<p>用户空间代码从该 map 中读取事件信息。在我们讨论这个问题之前，让我们简要地看一下 Makefile。</p>
<h3 id="libbpf-tools-makefile">libbpf-tools Makefile</h3>
<p>当构建 eBPF 代码时，你会得到一个包含 eBPF 程序和 map 的二进制定义的目标文件。你还需要额外的一个用户空间可执行文件，它将这些程序和 map 加载到内核中，并充当用户接口。 让我们看看构建 opensnoop 的 Makefile，是如何创建 eBPF 目标文件和可执行文件的。</p>
<p>Makefiles 由一组规则组成，这些规则的语法可能有点不透明（opaque），所以如果你不熟悉 Makefiles 并且不是特别关心细节，请随意跳过本节！</p>
<p>我们正在查看的 opensnoop 示例是诸多样例工具之一，这些样例工具共同使用一个 Makefile 构建，你可以在 libbpf-tools 目录中找到该 Makefile。 此文件中的所有内容并非都特别令人感兴趣，但我想强调一些规则。第一个是使用 bpf.c 文件并使用 clang 编译器创建 BPF 目标对象文件的规则：</p>
<div><pre class="hljs"><code>**$(OUTPUT)/%.bpf.o**: **%.bpf.c** $(LIBBPF_OBJ) $(wildcard %.h) $(AR.. $(call msg,BPF,$@)
$(Q)$(**CLANG**) $(CFLAGS) **-target bpf** -D__TARGET_ARCH_$(ARCH) \
-I$(ARCH)/ $(INCLUDES) -c $(filter %.c,$^) -o $@ &amp;&amp; \
    $(LLVM_STRIP) -g $@</code></pre></div>
<p>因此，opensnoop.bpf.c 被编译成 $(OUTPUT)/open snoop.bpf.o。这个对象文件包含将被载入内核的 eBPF 程序和 map。</p>
<p>另一条规则使用 bpftool gen skeleton 从 bpf.o 对象文件中包含的映射和程序定义创建一个脚手架头文件。</p>
<p>因此，opensnoop.bpf.c 被编译成 $(OUTPUT)/open snoop.bpf.o。该目标文件包含将加载到内核中的 eBPF 程序和 map。</p>
<p>另一个规则使用 bpftool gen 脚手架从该 bpf.o 目标文件中包含的 map 和程序定义创建脚手架头文件：</p>
<div><pre class="hljs"><code>**$(OUTPUT)/%.skel.h: $(OUTPUT)/%.bpf.o** | $(OUTPUT) $(call msg,GEN-SKEL,$@)
$(Q)$(**BPFTOOL**) **gen skeleton** $&lt; &gt; $@</code></pre></div>
<p>opensnoop.c 用户空间代码包含这个 opensnoop.skel.h 头文件，以获取它与内核中的 eBPF 程序共享的 map 的定义。这允许用户空间和内核代码了解存储在这些 map 中的数据结构的布局。</p>
<p>以下规则将用户空间代码从 opensnoop.c 编译成一个名为 $(OUTPUT)/opensnoop.o 的二进制对象：</p>
<div><pre class="hljs"><code>**$(OUTPUT)/%.o**: %.c $(wildcard %.h) $(LIBBPF_OBJ) | $(OUTPUT) $(call msg,CC,$@)
$(Q)$(**CC**) $(CFLAGS) $(INCLUDES) -c $(filter %.c,$^) -o $@</code></pre></div>
<p>最后，有一个规则使用 cc 将用户空间应用程序对象（在我们的例子中，opensnoop.o）链接到一组可执行文件中：</p>
<div><pre class="hljs"><code>$(APPS): %: $(OUTPUT)/%.o $(LIBBPF_OBJ) $(COMMON_OBJ) | $(OUT... $(call msg,BINARY,$@)
$(Q)$ (**CC**) $(CFLAGS) $^ $(LDFLAGS) -lelf -lz -o $@</code></pre></div>
<p>现在你已经了解了如何分别生成 eBPF 和用户空间程序，接着让我们看看对应的用户空间代码。</p>
<h3 id="opensnoop-用户空间代码">Opensnoop 用户空间代码</h3>
<p>正如我所提到的，与 eBPF 代码交互的用户空间代码几乎可以用任何编程语言编写。我们将在本节讨论的示例是用 C 编写的，但如果你有兴趣，可以将其与用 Python 编写的原始 BCC 版本进行比较，你可以在 bcc/tools 中找到它。</p>
<p>用户空间代码在 opensnoop.c 文件中。文件的前半部分有 #include 指令（其中一个是自动生成的 opensnoop.skel.h 文件）、各种定义以及处理不同命令行选项的代码，我们不会在这里详述。让我们也略过诸如 print_event() 之类的函数，它将有关事件的信息写入屏幕。从 eBPF 的角度来看，所有有趣的代码都在 main() 函数中。</p>
<p>你将看到诸如 <code>opensnoop_bpf__open()</code>、<code>open snoop_bpf__load()</code> 和 <code>opensnoop_bpf__attach()</code> 之类的函数。这些都是在<code> bpftool gen</code> 脚手架创建的自动生成代码中定义的。10 自动生成的代码处理在 eBPF 目标文件中定义的所有单独的 eBPF 程序、map 和附加点。</p>
<p>一旦 opensnoop 启动并运行，其工作就是监听事件 perf 缓冲区并将事件中包含的信息写入屏幕。首先，它打开与 perf 缓冲区关联的文件描述符，并将 handle_event() 设置为新事件到达时的调用的函数：</p>
<div><pre class="hljs"><code>     pb = perf_buffer__new(bpf_map__fd(obj-&gt;maps.events),
         PERF_BUFFER_PAGES, handle_event, handle_lost_events,
         <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);</code></pre></div>
<p>然后程序轮询缓冲区事件，直到达到时间限制，或者用户中断程序：</p>
<div><pre class="hljs"><code>     <span class="hljs-keyword">while</span> (!exiting) {
              err = perf_buffer__poll(pb, PERF_POLL_TIMEOUT_MS);
       ... 
     }</code></pre></div>
<p>传递给 handle_event() 的数据参数指向 eBPF 程序为该事件写入 map 的事件结构。用户空间代码可以获取此信息，对其进行格式化并将供用户查看。</p>
<p>正如你所见，opensnoop 注册了 eBPF 程序，每次任何应用程序调用 open() 或 openat() 系统调用时都会调用 eBPF 程序。这些在内核中运行的 eBPF 程序收集有关该系统调用的上下文的信息——可执行文件名称和进程 ID——以及有关正在打开的文件的信息。此信息被写入 map，用户空间可以从中读取它并将其显示给用户。</p>
<p>你可以在 libbpf-tools 目录中找到数十个类似的 eBPF 工具示例，每个示例通常检测一个系统调用或一系列相关的系统调用，如 open() 和 openat()。</p>
<p>系统调用是一个稳定的内核接口，它们提供了一种非常强大的方式来观察（虚拟）机器上发生的事情。但不要误以为 eBPF 编程开始和结束于拦截系统调用。除此之外，还有很多其他稳定的接口用于附加 eBPF 程序，包括 LSM 和网络栈中的各个挂载点。如果愿意冒险或解决内核版本之间的更改，那么你可以附加 eBPF 程序的地方范围将会非常广泛。</p>
<blockquote>
<ol>
<li>请参阅 <a title="https://docs.cilium.io/en/stable/bpf/#instruction-set" href="https://docs.cilium.io/en/stable/bpf/#instruction-set">BPF 指令集文档</a>。</li>
<li>Brendan Gregg 的网站是一个很好的关于<a title="https://www.brendangregg.com/perf.html" href="https://www.brendangregg.com/perf.html">perf event</a>的信息来源。<br />
如果你有兴趣看到一个具体的例子，你可能想看我在 <a title="https://oreil.ly/K6jLs" href="https://oreil.ly/K6jLs">2021 年 eBPF 峰会</a>上的演讲，我在几分钟内实现了一个非常基本的负载均衡器，作为我们如何使用的说明 eBPF 改变内核处理网络数据包的方式<br />
在撰写本文时，此代码为事件 map 使用 perf 缓冲区。如果今天为最近的内核编写此代码，你将从 <a title="https://nakryiko.com/posts/bpf-ringbuf/#bpf-ringbuf-vs-bpf-perfbuf" href="https://nakryiko.com/posts/bpf-ringbuf/#bpf-ringbuf-vs-bpf-perfbuf">ring buffer</a> 缓冲区获得更好的性能，这是一种较新的替代方案<br />
参见 Andrii Nakryiko 描述 BPF 脚手架代码生成的<a title="https://lwn.net/Articles/806328/" href="https://lwn.net/Articles/806328/">帖子</a></li>
</ol>
</blockquote>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[K8s Code-Generator工具概览]]></title>
            <guid>7f35bf7cd74c4c79afbbb5e0a9bd1b5e</guid>
            <pubDate>Fri, 16 Dec 2022 07:38:37 GMT</pubDate>
            <content:encoded><![CDATA[<blockquote>
<p><a title="https://github.com/kubernetes/code-generator" href="https://github.com/kubernetes/code-generator">Code-Generator工具</a> 生成Kubernets风格的API类型</p>
</blockquote>
<p><code>k8s.io/client-go</code>提供了对k8s原生资源的informer和clientset等等，但对于自定义资源的操作则相对低效，需要使用 rest api 和 dynamic client 来操作，并自己实现反序列化等功能。</p>
<p><code>code-generator</code> 提供了以下工具用于为k8s中的资源生成相关代码，可以更加方便的操作自定义资源：</p>
<ul>
<li><code>deepcopy-gen</code>: 生成深度拷贝对象方法
<ul>
<li>在文件中添加注释<code>// +k8s:deepcopy-gen=package</code></li>
<li>为单个类型添加自动生成<code>// +k8s:deepcopy-gen=true</code></li>
<li>为单个类型关闭自动生成<code>// +k8s:deepcopy-gen=false</code></li>
</ul>
</li>
<li><code>client-gen</code>: 为资源生成标准的操作方法(get;list;watch;create;update;patch;delete) 在<code>pkg/apis/${GROUP}/${VERSION}/types.go</code>中使用，使用<code>// +genclient</code>标记对应类型生成的客户端，如果与该类型相关联的资源不是命名空间范围的(例如PersistentVolume), 则还需要附加<code>// + genclient：nonNamespaced</code>标记
<ul>
<li><code>// +genclient</code>:  生成默认的客户端动作函数（create, update, delete, get, list, update, patch, watch以及 是否生成updateStatus取决于.Status字段是否存在）</li>
<li><code>// +genclient:nonNamespaced</code>: 所有动作函数都是在没有名称空间的情况下生成</li>
<li><code>// +genclient:onlyVerbs=create,get</code>: 指定的动作函数被生成</li>
<li><code>// +genclient:skipVerbs=watch</code>: 生成watch以外所有的动作函数</li>
<li><code>// +genclient:noStatus</code>: 即使.Status字段存在也不生成updateStatus动作函数</li>
</ul>
</li>
<li><code>informer-gen</code>: 生成informer，提供事件机制(AddFunc,UpdateFunc,DeleteFunc)来响应kubernetes的event</li>
<li><code>lister-gen</code>: 为get和list方法提供只读缓存层</li>
<li><code>conversion-gen</code>: 是用于自动生成在内部和外部类型之间转换的函数的工具<br />
一般的转换代码生成任务涉及三套程序包：
<ul>
<li>一套包含内部类型的程序包</li>
<li>一套包含外部类型的程序包</li>
<li>单个目标程序包（即，生成的转换函数所在的位置，以及开发人员授权的转换功能所在的位置）, 包含内部类型的包在Kubernetes的常规代码生成框架中扮演着称为<code>peer package</code>的角色<br />
使用方法</li>
<li><code>// +k8s:conversion-gen=&lt;import-path-of-internal-package&gt;</code>: 标记转换内部软件包</li>
<li><code>// +k8s:conversion-gen-external-types=&lt;import-path-of-external-package&gt;</code>: 标记转换外部软件包</li>
<li><code>// +k8s:conversion-gen=false</code>: 标记不转换对应注释或结构</li>
</ul>
</li>
<li><code>defaulter-gen</code>: 用于生产Defaulter函数
<ul>
<li><code>// +k8s:defaulter-gen=&lt;field-name-to-flag&gt;</code>: 为包含字段的所有类型创建defaulters</li>
<li><code>// +k8s:defaulter-gen=true|false</code>: 所有都生成</li>
</ul>
</li>
<li><code>go-to-protobuf</code>: 通过go struct生成pb idl</li>
<li><code>import-boss</code>: 在给定存储库中强制执行导入限制</li>
<li><code>openapi-gen</code>: 生成openAPI定义<br />
使用方法：
<ul>
<li><code>+k8s:openapi-gen=true</code>: 为指定包或方法开启</li>
<li><code>+k8s:openapi-gen=false</code>: 指定包关闭</li>
</ul>
</li>
<li><code>register-gen</code>: 生成register</li>
<li><code>set-gen</code><br />
code-generator整合了这些gen，使用脚本<a title="https://github.com/kubernetes/code-generator/blob/master/generate-groups.sh" href="https://github.com/kubernetes/code-generator/blob/master/generate-groups.sh">generate-groups.sh</a>和<a title="https://github.com/kubernetes/code-generator/blob/master/generate-internal-groups.sh" href="https://github.com/kubernetes/code-generator/blob/master/generate-internal-groups.sh">generate-internal-groups.sh</a>可以为自定义资源生产相关代码。</li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Code-Generator 生成crd的clientset、informer、listers]]></title>
            <guid>be1a77beec5a4d11a3a886d59e7cea33</guid>
            <pubDate>Fri, 16 Dec 2022 07:35:50 GMT</pubDate>
            <content:encoded><![CDATA[<blockquote>
<p><a title="https://github.com/kubernetes/code-generator" href="https://github.com/kubernetes/code-generator">Code-Generator工具</a> 生成Kubernets风格的API类型</p>
</blockquote>
<p><code>k8s.io/client-go</code>提供了对k8s原生资源的informer和clientset等等，但对于自定义资源的操作则相对低效，需要使用 rest api 和 dynamic client 来操作，并自己实现反序列化等功能。</p>
<p><code>code-generator</code> 提供了以下工具用于为k8s中的资源生成相关代码，可以更加方便的操作自定义资源：</p>
<ul>
<li><code>deepcopy-gen</code>: 生成深度拷贝对象方法
<ul>
<li>在文件中添加注释<code>// +k8s:deepcopy-gen=package</code></li>
<li>为单个类型添加自动生成<code>// +k8s:deepcopy-gen=true</code></li>
<li>为单个类型关闭自动生成<code>// +k8s:deepcopy-gen=false</code></li>
</ul>
</li>
<li><code>client-gen</code>: 为资源生成标准的操作方法(get;list;watch;create;update;patch;delete) 在<code>pkg/apis/${GROUP}/${VERSION}/types.go</code>中使用，使用<code>// +genclient</code>标记对应类型生成的客户端，如果与该类型相关联的资源不是命名空间范围的(例如PersistentVolume), 则还需要附加<code>// + genclient：nonNamespaced</code>标记
<ul>
<li><code>// +genclient</code>:  生成默认的客户端动作函数（create, update, delete, get, list, update, patch, watch以及 是否生成updateStatus取决于.Status字段是否存在）</li>
<li><code>// +genclient:nonNamespaced</code>: 所有动作函数都是在没有名称空间的情况下生成</li>
<li><code>// +genclient:onlyVerbs=create,get</code>: 指定的动作函数被生成</li>
<li><code>// +genclient:skipVerbs=watch</code>: 生成watch以外所有的动作函数</li>
<li><code>// +genclient:noStatus</code>: 即使.Status字段存在也不生成updateStatus动作函数</li>
</ul>
</li>
<li><code>informer-gen</code>: 生成informer，提供事件机制(AddFunc,UpdateFunc,DeleteFunc)来响应kubernetes的event</li>
<li><code>lister-gen</code>: 为get和list方法提供只读缓存层</li>
<li><code>conversion-gen</code>: 是用于自动生成在内部和外部类型之间转换的函数的工具<br />
一般的转换代码生成任务涉及三套程序包：
<ul>
<li>一套包含内部类型的程序包</li>
<li>一套包含外部类型的程序包</li>
<li>单个目标程序包（即，生成的转换函数所在的位置，以及开发人员授权的转换功能所在的位置）, 包含内部类型的包在Kubernetes的常规代码生成框架中扮演着称为<code>peer package</code>的角色<br />
使用方法</li>
<li><code>// +k8s:conversion-gen=&lt;import-path-of-internal-package&gt;</code>: 标记转换内部软件包</li>
<li><code>// +k8s:conversion-gen-external-types=&lt;import-path-of-external-package&gt;</code>: 标记转换外部软件包</li>
<li><code>// +k8s:conversion-gen=false</code>: 标记不转换对应注释或结构</li>
</ul>
</li>
<li><code>defaulter-gen</code>: 用于生产Defaulter函数
<ul>
<li><code>// +k8s:defaulter-gen=&lt;field-name-to-flag&gt;</code>: 为包含字段的所有类型创建defaulters</li>
<li><code>// +k8s:defaulter-gen=true|false</code>: 所有都生成</li>
</ul>
</li>
<li><code>go-to-protobuf</code>: 通过go struct生成pb idl</li>
<li><code>import-boss</code>: 在给定存储库中强制执行导入限制</li>
<li><code>openapi-gen</code>: 生成openAPI定义<br />
使用方法：
<ul>
<li><code>+k8s:openapi-gen=true</code>: 为指定包或方法开启</li>
<li><code>+k8s:openapi-gen=false</code>: 指定包关闭</li>
</ul>
</li>
<li><code>register-gen</code>: 生成register</li>
<li><code>set-gen</code><br />
code-generator整合了这些gen，使用脚本<a title="https://github.com/kubernetes/code-generator/blob/master/generate-groups.sh" href="https://github.com/kubernetes/code-generator/blob/master/generate-groups.sh">generate-groups.sh</a>和<a title="https://github.com/kubernetes/code-generator/blob/master/generate-internal-groups.sh" href="https://github.com/kubernetes/code-generator/blob/master/generate-internal-groups.sh">generate-internal-groups.sh</a>可以为自定义资源生产相关代码。</li>
</ul>
<h2 id="kubebuilder">kubebuilder</h2>
<blockquote>
<p>Kubebuilder是用于使用 <a title="https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/" href="https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/">自定义资源定义（CRD）</a> 构建Kubernetes API的框架。</p>
<p>类似于Ruby on Rails和SpringBoot之类的Web开发框架，Kubebuilder可以提高速度并降低开发人员管理的复杂性，以便在Go中快速构建和发布Kubernetes API。它建立在用于构建核心Kubernetes API的规范技术的基础之上，以提供减少样板和麻烦的简单抽象。</p>
<p>Resource + Controller = Operator，可以利用Kubebuilder编写自定义资源的Operator。</p>
</blockquote>
<h3 id="结合背景">结合背景</h3>
<p><code>Kubebuilder</code> 与 <code>code-generator</code> 都可以为CRD生成Kubernetes API相关代码，从代码生成层面来讲， 两者的区别在于</p>
<ul>
<li>Kubebuilder不会生成informers、listers、clientsets，而code-generator会。</li>
<li>Kubebuilder会生成Controller、Admission Webhooks，而code-generator不会。</li>
<li>Kubebuilder会生成manifests yaml，而code-generator不会。</li>
<li>Kubebuilder还带有一些其他便利性设施。</li>
</ul>
<p>使用Kubebuilder可以快捷生成CRD以及相关的控制器框架，然而由于Kubebuilder不会生成clientset等包，当别的服务想要操作CRD时将会很麻烦。</p>
<p>两者结合后可以使用Kubebuilder生成CRD和一整套控制器架构，再使用code-generator生成informers、listers、clientsets等。</p>
<h3 id="初始化项目">初始化项目</h3>
<h4 id="创建一个项目">创建一个项目</h4>
<div><pre class="hljs"><code>[root@kubebuilder ~]<span class="hljs-comment"># mkdir -p $GOPATH/src/my.domain/example</span>
[root@kubebuilder ~]<span class="hljs-comment"># cd $GOPATH/src/my.domain/example</span>
[root@kubebuilder example]<span class="hljs-comment"># kubebuilder init --domain my.domain </span>
[root@kubebuilder example]<span class="hljs-comment"># tree -CL 2</span>
.
├── config
│   ├── default
│   ├── manager
│   ├── prometheus
│   └── rbac
├── Dockerfile
├── go.mod
├── go.sum
├── hack
│   └── boilerplate.go.txt
├── main.go
├── Makefile
└── PROJECT</code></pre></div>
<h4 id="创建一个api">创建一个api</h4>
<div><pre class="hljs"><code>[root@kubebuilder example]<span class="hljs-comment"># kubebuilder create api --group example --version v1 --kind Guestbook</span>
Create Resource [y/n]
y
Create Controller [y/n]
y
...

[root@kubebuilder example]<span class="hljs-comment"># tree -CL 3</span>
.
├── api
│   └── v1
│       ├── groupversion_info.go
│       ├── guestbook_types.go
│       └── zz_generated.deepcopy.go
├── bin
│   └── controller-gen
├── config
│   ├── crd
│   │   ├── kustomization.yaml
│   │   ├── kustomizeconfig.yaml
│   │   └── patches
│   ├── default
│   │   ├── kustomization.yaml
│   │   ├── manager_auth_proxy_patch.yaml
│   │   └── manager_config_patch.yaml
│   ├── manager
│   │   ├── controller_manager_config.yaml
│   │   ├── kustomization.yaml
│   │   └── manager.yaml
│   ├── prometheus
│   │   ├── kustomization.yaml
│   │   └── monitor.yaml
│   ├── rbac
│   │   ├── auth_proxy_client_clusterrole.yaml
│   │   ├── auth_proxy_role_binding.yaml
│   │   ├── auth_proxy_role.yaml
│   │   ├── auth_proxy_service.yaml
│   │   ├── guestbook_editor_role.yaml
│   │   ├── guestbook_viewer_role.yaml
│   │   ├── kustomization.yaml
│   │   ├── leader_election_role_binding.yaml
│   │   ├── leader_election_role.yaml
│   │   ├── role_binding.yaml
│   │   └── service_account.yaml
│   └── samples
│       └── example_v1_guestbook.yaml
├── controllers
│   ├── guestbook_controller.go
│   └── suite_test.go
├── Dockerfile
├── go.mod
├── go.sum
├── hack
│   └── boilerplate.go.txt
├── main.go
├── Makefile
└── PROJECT</code></pre></div>
<p>注意：<br />
如果修改了<code>api/v1/guestbook_types.go</code>，需要执行以下命令来更新代码和manifests：</p>
<div><pre class="hljs"><code>make &amp;&amp; make manifests</code></pre></div>
<h4 id="使用code-generator">使用code-generator</h4>
<h5 id="更新依赖版本">更新依赖版本</h5>
<p>初始化项目后的go.mod：</p>
<div><pre class="hljs"><code>[root@kubebuilder example]<span class="hljs-comment"># cat go.mod</span>
module my.domain

go 1.16

require (
    github.com/onsi/ginkgo v1.14.1
    github.com/onsi/gomega v1.10.2
    k8s.io/apimachinery v0.20.2
    k8s.io/client-go v0.20.2
    sigs.k8s.io/controller-runtime v0.8.3
)</code></pre></div>
<p>需要将初始化的k8s库更新到要使用的版本，如：</p>
<div><pre class="hljs"><code>[root@kubebuilder example]<span class="hljs-comment"># K8S_VERSION=v0.18.6</span>
[root@kubebuilder example]<span class="hljs-comment"># go get k8s.io/client-go@$K8S_VERSION</span>
[root@kubebuilder example]<span class="hljs-comment"># go get k8s.io/apimachinery@$K8S_VERSION</span></code></pre></div>
<h5 id="安装code-generator">安装code-generator</h5>
<p>k8s的版本号与 go.mod 中的 k8s.io/client-go 的版本保持一致即可。</p>
<p>**注意：**需要将依赖复制到vendor中</p>
<div><pre class="hljs"><code>最新版本已经不包含， github.com/googleapis/gnostic/OpenAPIv2 ，如果不改版本会报如下错误
...
    github.com/googleapis/gnostic/OpenAPIv2: module github.com/googleapis/gnostic@latest found (v0<span class="hljs-number">.5</span><span class="hljs-number">.5</span>), but does not contain <span class="hljs-keyword">package</span> github.com/googleapis/gnostic/OpenAPIv2
Error: failed to create API: unable to run post-scaffold tasks of <span class="hljs-string">"base.go.kubebuilder.io/v3"</span>: exit status <span class="hljs-number">1</span>
...
[root@kubebuilder example]# <span class="hljs-keyword">go</span> get github.com/googleapis/gnostic@v0<span class="hljs-number">.4</span><span class="hljs-number">.0</span>

[root@kubebuilder example]# <span class="hljs-keyword">go</span> get k8s.io/code-generator@$K8S_VERSION
[root@kubebuilder example]# <span class="hljs-keyword">go</span> mod vendor</code></pre></div>
<h5 id="创建修改所需文件">创建&amp;修改所需文件</h5>
<p>需要在api目录下创建code-generator所需的文件，并添加相关注释。</p>
<ul>
<li>新增 <code>api/v1/doc.go</code>,<br />
<strong>注意</strong>: 修改groupName，package与api的version保持一致。</li>
</ul>
<div><pre class="hljs"><code>[root@kubebuilder example]# cat api/v1/doc.<span class="hljs-keyword">go</span>
<span class="hljs-comment">// +k8s:deepcopy-gen=package</span>
 
<span class="hljs-comment">// Package v1 is the v1alpha1 version of the API.</span>
<span class="hljs-comment">// +groupName=example.my.domain</span>
<span class="hljs-keyword">package</span> v1</code></pre></div>
<ul>
<li>新增<code>api/v1/register.go</code><br />
<strong>注意</strong>: package与api的version保持一致</li>
</ul>
<div><pre class="hljs"><code>[root@kubebuilder example]# cat api/v1/register.<span class="hljs-keyword">go</span>
<span class="hljs-keyword">package</span> v1
  
<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"k8s.io/apimachinery/pkg/runtime/schema"</span>
)
  
<span class="hljs-comment">// SchemeGroupVersion is group version used to register these objects.</span>
<span class="hljs-keyword">var</span> SchemeGroupVersion = GroupVersion
  
<span class="hljs-comment">// Resource takes an unqualified resource and returns a Group qualified GroupResource</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Resource</span><span class="hljs-params">(resource <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">schema</span>.<span class="hljs-title">GroupResource</span></span> {
    <span class="hljs-keyword">return</span> SchemeGroupVersion.WithResource(resource).GroupResource()
}</code></pre></div>
<ul>
<li>修改<code>api/v1/{crd}_types.go</code>文件，添加注释<code> // +genclient</code></li>
</ul>
<div><pre class="hljs"><code>[root@kubebuilder example]# cat api/v1/guestbook_types.<span class="hljs-keyword">go</span>
...
<span class="hljs-comment">// +genclient</span>
<span class="hljs-comment">//+kubebuilder:object:root=true</span>

<span class="hljs-comment">// GuestbookList contains a list of Guestbook</span>
<span class="hljs-keyword">type</span> GuestbookList <span class="hljs-keyword">struct</span> {
...</code></pre></div>
<h5 id="准备脚本">准备脚本</h5>
<p>在项目 <code>hack</code> 目录下准备以下文件：</p>
<ul>
<li><code>hack/tools.go</code></li>
</ul>
<div><pre class="hljs"><code>[root@kubebuilder example]# cat hack/tools.<span class="hljs-keyword">go</span>
<span class="hljs-comment">// +build tools</span>
  
<span class="hljs-keyword">package</span> tools
  
<span class="hljs-keyword">import</span> _ <span class="hljs-string">"k8s.io/code-generator"</span></code></pre></div>
<ul>
<li><code>hack/update-codegen.sh</code><br />
<code>MODULE</code> 和 <code>go.mod</code> 保持一致<br />
<code>API_PKG=api</code>，和 <code>api</code> 目录保持一致<br />
<code>OUTPUT_PKG=generated/example</code>，与生成Resource时指定的group保持一致<br />
<code>GROUP=example</code>， 和生成Resource时指定的group 保持一致<br />
<code>VERSION=v1</code>， 和生成Resource时指定的version保持一致</li>
</ul>
<div><pre class="hljs"><code>[root@kubebuilder example]<span class="hljs-comment"># cat ./hack/update-codegen.sh</span>
<span class="hljs-comment">#!/usr/bin/env bash</span>
<span class="hljs-comment">#表示有报错即退出 跟set -e含义一样</span>
<span class="hljs-built_in">set</span> -o errexit
<span class="hljs-comment">#执行脚本的时候，如果遇到不存在的变量，Bash 默认忽略它 ,跟 set -u含义一样</span>
<span class="hljs-built_in">set</span> -o nounset
<span class="hljs-comment"># 只要一个子命令失败，整个管道命令就失败，脚本就会终止执行 </span>
<span class="hljs-built_in">set</span> -o pipefail
  
<span class="hljs-comment">#kubebuilder项目的MODULE</span>
MODULE=my.domain/example
  
<span class="hljs-comment">#api包</span>
APIS_PKG=api
  
<span class="hljs-comment">#代码生出输出，生成Resource时指定的group一样</span>
OUTPUT_PKG=generated/example
  
<span class="hljs-comment"># group-version such as cronjob:v1</span>
GROUP=example
VERSION=v1
GROUP_VERSION=<span class="hljs-variable">$GROUP</span>:<span class="hljs-variable">$VERSION</span>
  
SCRIPT_ROOT=$(dirname <span class="hljs-string">"<span class="hljs-variable">${BASH_SOURCE[0]}</span>"</span>)/..
CODEGEN_PKG=<span class="hljs-variable">${CODEGEN_PKG:-$(cd "<span class="hljs-variable">${SCRIPT_ROOT}</span>"; ls -d -1 ./vendor/k8s.io/code-generator 2&gt;/dev/null || echo ../code-generator)}</span>
  
<span class="hljs-comment"># kubebuilder2.3.2版本生成的api目录结构code-generator无法直接使用</span>
rm -rf <span class="hljs-string">"<span class="hljs-variable">${APIS_PKG}</span>/<span class="hljs-variable">${GROUP}</span>"</span> &amp;&amp; mkdir -p <span class="hljs-string">"<span class="hljs-variable">${APIS_PKG}</span>/<span class="hljs-variable">${GROUP}</span>"</span> &amp;&amp; cp -r <span class="hljs-string">"<span class="hljs-variable">${APIS_PKG}</span>/<span class="hljs-variable">${VERSION}</span>/"</span> <span class="hljs-string">"<span class="hljs-variable">${APIS_PKG}</span>/<span class="hljs-variable">${GROUP}</span>"</span>
  
<span class="hljs-comment"># generate the code with:</span>
<span class="hljs-comment"># --output-base    because this script should also be able to run inside the vendor dir of</span>
<span class="hljs-comment">#                  k8s.io/kubernetes. The output-base is needed for the generators to output into the vendor dir</span>
<span class="hljs-comment">#                  instead of the $GOPATH directly. For normal projects this can be dropped.</span>
<span class="hljs-comment">#client,informer,lister(注意: code-generator 生成的deepcopy不适配 kubebuilder 所生成的api)</span>
bash <span class="hljs-string">"<span class="hljs-variable">${CODEGEN_PKG}</span>"</span>/generate-groups.sh <span class="hljs-string">"client,informer,lister"</span> \
  <span class="hljs-variable">${MODULE}</span>/<span class="hljs-variable">${OUTPUT_PKG}</span> <span class="hljs-variable">${MODULE}</span>/<span class="hljs-variable">${APIS_PKG}</span> \
  <span class="hljs-variable">${GROUP_VERSION}</span> \
  --go-header-file <span class="hljs-string">"<span class="hljs-variable">${SCRIPT_ROOT}</span>"</span>/hack/boilerplate.go.txt
<span class="hljs-comment">#  --output-base "${SCRIPT_ROOT}"</span>
<span class="hljs-comment">#  --output-base "${SCRIPT_ROOT}/../../.."</span></code></pre></div>
<p><strong>注意</strong>:</p>
<ul>
<li>
<p>kubebuilder2.3.2版本生成的api目录结构code-generator无法直接使用，需要在sh脚本中进行处理。</p>
</li>
<li>
<p>修改脚本执行参数可以选择生成的代码，如：“client,informer,lister”。</p>
</li>
<li>
<p>无需再次生成deepcopy：code-generator 生成的deepcopy不适配 kubebuilder 所生成的api。</p>
</li>
<li>
<p><code>Makefile</code>添加生成命令</p>
</li>
</ul>
<div><pre class="hljs"><code>[root@kubebuilder example]<span class="hljs-comment"># chmod +x hack/update-codegen.sh </span>
[root@kubebuilder example]<span class="hljs-comment"># vim Makefile</span>
 71 update-codegen: <span class="hljs-comment">## generetor clientset informer inderx code</span>
 72         ./hack/update-codegen.sh</code></pre></div>
<h5 id="生成代码">生成代码</h5>
<p>项目根目录下执行<code>make update-codegen</code>即可，将生成如下代码结构：</p>
<div><pre class="hljs"><code>[root@kubebuilder example]<span class="hljs-comment"># tree  generated/</span>
generated/
└── example
    ├── clientset
    │   └── versioned
    │       ├── clientset.go
    │       ├── doc.go
    │       ├── fake
    │       │   ├── clientset_generated.go
    │       │   ├── doc.go
    │       │   └── register.go
    │       ├── scheme
    │       │   ├── doc.go
    │       │   └── register.go
    │       └── typed
    │           └── example
    │               └── v1
    │                   ├── doc.go
    │                   ├── example_client.go
    │                   ├── fake
    │                   │   ├── doc.go
    │                   │   ├── fake_example_client.go
    │                   │   └── fake_guestbook.go
    │                   ├── generated_expansion.go
    │                   └── guestbook.go
    ├── informers
    │   └── externalversions
    │       ├── example
    │       │   ├── interface.go
    │       │   └── v1
    │       │       ├── guestbook.go
    │       │       └── interface.go
    │       ├── factory.go
    │       ├── generic.go
    │       └── internalinterfaces
    │           └── factory_interfaces.go
    └── listers
        └── example
            └── v1
                ├── expansion_generated.go
                └── guestbook.go</code></pre></div>
<p>之后便可以通过clientset等包对自定义资源对象进行操作。</p>
<p><strong>注意事项：</strong><br />
<code>kubebuilder2.3.2</code>版本生成的api目录结构为 <code>api/v1</code>，而<code>code-generator</code>需要的api目录结构为 <code>api/example/v1</code>，相比较增加了<code>group</code>这一层。</p>
<ul>
<li><code>hack/update-codegen.sh</code> 脚本会自动根据kubebuilder的api生成code-generator所需目录结构。</li>
<li><code>code-generator</code> 生成的deepcopy不适配 kubebuilder 所生成的api。</li>
<li><code>code-generator</code> 生成代码后再次使用make操作时可能由于生成的代码影响命令正常执行，例如： <code>make manifests</code> 在生成CRD模版时，需先删除api以及generated目录中为code-generator生成的代码，才可正常生成CRD模版。</li>
<li>使用时kubebuilder正常使用 <code>api/v1</code> 中的types，而code-generator生成的clientset等则需要使用 <code>api/example/v1</code> 中的types。</li>
</ul>
]]></content:encoded>
        </item>
    </channel>
</rss>