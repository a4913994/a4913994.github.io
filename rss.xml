<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title></title>
        <link>undefined</link>
        <description>undefined</description>
        <lastBuildDate>Tue, 31 Jan 2023 16:37:09 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>Joplin Pages Publisher</generator>
        <item>
            <title><![CDATA[6. 文档系统 ---- 关于结构]]></title>
            <guid>02ed0149cb0a4c5b865364a20e2fd29d</guid>
            <pubDate>Tue, 31 Jan 2023 16:31:31 GMT</pubDate>
            <content:encoded><![CDATA[<h2 id="为什么这不明显">为什么这不明显？</h2>
<p>这种结构很清晰，也很有效，但它不那么明显是有原因的，那就是文档的每个象限的特征与方案中相邻象限的特征重叠的方式。</p>
<p><img src="/_resources/c0b13b70118040068123301e5f90ba40.png" /></p>
<p>每个象限都与其相邻的两个象限相似：</p>
<ul>
<li>教程和操作指南都与描述实际步骤有关</li>
<li>操作指南和技术参考都是我们在工作、编码时所需要的</li>
<li>参考指南和解释都涉及理论知识</li>
<li>教程和解释在我们学习时最有用，而不是实际工作</li>
</ul>
<h2 id="崩溃的趋势">崩溃的趋势</h2>
<p>鉴于这些重叠，不同类型的文档相互混淆和混合也就不足为奇了。事实上，这些不同类型的文档相互之间有一种自然的引力，而且很难抗拒。它的作用是破坏结构，这就是为什么这么多文档看起来像这样：</p>
<p><img src="/_resources/4beabf32276340ae978dd4ea8e7f4daf.png" /></p>
<h2 id="系统的采用">系统的采用</h2>
<p>虽然很少能找到充分使用它的清晰示例，但大量文档以不同的方式识别这四个功能中的每一个。</p>
<p>该计划在重大项目中的良好示例包括：</p>
<ul>
<li><a title="https://docs.divio.com/" href="https://docs.divio.com/">Divio Developer Handbook</a></li>
<li><a title="https://docs.djangoproject.com/en/3.0/#how-the-documentation-is-organized" href="https://docs.djangoproject.com/en/3.0/#how-the-documentation-is-organized">Django’s documentation</a></li>
<li><a title="http://docs.django-cms.org/" href="http://docs.django-cms.org/">django CMS’s documentation</a></li>
</ul>
<p>即使在非常少的文档中也可以使用该系统，例如 <a title="https://docs.coreport.ch/" href="https://docs.coreport.ch/">CoReport（一个开源 COVID-19 报告项目）</a>。在这里，应用该系统为未来的文档创建了一个框架，有助于确保新材料符合要求。</p>
<p>有时文档非常少，以至于并非所有象限都准备好呈现，例如 <a title="https://github.com/flavours/getting-started-with-spring-boot/blob/master/README.md" href="https://github.com/flavours/getting-started-with-spring-boot/blob/master/README.md">Java 和 Spring-boot 入门</a>，它只包括教程、操作方法和参考资料。</p>
<p>尽管在每种情况下，无论多么微小甚至不完整，系统都受到尊重，各部分及其目的之间的明确区分将立即使作者和用户受益，并有助于指导材料在未来发展时的扩展。</p>
<h2 id="关于分析及其应用">关于分析及其应用</h2>
<p>本文中对文档的分析基于多年编写和维护文档的经验，并花费了大量时间考虑如何改进它。</p>
<p>它还基于来自各种学科的合理原则。例如，它的教程概念具有教学基础；它设定了一位导师和一位学习者，并将使用软件视为一门手艺，其中对一般原则的抽象理解来自于处理细节的具体步骤。</p>
<p>该系统定期在会谈和互动研讨会上展示。该分析已应用于众多项目，包括大型内部文档集，并在非常广泛的技术主题中多次获得可用性和可维护性的好处。</p>
<h2 id="参考">参考</h2>
<p><a title="https://documentation.divio.com/adoption/" href="https://documentation.divio.com/adoption/">https://documentation.divio.com/adoption/</a></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[5. 文档系统 ---- 说明]]></title>
            <guid>d8e8b58f4e1f419cbbae1c5494b4a542</guid>
            <pubDate>Tue, 31 Jan 2023 16:28:41 GMT</pubDate>
            <content:encoded><![CDATA[<blockquote>
<p>解释或讨论，澄清和阐明特定主题。它们扩大了文档对某个主题的覆盖范围。</p>
</blockquote>
<p>他们以理解为导向。</p>
<p>解释同样可以描述为讨论；它们本质上是散漫的。它们是文档放松和从软件退后一步的机会，从更广阔的视野，从更高的层次甚至从不同的角度阐明它。您可能会想象一个讨论文档是在闲暇时阅读的，而不是阅读代码。</p>
<p>这部分文档很少明确创建，相反，解释片段散布在其他部分中。有时，该部分存在，但有一个名称，例如背景或其他注释或关键主题 - 这些名称并不总是有用的。</p>
<p>创建讨论并不像看起来那么容易 - 当您有某人问题的起点时，可以直接解释的事情在您有空白页并且必须写下一些相关内容时就不那么容易了。</p>
<p>主题不是由您想要完成的特定任务定义的，例如操作指南，或者您希望用户学习的内容，例如教程。它不是由一台机器定义的，比如参考资料。它是由您认为一次尝试涵盖的合理区域来定义的，因此讨论主题的划分有时可能有点武断。</p>
<h2 id="烹饪类比">烹饪类比</h2>
<p>想想一部在历史、科学和技术背景下讨论食物和烹饪的作品。这是关于烹饪和厨房的。</p>
<p>它不教授，它不是食谱的集合，它不只是描述。</p>
<p>相反，它从多个角度分析、考虑事物。它可能会解释为什么我们现在按照自己的方式做事，甚至可以描述糟糕的做事方式，或模糊的替代方案。</p>
<p>它加深了我们的知识并使它更丰富，即使它不是我们可以在任何实际意义上实际应用的知识——但它不需要是，为了有价值。</p>
<p>当我们想在更高层次上思考烹饪，并想更多地了解这个主题时，我们可能会在闲暇时阅读它，远离厨房本身。</p>
<h2 id="如何写出好的解释">如何写出好的解释</h2>
<h3 id="提供上下文">提供上下文</h3>
<p>解释是背景和上下文的地方——例如，Web 表单以及它们在 Django 中的处理方式，或在 Django CMS 中的搜索。</p>
<p>他们还可以解释为什么会这样——设计决策、历史原因、技术限制。</p>
<h3 id="讨论备选方案和意见">讨论备选方案和意见</h3>
<p>解释可以考虑替代方案，或针对同一问题的多种不同方法。例如，在一篇关于 Django 部署的文章中，考虑和评估不同的 Web 服务器选项是合适的，</p>
<p>讨论甚至可以考虑和权衡相反的意见——例如，测试模块是否应该在包目录中。</p>
<h3 id="不指导不提供技术参考">不指导，不提供技术参考</h3>
<p>解释应该做文档其他部分做不到的事情。这不是指导用户如何做某事的解释的地方。也不应提供技术说明。文档的这些功能已经在其他部分中得到了处理。</p>
<h2 id="divio-文档中的示例">Divio 文档中的示例</h2>
<p>看看我们的<a title="https://docs.divio.com/en/latest/reference/divio-cli" href="https://docs.divio.com/en/latest/reference/divio-cli">解释部分</a>（标题为“背景” - 只要目的明确，名称并不重要）。</p>
<p>这些文章没有教任何东西。他们不会告诉用户该做什么。它们不是参考指南。他们只是讨论特定的话题。用户不需要了解（例如）缓存或 CDN 或我们如何管理环境变量来使用平台或完成任何特定任务，但时间很可能会到来，届时某人的经验和平台使用将成为通过对这些事情有更清晰、更好、更深入的理解而得到改善。</p>
<p>这些文章提供了更大的图景和背景。用户是人；也许他们不需要严格地知道我们为什么以某种方式做某事，但知道这很可能会给他们带来一种满足感和舒适感，使他们成为更快乐的产品用户。</p>
<p><img src="/_resources/c72ddba88f2145d49101e1ecc623e823.png" /></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[4. 文档系统 ---- 参考指南]]></title>
            <guid>d8969ada7b974ff5b02a21aa203533c6</guid>
            <pubDate>Tue, 31 Jan 2023 16:24:57 GMT</pubDate>
            <content:encoded><![CDATA[<blockquote>
<p>参考指南是对机器及其操作方法的技术说明。</p>
</blockquote>
<p>参考指南只有一项工作：描述。它们是由代码决定的，因为最终这就是它们描述的内容：关键类、函数、API，因此它们应该列出函数、字段、属性和方法等内容，并说明如何使用它们。</p>
<p>参考资料以信息为导向。</p>
<p>无论如何，技术参考可以包含示例来说明用法，但不应试图解释基本概念或如何实现常见任务。</p>
<p>参考资料应该简明扼要。</p>
<p>请注意，描述确实包括如何使用机器的基本描述 - 例如，如何实例化特定类或调用特定方法，或将某些内容传递给函数时必须采取的预防措施。然而，这只是其技术参考功能的一部分，强调不要与操作指南混淆 - 描述软件的正确使用（技术参考）与展示如何使用它来实现特定目的不同（操作文档）。</p>
<p>对于一些开发人员来说，参考指南是他们唯一能想到的文档。他们已经了解他们的软件，他们知道如何使用它。他们所能想到的其他人可能需要的只是有关它的技术信息。</p>
<p>参考资料往往写得很好。它甚至可以 - 在某种程度上 - 自动生成，但这本身是不够的。</p>
<h2 id="烹饪类比">烹饪类比</h2>
<p>考虑一篇关于某种成分的百科全书文章，比如生姜。</p>
<p>当您在参考书中查找生姜时，您需要的是有关该成分的信息——描述其来源、行为、化学成分以及烹饪方法的信息。</p>
<p>您希望无论查找什么成分，信息都会以类似的方式呈现。您希望了解基本事实，例如生姜是姜黄和豆蔻家族的一员。</p>
<p>这也是您希望收到有关潜在问题的警报的地方，例如：已知生姜会引起某些人的胃灼热或：生姜可能会干扰抗凝剂的作用，例如华法林或阿司匹林。</p>
<h2 id="如何写出好的参考指南">如何写出好的参考指南</h2>
<h3 id="围绕代码构建文档">围绕代码构建文档</h3>
<p>为参考文档提供与代码库相同的结构，以便用户可以同时浏览代码和文档。这也将帮助维护者查看参考文档丢失或需要更新的地方。</p>
<h3 id="始终如一">始终如一</h3>
<p>在参考指南中，结构、语气、格式都必须保持一致——就像百科全书或字典一样。</p>
<h3 id="除了描述什么都不做">除了描述什么都不做</h3>
<p>技术参考的唯一工作就是描述，尽可能清楚和完整。其他任何事情（解释、讨论、指导、推测、意见）不仅会分散注意力，而且会使它更难使用和维护。在适当的时候提供示例来说明描述。</p>
<p>避免使用参考资料来指导如何实现事物的诱惑，超出使用软件的基本范围，并且不允许对概念进行解释或对主题进行讨论。取而代之的是，链接到操作指南、解释和介绍性教程。</p>
<h3 id="准确">准确</h3>
<p>这些描述必须准确并保持最新。机器与您的描述之间的任何差异都将不可避免地导致用户误入歧途。</p>
<h3 id="divio-文档中的示例">Divio 文档中的示例</h3>
<p>查看我们的<a title="https://docs.divio.com/en/latest/reference/divio-cli" href="https://docs.divio.com/en/latest/reference/divio-cli">技术参考</a>部分中的示例。</p>
<p>这是一个典型的参考指南（在本例中，针对我们的 Divio CLI）。</p>
<p>本文所做的就是描述，以完整和准确的形式列出该工具的功能、命令和选项。</p>
<p>这不是一本友好或引人入胜的读物，但它的目的是尽可能快速和无干扰地查找有关功能的信息。</p>
<p><img src="/_resources/39dbb70411b14b989589918e6e9cc290.png" /></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[3. 文档系统 ---- 操作指南]]></title>
            <guid>3bd5b0fd198c4934bc32b1b464f28a33</guid>
            <pubDate>Tue, 31 Jan 2023 16:20:44 GMT</pubDate>
            <content:encoded><![CDATA[<p>操作指南引导读者完成解决现实世界问题所需的步骤。</p>
<p>它们是实现特定目标的秘诀和指导——例如：如何创建网络表单；如何绘制三维数据集；如何启用 LDAP 身份验证。</p>
<p>他们完全以目标为导向。</p>
<p>操作指南与教程完全不同，切勿与它们混淆：</p>
<ul>
<li>教程是您决定初学者需要了解的内容。</li>
<li>操作指南是对只有具有一定经验的用户才能提出的问题的答案。</li>
</ul>
<p>在操作指南中，您可以假设一些知识和理解。您可以假设用户已经知道如何做基本的事情和使用基本的工具。</p>
<p>与教程不同，软件文档中的操作指南往往做得相当好。它们也很有趣且易于编写。</p>
<h2 id="烹饪类比">烹饪类比</h2>
<p><img src="/_resources/64b5ff532d70498891941154b75179a0.png" /></p>
<p>想想一个食谱，准备吃的东西。</p>
<p>食谱有一个明确、明确的结局。它解决了一个特定的问题。它向某人展示 - 可以假设他们已经具备一些基本知识 - 如何取得成就。</p>
<p>不能指望以前从未做过饭的人成功地遵循食谱，因此食谱不能代替烹饪课。同时，阅读食谱的人会很生气地发现它试图教授他们已经知道的基础知识，或者包含与成分无关的讨论。</p>
<h2 id="如何编写好的操作指南">如何编写好的操作指南</h2>
<h3 id="提供一系列步骤">提供一系列步骤</h3>
<p>操作指南必须包含一系列步骤，需要按顺序执行（就像教程一样）。您不必从头开始，只需从一个合理的起点开始。操作指南应该是可靠的，但它们不需要像教程那样具有铁一般的可重复性。</p>
<h3 id="注重结果">注重结果</h3>
<p>操作指南必须侧重于实现实际目标。其他任何事情都会让人分心。与教程一样，详细的解释在这里是不合适的。</p>
<h3 id="解决特定问题">解决特定问题</h3>
<p>操作指南必须解决特定问题：我如何……？</p>
<p>这是操作指南不同于教程的一种方式：当涉及到操作指南时，可以假设读者知道他们应该实现什么，但还不知道如何实现 - 而在教程中，您有责任决定读者需要了解哪些内容。</p>
<h3 id="不解释概念">不解释概念</h3>
<p>操作指南不应解释任何事情。这不是进行此类讨论的场所；他们只会妨碍行动。如果解释很重要，请链接到它们。</p>
<h3 id="允许一些灵活性">允许一些灵活性</h3>
<p>操作指南应该允许使用略有不同的方法来做同样的事情。它只需要足够的灵活性，以便用户可以看到它将如何应用于与您描述的示例略有不同的示例，或者了解如何使其适应与您假设的系统或配置略有不同的系统或配置。不要太具体以至于指南除了你心中的确切目的之外没有任何用处。</p>
<h3 id="把事情留在外面">把事情留在外面</h3>
<p>实用性比完整性更有价值。教程需要是完整的、端到端的指南；操作指南没有。他们可以在您认为合适的地方开始和结束。他们也不需要提及该提及的所有内容，只是因为它与主题相关。臃肿的操作指南无法帮助用户快速找到他们的解决方案。</p>
<h3 id="名字很好引导">名字很好引导</h3>
<p>操作文档的标题应该告诉用户它到底做了什么。 How to create a class-based view 这个标题不错。创建基于类的视图或更糟的是，基于类的视图不是。</p>
<h3 id="divio-文档中的示例">Divio 文档中的示例</h3>
<p>看看我们的<a title="https://docs.divio.com/en/latest/how-to/" href="https://docs.divio.com/en/latest/how-to/">操作指南</a>。</p>
<p>其中每一个都是对一个问题的回答：我如何……？每个标题前面都可以清楚地加上“How to”字样。每一个都是一个秘诀，引导您完成完成特定任务所需的步骤。</p>
<p>尽管教程和操作指南都是为用户服务的，但是教程是由知道用户需要知道什么的作者主导的，而操作指南是由提出问题的用户引导的。</p>
<p><img src="/_resources/740543613b8d409e9e9293a2c371cb6a.png" /></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[2. 文档系统 ---- 教程]]></title>
            <guid>0b3fe84173924c459ed57b3b36078e88</guid>
            <pubDate>Tue, 31 Jan 2023 16:10:58 GMT</pubDate>
            <content:encoded><![CDATA[<p>教程是指导读者通过一系列步骤完成某种项目的课程。它们是您的项目所需要的，以便向初学者展示他们可以用它取得一些成就。</p>
<p>他们完全以学习为导向，具体来说，他们以学习如何做而不是学习那个为导向。</p>
<p>您是老师，您要对学生的行为负责。在您的指导下，学生将执行一系列操作以达到某个目的。</p>
<p>结局和行动取决于你，但决定它们应该是什么可能是一项艰苦的工作。结束必须是有意义的，但对于一个完全的初学者来说也是可以实现的。</p>
<p>重要的是完成教程后，学习者能够理解文档的其余部分以及软件本身。</p>
<p>大多数软件项目都有非常糟糕的——或者根本不存在的——教程。教程将把你的学习者变成用户。糟糕或缺失的教程将阻止您的项目获得新用户。</p>
<p>在描述四种文档的部分中，这是迄今为止最长的 - 这是因为教程最容易被误解，也最难做好。最好的教学方式是有老师在场，与学生互动。这几乎不可能，我们的书面教程充其量只是一个远非完美的替代品。这就是特别关注它们的更多理由。</p>
<p>教程需要对初学者有用，易于理解，有意义且极其强大，并保持最新。您可能会发现编写和维护教程所占用的时间和精力与其他三个部分加在一起所占用的时间和精力一样多。</p>
<h2 id="烹饪类比">烹饪类比</h2>
<p>考虑一个教孩子做饭的类比。</p>
<p>你教孩子做什么并不重要。重要的是孩子觉得它很有趣，并获得信心，并想再做一次。</p>
<p>通过孩子所做的事情，他将学习有关烹饪的重要知识。它将了解在厨房、使用器具和处理食物时的感觉。</p>
<p>这是因为使用软件就像烹饪一样是一门手艺。它是知识——但它是实践知识，而不是理论知识。</p>
<p>当我们学习一门新手艺或技能时，我们总是边做边学。</p>
<h2 id="如何写出好的教程">如何写出好的教程</h2>
<h3 id="允许用户边做边学">允许用户边做边学</h3>
<p><strong>一开始，我们只能通过实践来学习任何东西</strong>——这就是我们学习说话或走路的方式。</p>
<p>在您的软件教程中，您的学习者需要做一些事情。他们在按照您的教程进行操作时所做的不同事情需要涵盖广泛的工具和操作，从一开始最简单的工具和更复杂的工具和操作。</p>
<h3 id="让用户开始">让用户开始</h3>
<p>如果您的初学者的第一步是手持婴儿学步，那是完全可以接受的。如果您让初学者做的事情不是有经验的人会做的，或者即使这不是“正确”的方式，这也是完全可以接受的——初学者教程与最佳实践手册不同。</p>
<p>教程的目的是让您的学习者开始他们的旅程，而不是让他们到达最终目的地。</p>
<h3 id="确保您的教程有效">确保您的教程有效</h3>
<p>作为导师，你的工作之一是激发初学者的信心：对软件、对教程、对导师，当然还有对他们自己实现要求的能力的信心。</p>
<p>有很多因素促成了这一点。友好的语气会有所帮助，语言的一致使用以及材料的逻辑进展也会有所帮助。但最重要的一点是，你要求初学者做的事情必须奏效。学习者需要看到您要求他们采取的行动会产生您所说的效果。</p>
<p>如果学习者的操作产生错误或意外结果，那么您的教程就失败了——即使这不是您的错。当你的学生和你在一起时，你可以拯救他们；如果他们自己阅读你的文档，你就不能——所以你必须提前防止这种情况发生。毫无疑问，这说起来容易做起来难。</p>
<h3 id="确保用户立即看到结果">确保用户立即看到结果</h3>
<p>学习者所做的每一件事都应该完成一些可以理解的事情，无论多么小。如果您的学生在看到结果之前必须在两页纸上做一些奇怪且难以理解的事情，那就太长了。每个动作的效果都应该尽快可见和明显，并且与动作的联系应该清楚。</p>
<p>教程的每个部分或整个教程的结论必须是有意义的成就。</p>
<h3 id="让您的教程可重复">让您的教程可重复</h3>
<p>您的教程必须可靠地可重复。这并不容易实现：人们将使用不同的操作系统、经验水平和工具来实现它。更重要的是，他们使用的任何软件或资源很可能同时发生变化。</p>
<p>本教程每次都必须适用于所有人。</p>
<p>不幸的是，教程需要定期和详细的测试以确保它们仍然有效。</p>
<h3 id="关注具体步骤而不是抽象概念">关注具体步骤，而不是抽象概念</h3>
<p>教程需要具体，围绕具体的、特定的行动和结果构建。</p>
<p>引入抽象的诱惑是巨大的；毕竟，大多数计算都是通过这种方式获得其能力的。但是所有的学习都是从具体和具体到一般和抽象的，要求学习者在他们甚至有机会掌握具体之前欣赏抽象层次是糟糕的教学。</p>
<h3 id="提供最少的必要解释">提供最少的必要解释</h3>
<p>不要解释学习者为了完成教程不需要知道的任何事情。扩展讨论很重要——只是不在教程中。在教程中，它是一种障碍和干扰。只有最低限度是合适的。相反，链接到文档中其他地方的解释。</p>
<h3 id="只关注用户需要采取的步骤">只关注用户需要采取的步骤</h3>
<p>您的教程需要专注于手头的任务。也许您要介绍的命令还有许多其他选项，或者可能有不同的方式来访问某个 API。没关系：现在，您的学习者不需要了解这些就可以取得进步。</p>
<h3 id="divio-文档中的示例">Divio 文档中的示例</h3>
<p>看看我们的<a title="https://docs.divio.com/en/latest/introduction/" href="https://docs.divio.com/en/latest/introduction/">教程</a>。</p>
<p>特别是，请参阅 Django 教程。本教程做出的承诺是：如果您具备学习本教程所需的基本知识，并且按照它的指示进行操作，您最终将得到一个可用的 Django Web 应用程序，其中包含 Postgres 数据库、S3 媒体存储等.为了作为教程工作，它必须履行该承诺。</p>
<p>请注意，它不会告诉您将学习什么，而只会告诉您将做什么。学习来自于那样做。本教程对您将要执行的操作以及执行顺序负全部责任。</p>
<p><img src="/_resources/89080eae08bf40d58fc1a1ef6f780f9d.png" /></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[1. 文档系统 ---- 介绍]]></title>
            <guid>a2e5226395d2413dbeec0ff7c99ddcfc</guid>
            <pubDate>Tue, 31 Jan 2023 15:52:16 GMT</pubDate>
            <content:encoded><![CDATA[<blockquote>
<p>为了编写好的软件文档，需要了解一个秘密：没有一种叫做文档的东西，而是有四种。</p>
</blockquote>
<p>它们是：<strong>教程</strong>、<strong>操作指南</strong>、<strong>技术参考</strong>和<strong>解释</strong>。它们代表四种不同的目的或功能，所以需要四种不同的创建方法。理解这一点的含义将有助于改进大多数文档。</p>
<p><img src="/_resources/edacd9c6002b4530bc8bb2197a145e51.png" /></p>
<center style="font-size:14px;color:#C0C0C0;text-decoration:underline;margin-top:-20px" class="jop-noMdConv">文档系统</center>
<p>此处概述的文档系统是一个简单、全面且几乎普遍适用的方案。它在广泛的领域和应用中得到了实践证明。</p>
<p>如果你能将这些原则付诸实践，它会让你的文档变得更好，你的项目、产品或团队会更成功。</p>
<h2 id="介绍">介绍</h2>
<h3 id="问题与解决方案">问题与解决方案</h3>
<h4 id="解决的问题">解决的问题</h4>
<p>你的产品有多好并不重要，因为如果它的文档不够好，人们就不会使用它。即使他们因为别无选择而不得不使用它，如果没有良好的文档，他们也不会有效地或按照您希望的方式使用它。</p>
<p>几乎每个人都明白这一点。几乎每个人都知道他们需要好的文档，而且大多数人都试图创建好的文档。大多数人都失败了。</p>
<p>通常，这不是因为他们不够努力。通常，这是因为他们没有以正确的方式做事。</p>
<p>这个系统是一种让你的文档变得更好的方法，不是通过更努力地工作，而是通过正确的方式来做。正确的方法是更简单的方法——更容易编写，也更容易维护。</p>
<h4 id="原理">原理</h4>
<p>这实际上不是秘密，当然也不应该是秘密：文档需要包括并围绕其四个不同功能构建：<strong>教程、操作指南、技术参考和解释</strong>。他们每个都需要一种独特的写作方式。使用软件的人在不同的时间、不同的情况下需要这四种不同的文档——所以软件通常都需要它们，而且它们都应该集成到您的文档中。</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">教程</th>
<th style="text-align:left">操作指南</th>
<th style="text-align:left">参考</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">面向</td>
<td style="text-align:left">学习</td>
<td style="text-align:left">一个目标</td>
<td style="text-align:left">信息</td>
<td style="text-align:left">理解</td>
</tr>
<tr>
<td style="text-align:left">必须</td>
<td style="text-align:left">让新人开始</td>
<td style="text-align:left">展示如何解决特定问题</td>
<td style="text-align:left">描述原理</td>
<td style="text-align:left">诠释</td>
</tr>
<tr>
<td style="text-align:left">它的形式</td>
<td style="text-align:left">一堂课</td>
<td style="text-align:left">一系列步骤</td>
<td style="text-align:left">尝试描述</td>
<td style="text-align:left">话语解释</td>
</tr>
<tr>
<td style="text-align:left">比如</td>
<td style="text-align:left">教小孩做饭</td>
<td style="text-align:left">烹饪书中的食谱</td>
<td style="text-align:left">参考百科文章</td>
<td style="text-align:left">一篇关于烹饪社会史的文章</td>
</tr>
</tbody>
</table>
<p>这种划分使作者和读者都清楚什么材料，什么样的材料，去哪里。它告诉作者如何写，写什么，写在哪里。它使作者免于浪费大量时间试图将他们想要传达的信息拼凑成有意义的形式，因为这些类型的文档中的每一种都只有一项工作。</p>
<p>事实上，如果不隐式或明确地识别此方案的象限，则很难维护良好的文档。每种类型的需求都与其他类型的需求不同，因此任何未能保持这种结构的文档尝试都会受到影响，因为它会同时被拉向不同的方向。</p>
<p>一旦您理解了结构，它就成为分析现有文档以及理解需要做什么来改进它的非常有用的工具。</p>
<p>在以下各节中，将详细介绍这四个部分中的每一个。</p>
<h4 id="使文档工作">使文档工作</h4>
<h4 id="对于作者">对于作者</h4>
<p>文档维护者必须处理的最令人头疼的问题之一是不清楚他们应该做什么。他们写了又改，但发现很难以令人满意的方式将它们组合在一起。</p>
<p>这种结构通过明确区分和分离解决了这些问题。他们制作的文档更易于编写和维护，更易于使用和使用。</p>
<p>该文档不会自行编写 - 但现在可以编写它，而不必为不合适、范围不明确或对应包含的内容或采用的样式产生疑问而苦苦挣扎。写什么、怎么写、放在哪里都变得清晰多了。</p>
<h4 id="对于读者">对于读者</h4>
<p>它更好地为用户服务，因为在他们与软件交互的周期的所有不同阶段，他们会找到合适的文档类型，满足当时的需求。</p>
<p>编写明确和明确地解决四个象限中每一个的文档有助于软件吸引和留住更多用户，他们将更有效地使用它——这是软件创建者最想要的事情之一。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Golang错误处理]]></title>
            <guid>6cd2eaf95f824f7d9f74885783dd6547</guid>
            <pubDate>Tue, 31 Jan 2023 14:53:47 GMT</pubDate>
            <content:encoded><![CDATA[<h2 id="最佳实践">最佳实践</h2>
<h3 id="panic">panic</h3>
<ol>
<li>在程序启动的时候，如果有强依赖的服务出现故障时<code>panic</code>退出</li>
<li>在程序启动的时候，如果发现有配置明显不符合要求， 可以<code>panic</code>退出（防御编程）</li>
<li>其他情况下只要不是不可恢复的程序错误，都不应该直接<code>panic</code>应该返回<code>error</code></li>
<li>在程序入口处，例如<code>gin</code>中间件需要使用<code>recover</code>预防<code>panic</code>程序退出</li>
<li>在程序中我们应该避免使用野生的<code>goroutine</code>
<ol>
<li>如果是在请求中需要执行异步任务，应该使用异步<code>worker</code>，消息通知的方式进行处理，避免请求量大时大量<code>goroutine</code>创建</li>
<li>如果需要使用<code>goroutine</code>时，应该使用统一的<code>Go</code>函数进行创建，这个函数中会进行<code>recover</code>，避免因为野生<code>goroutine panic</code>导致主进程退出</li>
</ol>
</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Go</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>()</span>)</span>{
    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>{
            <span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> {
                log.Printf(<span class="hljs-string">"panic: %+v"</span>, err)
            }
        }()

        f()
    }()
}</code></pre></div>
<h3 id="error">error</h3>
<ol>
<li>我们在应用程序中使用<code>github.com/pkg/errors</code>处理应用错误，注意在公共库当中，<strong>一般不使用这个</strong></li>
<li><code>error</code>应该是函数的最后一个返回值，当<code>error</code>不为<code>nil</code>时，函数的其他返回值是不可用的状态，不应该对其他返回值做任何期待
<ol>
<li><code>func f() (io.Reader, *S1, error)</code>在这里，我们不知道<code>io.Reader</code>中是否有数据，可能有，也有可能有一部分</li>
</ol>
</li>
<li>错误处理的时候应该先判断错误， <code>if err != nil</code>出现错误及时返回，使代码是一条流畅的直线，避免过多的嵌套.</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-comment">// good case</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> {
    a, err := A()
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> err
    }

    <span class="hljs-comment">// ... 其他逻辑</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}

<span class="hljs-comment">// bad case</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> {
    a, err := A()
    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> {
    	<span class="hljs-comment">// 其他逻辑</span>
    }

    <span class="hljs-keyword">return</span> err
}</code></pre></div>
<ol start="4">
<li>在应用程序中出现错误时，使用<code>errors.New</code>或者<code>errors.Errorf</code>返回错误</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *usecese)</span> <span class="hljs-title">usecase1</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> {
    money := u.repo.getMoney(uid)
    <span class="hljs-keyword">if</span> money &lt; <span class="hljs-number">10</span> {
        errors.Errorf(<span class="hljs-string">"用户余额不足, uid: %d, money: %d"</span>, uid, money)
    }
    <span class="hljs-comment">// 其他逻辑</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}</code></pre></div>
<ol start="5">
<li>如果是调用应用程序的其他函数出现错误，请直接返回，如果需要携带信息，请使用 <code>errors.WithMessage</code></li>
</ol>
<div><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *usecese)</span> <span class="hljs-title">usecase2</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> {
    name, err := u.repo.getUserName(uid)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> errors.WithMessage(err, <span class="hljs-string">"其他附加信息"</span>)
    }

    <span class="hljs-comment">// 其他逻辑</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}</code></pre></div>
<ol start="5">
<li>如果是调用其他库（标准库、企业公共库、开源第三方库等）获取到错误时，请使用<code>errors.Wrap</code>添加堆栈信息
<ol>
<li>切记，不要每个地方都是用<code>errors.Wrap</code>只需要在错误第一次出现时进行 <code>errors.Wrap</code>即可</li>
<li>根据场景进行判断是否需要将其他库的原始错误吞掉，例如可以把 <code>repository</code>层的数据库相关错误吞掉，返回业务错误码，避免后续我们分割微服务或者更换 ORM  库时需要去修改上层代码</li>
<li>注意我们在基础库，被大量引入的第三方库编写时一般不使用 <code>errors.Wrap</code> 避免堆栈信息重复</li>
</ol>
</li>
<li><strong>禁止每个出错的地方都打日志</strong>，只需要在进程的最开始的地方使用 %+v  进行统一打印，例如 http/rpc 服务的中间件</li>
<li>错误判断使用<code>errors.Is</code>进行比较</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> {
    err := A()
    <span class="hljs-keyword">if</span> errors.Is(err, io.EOF){
    	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
    }

    <span class="hljs-comment">// 其他逻辑</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}</code></pre></div>
<ol start="8">
<li>错误类型判断，使用 errors.As  进行赋值</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> {
    err := A()

    <span class="hljs-keyword">var</span> errA errorA
    <span class="hljs-keyword">if</span> errors.As(err, &amp;errA){
    	<span class="hljs-comment">// ...</span>
    }

    <span class="hljs-comment">// 其他逻辑</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}</code></pre></div>
<ol start="9">
<li>如何判定错误的信息是否足够，想一想当你的代码出现问题需要排查的时候你的错误信息是否可以帮助你快速的定位问题，例如我们在请求中一般会输出参数信息，用于辅助判断错误</li>
<li>对于业务错误，推荐在一个统一的地方创建一个错误字典，错误字典里面应该包含错误的 code，并且在日志中作为独立字段打印，方便做业务告警的判断，错误必须有清晰的错误文档</li>
<li>不需要返回，被忽略的错误必须输出日志信息</li>
<li>同一个地方不停的报错，最好不要不停输出错误日志，这样可能会导致被大量的错误日志信息淹没，无法排查问题，比较好的做法是打印一次错误详情，然后打印出错误出现的次数</li>
<li>对同一个类型的错误，采用相同的模式，例如参数错误，不要有的返回 404 有的返回 200</li>
<li><strong>处理错误的时候，需要处理已分配的资源</strong>，使用<code>defer</code>进行清理，例如文件句柄</li>
</ol>
<h2 id="panic-or-error">panic or error?</h2>
<ol>
<li>在 Go 中<code>panic</code>会导致程序直接退出，是一个致命的错误，如果使用<code>panic  recover</code>进行处理的话，会存在很多问题
<ol>
<li>性能问题，频繁<code>panic recover</code>性能不好</li>
<li>容易导致程序异常退出，只要有一个地方没有处理到就会导致程序进程整个退出</li>
<li>不可控，一旦<code>panic</code>就将处理逻辑移交给了外部，我们并不能预设外部包一定会进行处理</li>
</ol>
</li>
<li>什么时候使用<code>panic</code>呢？
<ol>
<li>对于真正意外的情况，那些表示不可恢复的程序错误，例如索引越界、不可恢复的环境问题、栈溢出，我们才使用 panic</li>
</ol>
</li>
<li>使用 error 处理有哪些好处？
<ol>
<li>简单</li>
<li>考虑失败，而不是成功(Plan for failure, not success)</li>
<li>没有隐藏的控制流</li>
<li>完全交给你来控制 error</li>
<li>Error are values</li>
</ol>
</li>
</ol>
<h2 id="为什么标准库中-errorsnew-会返回一个指针">为什么标准库中 errors.New 会返回一个指针</h2>
<p>翻看标准库的源代码我们可以发现，<code> errors</code>  库中的 <code>errorString</code>  结构体实现了<code> error</code>  接口，为什么在 <code>New</code>  一个 <code>error</code> 的时候会返回一个结构体的指针呢？</p>
<div><pre class="hljs"><code><span class="hljs-comment">// New returns an error that formats as the given text.</span>
<span class="hljs-comment">// Each call to New returns a distinct error value even if the text is identical.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(text <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> {
    <span class="hljs-keyword">return</span> &amp;errorString{text}
}

<span class="hljs-comment">// errorString is a trivial implementation of error.</span>
<span class="hljs-keyword">type</span> errorString <span class="hljs-keyword">struct</span> {
    s <span class="hljs-keyword">string</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *errorString)</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> {
    <span class="hljs-keyword">return</span> e.s
}</code></pre></div>
<p>我们先来看一个例子，我们同样创建了 <code>errorString</code> 的结构体，我们自定义的和标准库中的唯一不同就是，自建的这个返回的是值，而不是指针。</p>
<p>在<code>main</code>函数的对比中我们就可以发现，我们自定义的<code>errorString</code>在对比的时候只要对应的字符串相同就会返回 <code>true</code>，但是标准库的包不会。</p>
<p>这是因为，在对比两个 <code>struct</code> 是否相同的时候，会去对比，这两个 <code>struct</code> 里面的各个字段是否是相同的，如果相同就返回 <code>true</code>，但是对比指针的时候会去判断两个指针的地址是否一致。</p>
<p><strong>如果字符串相等就返回 true 会导致什么问题呢？</strong></p>
<p>如果我有两个包，定义了两个错误，他们其实是两个相同的字符串，在其他库调用对比的时候，可能会由于不同的书写顺序，走进不同的分支导致一些奇奇怪怪的错误</p>
<div><pre class="hljs"><code><span class="hljs-keyword">type</span> errorString <span class="hljs-keyword">struct</span> {
    text <span class="hljs-keyword">string</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e errorString)</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> {
    <span class="hljs-keyword">return</span> e.text
}

<span class="hljs-comment">// New 创建一个自定义错误</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> {
    <span class="hljs-keyword">return</span> errorString{text: s}
}

<span class="hljs-keyword">var</span> errorString1 = New(<span class="hljs-string">"test a"</span>)
<span class="hljs-keyword">var</span> err1 = errors.New(<span class="hljs-string">"test b"</span>)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">if</span> errorString1 == New(<span class="hljs-string">"test a"</span>) {
        fmt.Println(<span class="hljs-string">"err string a"</span>) <span class="hljs-comment">// 会输出</span>
    }

    <span class="hljs-keyword">if</span> err1 == errors.New(<span class="hljs-string">"test b"</span>) {
        fmt.Println(<span class="hljs-string">"err b"</span>) <span class="hljs-comment">// 不会输出</span>
    }
}</code></pre></div>
<h2 id="error-type-错误定义与判断">error type: 错误定义与判断</h2>
<h3 id="sentinel-error">Sentinel Error</h3>
<p>哨兵错误，就是定义一些包级别的错误变量，然后在调用的时候外部包可以直接对比变量进行判定，在标准库当中大量的使用了这种方式</p>
<p>例如下方 <code>io</code>  库中定义的错误</p>
<div><pre class="hljs"><code><span class="hljs-comment">// EOF is the error returned by Read when no more input is available.</span>
<span class="hljs-comment">// Functions should return EOF only to signal a graceful end of input.</span>
<span class="hljs-comment">// If the EOF occurs unexpectedly in a structured data stream,</span>
<span class="hljs-comment">// the appropriate error is either ErrUnexpectedEOF or some other error</span>
<span class="hljs-comment">// giving more detail.</span>
<span class="hljs-keyword">var</span> EOF = errors.New(<span class="hljs-string">"EOF"</span>)

<span class="hljs-comment">// ErrUnexpectedEOF means that EOF was encountered in the</span>
<span class="hljs-comment">// middle of reading a fixed-size block or data structure.</span>
<span class="hljs-keyword">var</span> ErrUnexpectedEOF = errors.New(<span class="hljs-string">"unexpected EOF"</span>)

<span class="hljs-comment">// ErrNoProgress is returned by some clients of an io.Reader when</span>
<span class="hljs-comment">// many calls to Read have failed to return any data or error,</span>
<span class="hljs-comment">// usually the sign of a broken io.Reader implementation.</span>
<span class="hljs-keyword">var</span> ErrNoProgress = errors.New(<span class="hljs-string">"multiple Read calls return no data or error"</span>)
</code></pre></div>
<p>我们在外部判定的时候一般使用等值判定或者使用<code> errors.Is</code>  进行判断</p>
<div><pre class="hljs"><code><span class="hljs-keyword">if</span> err == io.EOF {
    <span class="hljs-comment">//...</span>
}

<span class="hljs-keyword">if</span> errors.Is(err, io.EOF){
    <span class="hljs-comment">//...</span>
}</code></pre></div>
<p>这种错误处理方式有一个问题是，将<code>error</code>当做包的<code>API</code>暴露给了第三方，这样会导致在做重构或者升级的时候很麻烦，并且这种方式包含的错误信息会十分的有限</p>
<h3 id="error-types">error types</h3>
<p>这个就类似我们前面定义的<code>errorString</code>一样实现了<code>error</code> 的接口，然后在外部是否类型断言来判断是否是这种错误类型</p>
<div><pre class="hljs"><code><span class="hljs-keyword">type</span> MyStruct <span class="hljs-keyword">struct</span> {
    s <span class="hljs-keyword">string</span>
    name <span class="hljs-keyword">string</span>
    path <span class="hljs-keyword">string</span>
}



<span class="hljs-comment">// 使用的时候</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">switch</span> err.(<span class="hljs-keyword">type</span>) {
        <span class="hljs-keyword">case</span> *MyStruct:
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">case</span> others:
        <span class="hljs-comment">// ...</span>
    }
}</code></pre></div>
<p>这种方式相对于哨兵来说，可以包含更加丰富的信息，但是同样也将错误的类型暴露给了外部，例如标准库中的<code>os.PathError</code></p>
<h3 id="opaque-errors">Opaque errors</h3>
<p>不透明的错误处理，这种方式最大的特点就是只返回错误，暴露错误判定接口，不返回类型，这样可以减少 API 的暴露，后续的处理会比较灵活，这个一般用在公共库会比较好</p>
<div><pre class="hljs"><code><span class="hljs-keyword">type</span> temporary <span class="hljs-keyword">interface</span> {
    Temporary() <span class="hljs-keyword">bool</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsTemporary</span><span class="hljs-params">(err error)</span> <span class="hljs-title">bool</span></span> {
    te, ok := err.(temporary)
    <span class="hljs-keyword">return</span> ok &amp;&amp; te.Temporary()
}</code></pre></div>
<h2 id="error-handle-错误处理优化">error handle: 错误处理优化</h2>
<p>在 go 中常常会存在大量的 <code>if err</code>代码，下面介绍两种常见的减少这种代码的方式</p>
<h3 id="bufioscan">bufio.scan</h3>
<p>对比下面两个函数的处理我们可以发现，<code>count2</code>  使用<code>sc.Scan</code>  之后一个 <code>if err</code> 的判断都没有，极大的简化了代码，这是因为在<code>sc.Scan</code>做了很多处理，像很多类似的，需要循环读取的都可以考虑像这样包装之后进行处理，这样外部包调用的时候就会非常简洁</p>
<div><pre class="hljs"><code><span class="hljs-comment">// 统计文件行数</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">count</span><span class="hljs-params">(r io.Reader)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span> {
    <span class="hljs-keyword">var</span> (
        br    = bufio.NewReader(r)
        lines <span class="hljs-keyword">int</span>
        err   error
    )

    <span class="hljs-keyword">for</span> {
        <span class="hljs-comment">// 读取到换行符就说明是一行</span>
        _, err = br.ReadString(<span class="hljs-string">'\n'</span>)
        lines++
        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
            <span class="hljs-keyword">break</span>
        }
    }

    <span class="hljs-comment">// 当错误是 EOF 的时候说明文件读取完毕了</span>
    <span class="hljs-keyword">if</span> err != io.EOF {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, err
    }

    <span class="hljs-keyword">return</span> lines, err
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">count2</span><span class="hljs-params">(r io.Reader)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span> {
    <span class="hljs-keyword">var</span> (
        sc    = bufio.NewScanner(r)
        lines <span class="hljs-keyword">int</span>
    )

    <span class="hljs-keyword">for</span> sc.Scan() {
        lines++
    }

    <span class="hljs-keyword">return</span> lines, sc.Err()
}</code></pre></div>
<h3 id="error-writer">error writer</h3>
<p>看一个来自 go blog 的例子：<a title="https://blog.golang.org/errors-are-values" href="https://blog.golang.org/errors-are-values">https://blog.golang.org/errors-are-values</a></p>
<p>一般代码：</p>
<div><pre class="hljs"><code>_, err = fd.Write(p0[a:b])
<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
    <span class="hljs-keyword">return</span> err
}
_, err = fd.Write(p1[c:d])
<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
    <span class="hljs-keyword">return</span> err
}
_, err = fd.Write(p2[e:f])
<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
    <span class="hljs-keyword">return</span> err
}
<span class="hljs-comment">// and so on</span></code></pre></div>
<p>errWriter</p>
<div><pre class="hljs"><code><span class="hljs-keyword">type</span> errWriter <span class="hljs-keyword">struct</span> {
    w   io.Writer
    err error
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ew *errWriter)</span> <span class="hljs-title">write</span><span class="hljs-params">(buf []<span class="hljs-keyword">byte</span>)</span></span> {
    <span class="hljs-keyword">if</span> ew.err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span>
    }
    _, ew.err = ew.w.Write(buf)
}

<span class="hljs-comment">// 使用时</span>
ew := &amp;errWriter{w: fd}
ew.write(p0[a:b])
ew.write(p1[c:d])
ew.write(p2[e:f])
<span class="hljs-comment">// and so on</span>
<span class="hljs-keyword">if</span> ew.err != <span class="hljs-literal">nil</span> {
    <span class="hljs-keyword">return</span> ew.err
}</code></pre></div>
<p>如果去翻 标准库中<code>bufio.Writer</code> 的源代码，你会发现也有这种用法，这种就是将重复的逻辑进行了封装，然后把<code>error</code>暂存，然后我们就只需要在最后判断一下<code>error</code>就行了</p>
<h2 id="wrap-error-错误包装">wrap error: 错误包装</h2>
<h3 id="errorswrap-有何作用为什么不用标准库的-fmterrorfw">errors.wrap 有何作用，为什么不用标准库的 fmt.Errorf("%w")</h3>
<p>我们先看一下标准库的源码，我们可以发现当<code>p.wrappedErr != nil</code> 的时候（也就是有 <code>%w</code>）的时候，会使用一个 <code>wrapError</code>  将错误包装，看 <code>wrapError</code>  的源码可以发现，这个方法只是包装了一下原始错误，并且可以做到附加一些文本信息，但是没有堆栈信息。</p>
<div><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Errorf</span><span class="hljs-params">(format <span class="hljs-keyword">string</span>, a ...<span class="hljs-keyword">interface</span>{})</span> <span class="hljs-title">error</span></span> {
    p := newPrinter()
    p.wrapErrs = <span class="hljs-literal">true</span>
    p.doPrintf(format, a)
    s := <span class="hljs-keyword">string</span>(p.buf)
    <span class="hljs-keyword">var</span> err error
    <span class="hljs-keyword">if</span> p.wrappedErr == <span class="hljs-literal">nil</span> {
        err = errors.New(s)
    } <span class="hljs-keyword">else</span> {
        err = &amp;wrapError{s, p.wrappedErr}
    }
    p.free()
    <span class="hljs-keyword">return</span> err
}

<span class="hljs-keyword">type</span> wrapError <span class="hljs-keyword">struct</span> {
    msg <span class="hljs-keyword">string</span>
    err error
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *wrapError)</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> {
    <span class="hljs-keyword">return</span> e.msg
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *wrapError)</span> <span class="hljs-title">Unwrap</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> {
    <span class="hljs-keyword">return</span> e.err
}</code></pre></div>
<p>再看一下 <code>pkg/errors</code> 的源码，我肯可以发现除了使用 <code>withMessage</code>  附加了错误信息之外还使用<code> withStack</code>  附加了堆栈信息，这样我们在程序入口处打印日志信息的时候就可以将堆栈信息一并打出了</p>
<div><pre class="hljs"><code><span class="hljs-comment">// Wrap returns an error annotating err with a stack trace</span>
<span class="hljs-comment">// at the point Wrap is called, and the supplied message.</span>
<span class="hljs-comment">// If err is nil, Wrap returns nil.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Wrap</span><span class="hljs-params">(err error, message <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> {
    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
    }
    err = &amp;withMessage{
        cause: err,
        msg:   message,
    }
    <span class="hljs-keyword">return</span> &amp;withStack{
        err,
        callers(),
    }
}</code></pre></div>
<h3 id="为什么不允许处处使用-errorswrap">为什么不允许处处使用 errors.Wrap</h3>
<p>因为每一次 <code>errors.Wrap</code> 的调用都会为错误添加堆栈信息，如果处处调用那会有大量的无用堆栈<br />
我们先看一下只有一处<code> wrap</code></p>
<div><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    fmt.Printf(<span class="hljs-string">"err: %+v"</span>, c())
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> {
    <span class="hljs-keyword">return</span> errors.Wrap(fmt.Errorf(<span class="hljs-string">"xxx"</span>), <span class="hljs-string">"test"</span>)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> {
    <span class="hljs-keyword">return</span> a()
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">c</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> {
    <span class="hljs-keyword">return</span> b()
}</code></pre></div>
<p>看结果我们可以发现已经可以打印出全部的堆栈信息了</p>
<div><pre class="hljs"><code>err: xxx
test
main.a
        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">14</span>
main.b
        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">18</span>
main.c
        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">22</span>
main.main
        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>
runtime.main
        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/proc.<span class="hljs-keyword">go</span>:<span class="hljs-number">204</span>
runtime.goexit
        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/asm_amd64.s:<span class="hljs-number">1374</span></code></pre></div>
<p>再看多处 wrap 的现象</p>
<div><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    fmt.Printf(<span class="hljs-string">"err: %+v"</span>, c())
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> {
    <span class="hljs-keyword">return</span> errors.Wrap(fmt.Errorf(<span class="hljs-string">"xxx"</span>), <span class="hljs-string">"a"</span>)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> {
    <span class="hljs-keyword">return</span> errors.Wrap(a(), <span class="hljs-string">"b"</span>)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">c</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> {
    <span class="hljs-keyword">return</span> errors.Wrap(b(), <span class="hljs-string">"c"</span>)
}</code></pre></div>
<p>可以看到每一处<code>wrap</code>都添加了一次堆栈信息</p>
<div><pre class="hljs"><code>err: xxx
a
main.a
        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">14</span>
main.b
        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">18</span>
main.c
        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">22</span>
main.main
        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>
runtime.main
        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/proc.<span class="hljs-keyword">go</span>:<span class="hljs-number">204</span>
runtime.goexit
        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/asm_amd64.s:<span class="hljs-number">1374</span>
b
main.b
        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">18</span>
main.c
        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">22</span>
main.main
        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>
runtime.main
        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/proc.<span class="hljs-keyword">go</span>:<span class="hljs-number">204</span>
runtime.goexit
        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/asm_amd64.s:<span class="hljs-number">1374</span>
c
main.c
        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">22</span>
main.main
        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>
runtime.main
        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/proc.<span class="hljs-keyword">go</span>:<span class="hljs-number">204</span>
runtime.goexit
        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/asm_amd64.s:<span class="hljs-number">1374</span></code></pre></div>
<h2 id="标准库-errorsis-as-怎么判断错误">标准库 errors.Is / As 怎么判断错误</h2>
<h3 id="errorsis">errors.Is</h3>
<div><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Is</span><span class="hljs-params">(err, target error)</span> <span class="hljs-title">bool</span></span> {
    <span class="hljs-keyword">if</span> target == <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> err == target
    }
    <span class="hljs-comment">// 通过反射判读 target 是否可以被比较</span>
    isComparable := reflectlite.TypeOf(target).Comparable()
    <span class="hljs-keyword">for</span> {
        <span class="hljs-comment">// 循环判断是否相等</span>
        <span class="hljs-keyword">if</span> isComparable &amp;&amp; err == target {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
        }
        <span class="hljs-comment">// 判断是否实现了 is 接口，如果有实现就直接判断</span>
        <span class="hljs-keyword">if</span> x, ok := err.(<span class="hljs-keyword">interface</span>{ Is(error) <span class="hljs-keyword">bool</span> }); ok &amp;&amp; x.Is(target) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
        }

        <span class="hljs-comment">// 去判断是否实现了 unwrap 的接口，如果实现了就进行 unwrap</span>
        <span class="hljs-keyword">if</span> err = Unwrap(err); err == <span class="hljs-literal">nil</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        }
    }
}</code></pre></div>
<h3 id="errorsas">errors.As</h3>
<p>和 is 的逻辑类似，就是不断的进行 unwrap 进行比较，只要有一个相同就返回，如果一直到底都不行就返回 false</p>
<div><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">As</span><span class="hljs-params">(err error, target <span class="hljs-keyword">interface</span>{})</span> <span class="hljs-title">bool</span></span> {
    <span class="hljs-keyword">if</span> target == <span class="hljs-literal">nil</span> {
        <span class="hljs-built_in">panic</span>(<span class="hljs-string">"errors: target cannot be nil"</span>)
    }
    val := reflectlite.ValueOf(target)
    typ := val.Type()
    <span class="hljs-keyword">if</span> typ.Kind() != reflectlite.Ptr || val.IsNil() {
        <span class="hljs-built_in">panic</span>(<span class="hljs-string">"errors: target must be a non-nil pointer"</span>)
    }
    <span class="hljs-keyword">if</span> e := typ.Elem(); e.Kind() != reflectlite.Interface &amp;&amp; !e.Implements(errorType) {
        <span class="hljs-built_in">panic</span>(<span class="hljs-string">"errors: *target must be interface or implement error"</span>)
    }
    targetType := typ.Elem()
    <span class="hljs-keyword">for</span> err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">if</span> reflectlite.TypeOf(err).AssignableTo(targetType) {
            val.Elem().Set(reflectlite.ValueOf(err))
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
        }
        <span class="hljs-keyword">if</span> x, ok := err.(<span class="hljs-keyword">interface</span>{ As(<span class="hljs-keyword">interface</span>{}) <span class="hljs-keyword">bool</span> }); ok &amp;&amp; x.As(target) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
        }
        err = Unwrap(err)
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
}</code></pre></div>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Golang项目目录结构]]></title>
            <guid>f2a72a9994004b52a6cf5ce91d394c31</guid>
            <pubDate>Mon, 30 Jan 2023 02:30:43 GMT</pubDate>
            <content:encoded><![CDATA[<p>这是 Go 应用程序项目的基本布局。它不是核心 Go 开发团队定义的官方标准；然而，它是 Go 生态系统中一组常见的老项目和新项目的布局模式。其中一些模式比其他模式更受欢迎。它还具有许多小的增强，以及对任何足够大的实际应用程序通用的几个支持目录。</p>
<p>如果你尝试学习 Go，或者你正在为自己建立一个 PoC 或一个玩具项目，这个项目布局是没啥必要的。从一些非常简单的事情开始(一个 <code>main.go</code> 文件绰绰有余)。随着项目的增长，请记住保持代码结构良好非常重要，否则你最终会得到一个凌乱的代码，这其中就包含大量隐藏的依赖项和全局状态。当有更多的人参与这个项目时，你将需要更多的结构。这时候，介绍一种管理包/库的通用方法是很重要的。当你有一个开源项目时，或者当你知道其他项目从你的项目存储库中导入代码时，这时候拥有私有(又名 <code>internal</code>)包和代码就很重要。克隆存储库，保留你需要的内容，删除其他所有的内容!仅仅因为它在那里并不意味着你必须全部使用它。这些模式都没有在每个项目中使用。甚至 <code>vendor</code> 模式也不是通用的。</p>
<p>Go 1.14 <a title="https://github.com/golang/go/wiki/Modules" href="https://github.com/golang/go/wiki/Modules"><code>Go Modules</code></a> 终于可以投入生产了。除非你有特定的理由不使用它们，否则使用 <a title="https://blog.golang.org/using-go-modules" href="https://blog.golang.org/using-go-modules"><code>Go Modules</code></a> 。如果你使用，就无需担心 $GOPATH 以及项目放置的位置。存储库中的 <code>go.mod</code> 文件基本假定你的项目托管在 Github 上，但这不是要求。模块路径可以是任何地方，尽管第一个模块路径组件的名称中应该有一个点（当前版本的 Go 不再强制使用该模块，但如果使用稍旧的版本，如果没有 <code>mod</code> 文件构建失败的话 ，不要惊讶）。如果你想知道更多信息，请参阅 Issues <a title="https://github.com/golang/go/issues/37554" href="https://github.com/golang/go/issues/37554"><code>37554</code></a> 和 <a title="https://github.com/golang/go/issues/32819" href="https://github.com/golang/go/issues/32819"><code>32819</code></a> 。</p>
<p>此项目布局是通用的，并且不会尝试强加一个特定的 Go 包结构。</p>
<p>这是社区的努力。 如果看到新的模式，或者认为一个现有的模式需要更新，请提一个 issue。</p>
<p>如果需要命名、格式和样式方面的帮助，请运行 <a title="https://golang.org/cmd/gofmt/" href="https://golang.org/cmd/gofmt/"><code>gofmt</code></a> 和 <a title="https://github.com/golang/lint" href="https://github.com/golang/lint"><code>golint</code></a> 。还要确保阅读这些 Go 代码风格的指导方针和建议:</p>
<ul>
<li><a title="https://talks.golang.org/2014/names.slide" href="https://talks.golang.org/2014/names.slide">https://talks.golang.org/2014/names.slide</a></li>
<li><a title="https://golang.org/doc/effective_go.html#names" href="https://golang.org/doc/effective_go.html#names">https://golang.org/doc/effective_go.html#names</a></li>
<li><a title="https://blog.golang.org/package-names" href="https://blog.golang.org/package-names">https://blog.golang.org/package-names</a></li>
<li><a title="https://github.com/golang/go/wiki/CodeReviewComments" href="https://github.com/golang/go/wiki/CodeReviewComments">https://github.com/golang/go/wiki/CodeReviewComments</a></li>
<li><a title="https://rakyll.org/style-packages" href="https://rakyll.org/style-packages">Style guideline for Go packages</a> (rakyll/JBD)</li>
</ul>
<p>参见 <a title="https://medium.com/golang-learn/go-project-layout-e5213cdcfaa2" href="https://medium.com/golang-learn/go-project-layout-e5213cdcfaa2"><code>Go Project Layout</code></a> 了解更多的背景信息。</p>
<p>更多关于包的命名和组织以及其他代码结构的建议:</p>
<ul>
<li><a title="https://www.youtube.com/watch?v=PTE4VJIdHPg" href="https://www.youtube.com/watch?v=PTE4VJIdHPg">GopherCon EU 2018: Peter Bourgon - Best Practices for Industrial Programming</a></li>
<li><a title="https://www.youtube.com/watch?v=MzTcsI6tn-0" href="https://www.youtube.com/watch?v=MzTcsI6tn-0">GopherCon Russia 2018: Ashley McNamara + Brian Ketelsen - Go best practices.</a></li>
<li><a title="https://www.youtube.com/watch?v=ltqV6pDKZD8" href="https://www.youtube.com/watch?v=ltqV6pDKZD8">GopherCon 2017: Edward Muller - Go Anti-Patterns</a></li>
<li><a title="https://www.youtube.com/watch?v=oL6JBUk6tj0" href="https://www.youtube.com/watch?v=oL6JBUk6tj0">GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps</a></li>
</ul>
<h2 id="go-目录">Go 目录</h2>
<h3 id="cmd"><code>/cmd</code></h3>
<p>本项目的主干。</p>
<p>每个应用程序的目录名应该与你想要的可执行文件的名称相匹配(例如，<code>/cmd/myapp</code>)。</p>
<p>不要在这个目录中放置太多代码。如果你认为代码可以导入并在其他项目中使用，那么它应该位于 <code>/pkg</code> 目录中。如果代码不是可重用的，或者你不希望其他人重用它，请将该代码放到 <code>/internal</code> 目录中。你会惊讶于别人会怎么做，所以要明确你的意图!</p>
<p>通常有一个小的 <code>main</code> 函数，从 <code>/internal</code> 和 <code>/pkg</code> 目录导入和调用代码，除此之外没有别的东西。</p>
<p>有关示例，请参阅 <a title="cmd/README.md" href="cmd/README.md"><code>/cmd</code></a> 目录。</p>
<h3 id="internal"><code>/internal</code></h3>
<p>私有应用程序和库代码。这是你不希望其他人在其应用程序或库中导入代码。请注意，这个布局模式是由 Go 编译器本身执行的。有关更多细节，请参阅Go 1.4 <a title="https://golang.org/doc/go1.4#internalpackages" href="https://golang.org/doc/go1.4#internalpackages"><code>release notes</code></a> 。注意，你并不局限于顶级 <code>internal</code> 目录。在项目树的任何级别上都可以有多个内部目录。</p>
<p>你可以选择向 internal 包中添加一些额外的结构，以分隔共享和非共享的内部代码。这不是必需的(特别是对于较小的项目)，但是最好有有可视化的线索来显示预期的包的用途。你的实际应用程序代码可以放在 <code>/internal/app</code> 目录下(例如 <code>/internal/app/myapp</code>)，这些应用程序共享的代码可以放在 <code>/internal/pkg</code> 目录下(例如 <code>/internal/pkg/myprivlib</code>)。</p>
<h3 id="pkg"><code>/pkg</code></h3>
<p>外部应用程序可以使用的库代码(例如 <code>/pkg/mypubliclib</code>)。其他项目会导入这些库，希望它们能正常工作，所以在这里放东西之前要三思:-)注意，<code>internal</code> 目录是确保私有包不可导入的更好方法，因为它是由 Go 强制执行的。<code>/pkg</code> 目录仍然是一种很好的方式，可以显式地表示该目录中的代码对于其他人来说是安全使用的好方法。由 Travis Jeffery  撰写的 <a title="https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/" href="https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/"><code>I'll take pkg over internal</code></a> 博客文章提供了 <code>pkg</code> 和 <code>internal</code> 目录的一个很好的概述，以及什么时候使用它们是有意义的。</p>
<p>当根目录包含大量非 Go 组件和目录时，这也是一种将 Go 代码分组到一个位置的方法，这使得运行各种 Go 工具变得更加容易（正如在这些演讲中提到的那样: 来自 GopherCon EU 2018 的 <a title="https://www.youtube.com/watch?v=PTE4VJIdHPg" href="https://www.youtube.com/watch?v=PTE4VJIdHPg"><code>Best Practices for Industrial Programming</code></a> , <a title="https://www.youtube.com/watch?v=oL6JBUk6tj0" href="https://www.youtube.com/watch?v=oL6JBUk6tj0">GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps</a> 和 <a title="https://www.youtube.com/watch?v=3gQa1LWwuzk" href="https://www.youtube.com/watch?v=3gQa1LWwuzk">GoLab 2018 - Massimiliano Pippi - Project layout patterns in Go</a> ）。</p>
<p>如果你想查看哪个流行的 Go 存储库使用此项目布局模式，请查看 <a title="pkg/README.md" href="pkg/README.md"><code>/pkg</code></a> 目录。这是一种常见的布局模式，但并不是所有人都接受它，一些 Go 社区的人也不推荐它。</p>
<p>如果你的应用程序项目真的很小，并且额外的嵌套并不能增加多少价值(除非你真的想要:-)，那就不要使用它。当它变得足够大时，你的根目录会变得非常繁琐时(尤其是当你有很多非 Go 应用组件时)，请考虑一下。</p>
<p>可以参考的开源项目<a title="https://github.com/go-kit/kit" href="https://github.com/go-kit/kit">go-kit</a></p>
<h3 id="vendor"><code>/vendor</code></h3>
<p>应用程序依赖项(手动管理或使用你喜欢的依赖项管理工具，如新的内置 <a title="https://github.com/golang/go/wiki/Modules" href="https://github.com/golang/go/wiki/Modules"><code>Go Modules</code></a> 功能)。<code>go mod vendor</code> 命令将为你创建 <code>/vendor</code> 目录。请注意，如果未使用默认情况下处于启用状态的 Go 1.14，则可能需要在 <code>go build</code> 命令中添加 <code>-mod=vendor</code> 标志。</p>
<p>如果你正在构建一个库，那么不要提交你的应用程序依赖项。</p>
<p>注意，自从 <a title="https://golang.org/doc/go1.13#modules" href="https://golang.org/doc/go1.13#modules"><code>1.13</code></a> 以后，Go 还启用了模块代理功能(默认使用 <a title="https://proxy.golang.org" href="https://proxy.golang.org"><code>https://proxy.golang.org</code></a> 作为他们的模块代理服务器)。在<a title="https://blog.golang.org/module-mirror-launch" href="https://blog.golang.org/module-mirror-launch"><code>here</code></a> 阅读更多关于它的信息，看看它是否符合你的所有需求和约束。如果需要，那么你根本不需要 <code>vendor</code> 目录。</p>
<p>国内模块代理功能默认是被墙的，七牛云有维护专门的的<a title="https://github.com/goproxy/goproxy.cn/blob/master/README.zh-CN.md" href="https://github.com/goproxy/goproxy.cn/blob/master/README.zh-CN.md"><code>模块代理</code></a> 。</p>
<h2 id="服务应用程序目录">服务应用程序目录</h2>
<h3 id="api"><code>/api</code></h3>
<p>OpenAPI/Swagger 规范，JSON 模式文件，协议定义文件。</p>
<p>有关示例，请参见 <a title="api/README.md" href="api/README.md"><code>/api</code></a> 目录。</p>
<h2 id="web-应用程序目录">Web 应用程序目录</h2>
<h3 id="web"><code>/web</code></h3>
<p>特定于 Web 应用程序的组件:静态 Web 资产、服务器端模板和 SPAs。</p>
<h2 id="通用应用目录">通用应用目录</h2>
<h3 id="configs"><code>/configs</code></h3>
<p>配置文件模板或默认配置。</p>
<p>将你的 <code>confd</code> 或 <code>consul-template</code> 模板文件放在这里。</p>
<h3 id="init"><code>/init</code></h3>
<p>System init（systemd，upstart，sysv）和 process manager/supervisor（runit，supervisor）配置。</p>
<h3 id="scripts"><code>/scripts</code></h3>
<p>执行各种构建、安装、分析等操作的脚本。</p>
<p>这些脚本保持了根级别的 Makefile 变得小而简单(例如， <a title="https://github.com/hashicorp/terraform/blob/master/Makefile" href="https://github.com/hashicorp/terraform/blob/master/Makefile"><code>https://github.com/hashicorp/terraform/blob/master/Makefile</code></a> )。</p>
<p>有关示例，请参见  <a title="scripts/README.md" href="scripts/README.md"><code>/scripts</code></a> 目录。</p>
<h3 id="build"><code>/build</code></h3>
<p>打包和持续集成。</p>
<p>将你的云( AMI )、容器( Docker )、操作系统( deb、rpm、pkg )包配置和脚本放在 <code>/build/package</code> 目录下。</p>
<p>将你的 CI (travis、circle、drone)配置和脚本放在 <code>/build/ci</code> 目录中。请注意，有些 CI 工具(例如 Travis CI)对配置文件的位置非常挑剔。尝试将配置文件放在 <code>/build/ci</code> 目录中，将它们链接到 CI 工具期望它们的位置(如果可能的话)。</p>
<h3 id="deployments"><code>/deployments</code></h3>
<p>IaaS、PaaS、系统和容器编排部署配置和模板(docker-compose、kubernetes/helm、mesos、terraform、bosh)。注意，在一些存储库中(特别是使用 kubernetes 部署的应用程序)，这个目录被称为 <code>/deploy</code>。</p>
<h3 id="test"><code>/test</code></h3>
<p>额外的外部测试应用程序和测试数据。你可以随时根据需求构造 <code>/test</code> 目录。对于较大的项目，有一个数据子目录是有意义的。例如，你可以使用 <code>/test/data</code> 或 <code>/test/testdata</code> (如果你需要忽略目录中的内容)。请注意，Go 还会忽略以“.”或“_”开头的目录或文件，因此在如何命名测试数据目录方面有更大的灵活性。</p>
<p>有关示例，请参见  <a title="test/README.md" href="test/README.md"><code>/test</code></a> 目录。</p>
<h2 id="其他目录">其他目录</h2>
<h3 id="docs"><code>/docs</code></h3>
<p>设计和用户文档(除了 godoc 生成的文档之外)。</p>
<p>有关示例，请参阅 <a title="docs/README.md" href="docs/README.md"><code>/docs</code></a> 目录。</p>
<h3 id="tools"><code>/tools</code></h3>
<p>这个项目的支持工具。注意，这些工具可以从 <code>/pkg</code> 和 <code>/internal</code> 目录导入代码。</p>
<p>有关示例，请参见 <a title="tools/README.md" href="tools/README.md"><code>/tools</code></a> 目录。</p>
<h3 id="examples"><code>/examples</code></h3>
<p>你的应用程序和/或公共库的示例。</p>
<p>有关示例，请参见 <a title="examples/README.md" href="examples/README.md"><code>/examples</code></a> 目录。</p>
<h3 id="third_party"><code>/third_party</code></h3>
<p>外部辅助工具，分叉代码和其他第三方工具(例如 Swagger UI)。</p>
<h3 id="githooks"><code>/githooks</code></h3>
<p>Git hooks。</p>
<h3 id="assets"><code>/assets</code></h3>
<p>与存储库一起使用的其他资产(图像、徽标等)。</p>
<h3 id="website"><code>/website</code></h3>
<p>如果你不使用 Github 页面，则在这里放置项目的网站数据。</p>
<p>有关示例，请参见 <a title="website/README.md" href="website/README.md"><code>/website</code></a> 目录。</p>
<h2 id="你不应该拥有的目录">你不应该拥有的目录</h2>
<h3 id="src"><code>/src</code></h3>
<p>有些 Go 项目确实有一个 <code>src</code> 文件夹，但这通常发生在开发人员有 Java 背景，在那里它是一种常见的模式。如果可以的话，尽量不要采用这种 Java 模式。你真的不希望你的 Go 代码或 Go 项目看起来像 Java:-)</p>
<p>不要将项目级别 <code>src</code> 目录与 Go 用于其工作空间的 <code>src</code> 目录(如 <a title="https://golang.org/doc/code.html" href="https://golang.org/doc/code.html"><code>How to Write Go Code</code></a> 中所述)混淆。<code>$GOPATH</code> 环境变量指向你的(当前)工作空间(默认情况下，它指向非 windows 系统上的 <code>$HOME/go</code>)。这个工作空间包括顶层 <code>/pkg</code>, <code>/bin</code> 和 <code>/src</code> 目录。你的实际项目最终是 <code>/src</code> 下的一个子目录，因此，如果你的项目中有 <code>/src</code> 目录，那么项目路径将是这样的: <code>/some/path/to/workspace/src/your_project/src/your_code.go</code>。注意，在 Go 1.11 中，可以将项目放在 <code>GOPATH</code> 之外，但这并不意味着使用这种布局模式是一个好主意。</p>
<h3 id="utilscommon"><code>/utils，/common</code></h3>
<p>不要在项目中出现 utils 和 common 这种包，如果出现这种包，因为我们并不能从包中知道你这个包的作用，长久之后这个包就会变成一个大杂烩，所有东西都往这里面扔。</p>
<p>举个例子，我们当前使用<code>gin</code>作为路由框架，但是<code>gin</code>的 <code>handler</code> 注册其实不是很方便，所以我们做了一层封装，这个时候这个工具方法我们一般放在<code> /pkg/ginx</code> 目录下，表示这个是对<code>gin</code>增强的包，不直接使用<code>gin</code>作为包名的原因是因为我们在项目中也会引用<code>gin</code>相同的命名一个是会导致误解，另一个是在同时导入的时候也会需要去进行重命名会比较麻烦</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[BTFGen: 让 eBPF 程序可移植发布更近一步]]></title>
            <guid>f14b5b38df1f4a5d8ad1745dbfde1eb1</guid>
            <pubDate>Fri, 06 Jan 2023 02:28:46 GMT</pubDate>
            <content:encoded><![CDATA[<nav class="table-of-contents"><ul><li><a href="#1-问题所在">1. 问题所在</a></li><li><a href="#2-co-re-一次编译-到处运行">2. CO-RE (一次编译 - 到处运行)</a></li><li><a href="#3-btfhub">3. BTFHub</a></li><li><a href="#4-btfgen">4. BTFGen</a><ul><li><a href="#41-内部实现细节">4.1 内部实现细节</a></li></ul></li><li><a href="#42-如何使用">4.2 如何使用?</a><ul><li><a href="#安装-bpftool-工具">安装 bpftool 工具</a></li><li><a href="#从-bfthub-获取内核对应的-btf-文件">从 BFThub 获取内核对应的 BTF 文件</a></li><li><a href="#下载-修改和编译-bcc-libbpf-工具">下载、修改和编译 BCC libbpf 工具</a></li><li><a href="#生成-精简版-btf-文件">生成 “精简版” BTF 文件</a></li><li><a href="#验证">验证</a></li><li><a href="#43-集成样例">4.3 集成样例</a><ul><li><a href="#inspektor-gadget">Inspektor Gadget</a></li><li><a href="#tracee">Tracee</a></li></ul></li><li><a href="#44-限制">4.4 限制</a></li><li><a href="#45-未来发展">4.5 未来发展</a><ul><li><a href="#与其他项目的整合">与其他项目的整合</a></li><li><a href="#删除重复的文件">删除重复的文件</a></li><li><a href="#在线-api">在线 API</a></li></ul></li></ul></li><li><a href="#5-更多信息">5. 更多信息</a></li><li><a href="#6-致谢">6. 致谢</a></li></ul></nav><p>eBPF 是一项广为人知的技术，已经在可观测、网络和安全领域领域得到广泛应用。Linux 操作系统提供了虚拟机，可用于安全和高效的方式运行 eBPF 程序【译者注：如果是 JIT 模式则会直接翻译成本地 CPU 指令，则不需要虚拟机】。eBPF 程序挂载在操作系统提供的钩子上，使其能够在内核中发生特定事件时过滤和提取感兴趣的信息。</p>
<p>在本文中，我们将介绍助力 eBPF 程序移植的工具 BTFGen，以及其如何被集成到其他项目中，主要的内容如下：</p>
<ul>
<li>在不同的目标机器上运行 eBPF 程序的挑战；</li>
<li>传统上如何通过在加载程序之前通过编译解决的；</li>
<li>解决挑战对应的的机制/工具（如 CO-RE 一次编译 - 到处运行）；</li>
<li>BTFHub 工具如何尝试解决这些挑战。</li>
</ul>
<h2 id="1-问题所在">1. 问题所在</h2>
<p>eBPF 程序需要访问内核结构来获取需要的数据，因此依赖于内核结构的布局。为特定内核版本编译的 eBPF 程序通常不能在另一个内核版本上工作，这是因为相关的内核数据结构布局可能会发生了变化：比如字段添加、删除，或类型被改变，甚至内核编译配置的改变也会改变整个结构布局。例如，禁用 <code>CONFIG_THREAD_INFO_IN_TASK</code> 会改变 <a title="https://github.com/torvalds/linux/blob/v5.16/include/linux/sched.h#L723" href="https://github.com/torvalds/linux/blob/v5.16/include/linux/sched.h#L723">task_struct</a> 的所有成员变量的偏移：</p>
<div><pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> {</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_THREAD_INFO_IN_TASK</span>
    <span class="hljs-comment">/*
     * For reasons of header soup (see current_thread_info()), this
     * must be the first element of task_struct.
     */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_info</span>		<span class="hljs-title">thread_info</span>;</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>			__state;

<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PREEMPT_RT</span>
    <span class="hljs-comment">/* saved state for "spinlock sleepers" */</span>
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>			saved_state;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
...</code></pre></div>
<p>该问题的解决通常是在目标机器使用内核头文件编译 eBPF 程序并进行加载，<a title="https://github.com/iovisor/bcc/" href="https://github.com/iovisor/bcc/">BCC</a> 项目所使用的正是这种方式。但该方法存在以下问题：</p>
<ol>
<li>必须在目标机器上安装占用大量空间的编译器；</li>
<li>编译程序时需要资源，在某些情况下可能会影响工作负载的调度；</li>
<li>编译需要相当长的时间，因此事件采集会存在一些延迟；</li>
<li>依赖于目标机器上安装内核头文件包。</li>
</ol>
<h2 id="2-co-re-一次编译-到处运行">2. CO-RE (一次编译 - 到处运行)</h2>
<p>CO-RE 机制正是为解决上述问题提出的方案。在该方案中，eBPF 程序一次编译，然后在运行时进行更新（patched）：基于运行的机器的内核结构布局更新运行指令。<a title="https://nakryiko.com/posts/bpf-portability-and-co-re" href="https://nakryiko.com/posts/bpf-portability-and-co-re">BPF CO-RE (Compile Once - Run Everywhere)</a> 介绍了该技术背后的所有细节。对于本文，需要理解的是 CO-RE 需要有目标内核的 BTF 信息（BPF Type Format 类型格式）。BTF 信息由内核本身提供的，这需要在内核编译时设置 <code>CONFIG_DEBUG_INFO_BTF=y</code> 选项 。该选项在<a title="https://github.com/torvalds/linux/commit/e83b9f55448afce3fe1abcd1d10db9584f8042a6" href="https://github.com/torvalds/linux/commit/e83b9f55448afce3fe1abcd1d10db9584f8042a6">Linux 内核 5.2</a> 中引入的，许多流行的 Linux 发行版在其后的部分内核版本才默认启用。这意味着有很多用户运行的内核并没有导出 BTF 信息，因此不能使用基于 CO-RE 的工具。</p>
<h2 id="3-btfhub">3. BTFHub</h2>
<p><a title="https://github.com/aquasecurity/btfhub" href="https://github.com/aquasecurity/btfhub">BTFHub</a> 是 Aqua Security 公司的一个项目，其可为不导出 BTF 信息的流行发行版内核提供BTF 信息补充。目标内核的 BTF 文件可以在运行时下载，然后与加载库（libbpf、cilium/ebpf 或其他）配合，加载库基于 BTF 文件对程序进行相应的更新（patch）。</p>
<p>尽管 BTFHub 做了很大的改进，但是它仍然面临着一些挑战：每个 BTF 文件有数 MB 大小，因此不可能把所有内核的 BTF 文件和应用程序一起打包，因为这可能需要数 GB 的空间占用。另一种方法是在运行时下载当前内核的所需 BTF，但这也带来了一些问题：延迟 eBPF 程序启动，而且在某些情况下，连接到外部主机下载文件也不可行。</p>
<h2 id="4-btfgen">4. BTFGen</h2>
<p>其实，通常我们并不需要提供描述所有内核类型的完整 BTF 文件，因为 eBPF 程序通常只需要访问其中的少数类型。一个 “精简版” 的 BTF 文件，只需要提供程序使用类型的信息就足够了。这就是工具 BTFGen 发挥作用：其可以生成一组 eBPF 程序所需的精简的 BTF ，通过该方式生成的 BTF 文件只有数 KB 大小，将其与应用程序打包交付变成了可能。</p>
<p>BTFGen 并不是单独提供能力的。它需要具有不同 Linux 发行版的所有内核类型的源 BTF 文件（由 BTFHub 提供），并且 CO-RE 机制（在libbpf、Linux内核或另一个加载库中）在加载程序时通过打补丁方式更新 eBPF 程序。</p>
<p>使用 BTFGen 的主要流程如下：</p>
<ol>
<li>开发人员编写<a title="https://nakryiko.com/posts/bpf-core-reference-guide/" href="https://nakryiko.com/posts/bpf-core-reference-guide/">基于 CO-RE</a> 的 eBPF 程序，并通过 llvm/clang 编译成对象文件；</li>
<li>从 BTFHub 或其他来源收集不同 Linux 内核发行版的 BTF 源文件；</li>
<li>使用 BTFGen 生成精简版的 BTF 文件；</li>
<li>将精简版的 BTF 文件与应用程序打包分发。</li>
</ol>
<p><img src="/_resources/74c0a8490488473eaa2b1495f5cb1bf7.png" /></p>
<h3 id="41-内部实现细节">4.1 内部实现细节</h3>
<p>BTFGen 在 bpftool 工具中实现，其使用 libbpf CO-RE 逻辑来解决重定位问题。有了这些信息，它就能挑选出重新定位所涉及的类型来生成 “精简版” 的 BTF 文件。这篇文章的目的不是要解释所有的内部实现细节。如果你想知道更多，你可以查看 BTFHub 仓库中的<a title="https://github.com/aquasecurity/btfhub/blob/main/docs/btfgen-internals.md" href="https://github.com/aquasecurity/btfhub/blob/main/docs/btfgen-internals.md">这个文档</a>或实现它的<a title="https://lore.kernel.org/bpf/164503621150.2935.6634904664671748900.git-patchwork-notify@kernel.org/T/#mdd100ccbc95947c8fe6be74db66002e273a29abd" href="https://lore.kernel.org/bpf/164503621150.2935.6634904664671748900.git-patchwork-notify@kernel.org/T/#mdd100ccbc95947c8fe6be74db66002e273a29abd">补丁</a>。</p>
<h2 id="42-如何使用">4.2 如何使用?</h2>
<p>本节提供了 BTFGen 工具使用的更多细节。在本例中，我们将使用 BTFGen 来实现内核未启用 CONFIG_DEBUG_INFO_BTF 选项的机器上运行特定的 <a title="https://github.com/iovisor/bcc/tree/v0.24.0/libbpf-tools" href="https://github.com/iovisor/bcc/tree/v0.24.0/libbpf-tools">BCC libbpf-tools</a> 工具。其他 eBPF 应用程序集成的方式也是类似。</p>
<p>为了实现上述的目的，我们需要以下流程：</p>
<ol>
<li>下载、编译和安装支持 BTFGen 的 bpftool 版本；</li>
<li>从 BTFHub 下载所需的 BTF 文件；</li>
<li>下载和编译 BCC 工具；</li>
<li>使用 BTFGen 为特定的 BCC 工具生成 “精简版” BTF 文件；</li>
<li>调整 BCC 工具代码，使其可以从自定义路径加载 BTF 文件；</li>
<li>最后进行验证。</li>
</ol>
<p>首先，我们为该演示创建一个临时目录：</p>
<div><pre class="hljs"><code>$ mkdir /tmp/btfgendemo</code></pre></div>
<h4 id="安装-bpftool-工具">安装 bpftool 工具</h4>
<p>BTFGen 刚刚被合入 bpftool。在 BTFGen 未被包含在不同发行版的软件包之前，我们需要从源代码进行编译：</p>
<div><pre class="hljs"><code>$ <span class="hljs-built_in">cd</span> /tmp/btfgendemo
$ git <span class="hljs-built_in">clone</span> --recurse-submodules https://github.com/libbpf/bpftool.git
$ <span class="hljs-built_in">cd</span> bpftool/src
$ make
$ sudo make install</code></pre></div>
<h4 id="从-bfthub-获取内核对应的-btf-文件">从 BFThub 获取内核对应的 BTF 文件</h4>
<p>这里为简洁起见，我们只考虑 Ubuntu Focal 系统中使用的场景，该方式也完全适用于 BTFHub 支持的其他发行版本。</p>
<div><pre class="hljs"><code>$ <span class="hljs-built_in">cd</span> /tmp/btfgendemo
$ git <span class="hljs-built_in">clone</span> https://github.com/aquasecurity/btfhub-archive
$ <span class="hljs-built_in">cd</span> btfhub-archive/ubuntu/focal/x86_64/
$ <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> *.tar.xz; <span class="hljs-keyword">do</span> tar -xf <span class="hljs-string">"<span class="hljs-variable">$f</span>"</span>; <span class="hljs-keyword">done</span>
$ ls -lhn *.btf | head
-rw-r----- 1 1000 1000 4,5M Sep 29 13:36 5.11.0-1007-azure.btf
-rw-r----- 1 1000 1000 4,8M Aug 10 23:33 5.11.0-1009-aws.btf
-rw-r----- 1 1000 1000 4,8M Jan 22 12:29 5.11.0-1009-gcp.btf
-rw-r----- 1 1000 1000 4,5M Sep 29 13:38 5.11.0-1012-azure.btf
-rw-r----- 1 1000 1000 4,5M Sep 29 13:40 5.11.0-1013-azure.btf
-rw-r----- 1 1000 1000 4,8M Aug 10 23:39 5.11.0-1014-aws.btf
-rw-r----- 1 1000 1000 4,8M Jan 22 12:32 5.11.0-1014-gcp.btf
-rw-r----- 1 1000 1000 4,5M Sep 29 13:43 5.11.0-1015-azure.btf
-rw-r----- 1 1000 1000 4,8M Sep 7 22:52 5.11.0-1016-aws.btf
-rw-r----- 1 1000 1000 4,8M Sep 7 22:57 5.11.0-1017-aws.btf</code></pre></div>
<p>如上述显示，我们可以看到每个内核对应的 BTF 文件的大小约为 4MB。</p>
<div><pre class="hljs"><code>$ find . -name <span class="hljs-string">"*.btf"</span> | xargs du -ch | tail -n 1
944M	total</code></pre></div>
<p>但是汇总起来看，仅 Ubuntu Focal 就有~944MB 的大小，将其与应用程序一起打包显然不太可行。</p>
<h4 id="下载-修改和编译-bcc-libbpf-工具">下载、修改和编译 BCC libbpf 工具</h4>
<p>我们从 BCC v0.24.0 标签上克隆仓库代码：</p>
<div><pre class="hljs"><code>$ <span class="hljs-built_in">cd</span> /tmp/btfgendemo
$ git <span class="hljs-built_in">clone</span> https://github.com/iovisor/bcc -b v0.24.0 --recursive</code></pre></div>
<p>默认情况下，不同的 BCC 工具会尝试从<a title="https://github.com/libbpf/libbpf/blob/22411acc4b2c846868fd570b2d9f3b016d2af2cb/src/btf.c#L4631-L4639" href="https://github.com/libbpf/libbpf/blob/22411acc4b2c846868fd570b2d9f3b016d2af2cb/src/btf.c#L4631-L4639">约定目录</a>中加载 BTF 信息。正常情况下，我们不能直接覆盖对应的文件，因为它们极有可能也会被其他工具所依赖。相反，我们可以修改 BCC 工具源码，让其从一个自定义的路径加载 BTF 文件。我们可以使用 LIBBPF_OPTS() 来声明一个 bpf_object_open_opts 结构，将其中的 btf_custom_path 字段设置为自定义 BTF 所在的路径，并将其传递给 TOOL_bpf__open_opts()函数。我们尝试使用如下的补丁来修改 opennoop、execsnoop 和 bindsnoop 工具。</p>
<p>译者注，约定的加载 BTF 目录如下：</p>
<div><pre class="hljs"><code>    { <span class="hljs-string">"/sys/kernel/btf/vmlinux"</span>, <span class="hljs-literal">true</span> /* raw BTF */ },
    { <span class="hljs-string">"/boot/vmlinux-%1<span class="hljs-variable">$s</span>"</span> },
    { <span class="hljs-string">"/lib/modules/%1<span class="hljs-variable">$s</span>/vmlinux-%1<span class="hljs-variable">$s</span>"</span> },
    { <span class="hljs-string">"/lib/modules/%1<span class="hljs-variable">$s</span>/build/vmlinux"</span> },
    { <span class="hljs-string">"/usr/lib/modules/%1<span class="hljs-variable">$s</span>/kernel/vmlinux"</span> },
    { <span class="hljs-string">"/usr/lib/debug/boot/vmlinux-%1<span class="hljs-variable">$s</span>"</span> },
    { <span class="hljs-string">"/usr/lib/debug/boot/vmlinux-%1<span class="hljs-variable">$s</span>.debug"</span> },
    { <span class="hljs-string">"/usr/lib/debug/lib/modules/%1<span class="hljs-variable">$s</span>/vmlinux"</span> },</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-comment"># /tmp/btfgendemo/bcc.patch</span>
diff --git a/libbpf-tools/bindsnoop.c b/libbpf-tools/bindsnoop.c
index 5d87d484..a336747e 100644
--- a/libbpf-tools/bindsnoop.c
+++ b/libbpf-tools/bindsnoop.c
@@ -187,7 +187,8 @@ int main(int argc, char **argv)
 	libbpf_set_strict_mode(LIBBPF_STRICT_ALL);
 	libbpf_set_print(libbpf_print_fn);

-	obj = bindsnoop_bpf__open();
+	LIBBPF_OPTS(bpf_object_open_opts, opts, .btf_custom_path = <span class="hljs-string">"/tmp/vmlinux.btf"</span>);
+	obj = bindsnoop_bpf__open_opts(&amp;opts);
 	<span class="hljs-keyword">if</span> (!obj) {
 		warn(<span class="hljs-string">"failed to open BPF object\n"</span>);
 		<span class="hljs-built_in">return</span> 1;
diff --git a/libbpf-tools/execsnoop.c b/libbpf-tools/execsnoop.c
index 38294816..9bd0d077 100644
--- a/libbpf-tools/execsnoop.c
+++ b/libbpf-tools/execsnoop.c
@@ -274,7 +274,8 @@ int main(int argc, char **argv)
 	libbpf_set_strict_mode(LIBBPF_STRICT_ALL);
 	libbpf_set_print(libbpf_print_fn);

-	obj = execsnoop_bpf__open();
+	LIBBPF_OPTS(bpf_object_open_opts, opts, .btf_custom_path = <span class="hljs-string">"/tmp/vmlinux.btf"</span>);
+	obj = execsnoop_bpf__open_opts(&amp;opts);
 	<span class="hljs-keyword">if</span> (!obj) {
 		fprintf(stderr, <span class="hljs-string">"failed to open BPF object\n"</span>);
 		<span class="hljs-built_in">return</span> 1;
diff --git a/libbpf-tools/opensnoop.c b/libbpf-tools/opensnoop.c
index 557a63cd..cf2c5db6 100644
--- a/libbpf-tools/opensnoop.c
+++ b/libbpf-tools/opensnoop.c
@@ -231,7 +231,8 @@ int main(int argc, char **argv)
 	libbpf_set_strict_mode(LIBBPF_STRICT_ALL);
 	libbpf_set_print(libbpf_print_fn);

-	obj = opensnoop_bpf__open();
+	LIBBPF_OPTS(bpf_object_open_opts, opts, .btf_custom_path = <span class="hljs-string">"/tmp/vmlinux.btf"</span>);
+	obj = opensnoop_bpf__open_opts(&amp;opts);
 	<span class="hljs-keyword">if</span> (!obj) {
 		fprintf(stderr, <span class="hljs-string">"failed to open BPF object\n"</span>);
 		<span class="hljs-built_in">return</span> 1;
$ <span class="hljs-built_in">cd</span> bcc
$ git apply /tmp/btfgendemo/bcc.patch
$ <span class="hljs-built_in">cd</span> libbpf-tools/
$ make -j$(nproc)</code></pre></div>
<h4 id="生成-精简版-btf-文件">生成 “精简版” BTF 文件</h4>
<p>这里，我们将使用<code> bpftool gen min_core_btf</code> 命令为 BCC 工具中的 bindsnoop、execsnoop 和opensnoop 同时生成精简的 BTF 文件。下述的命令对目录中存在的每个 BTF 文件逐次调用 bpftool 工具进行精简。</p>
<div><pre class="hljs"><code>$ OBJ1=/tmp/btfgendemo/bcc/libbpf-tools/.output/bindsnoop.bpf.o
$ OBJ2=/tmp/btfgendemo/bcc/libbpf-tools/.output/execsnoop.bpf.o
$ OBJ3=/tmp/btfgendemo/bcc/libbpf-tools/.output/opensnoop.bpf.o

$ mkdir -p /tmp/btfgendemo/btfs
$ <span class="hljs-built_in">cd</span> /tmp/btfgendemo/btfhub-archive/ubuntu/focal/x86_64/

$ <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> *.btf; <span class="hljs-keyword">do</span> bpftool gen min_core_btf <span class="hljs-string">"<span class="hljs-variable">$f</span>"</span> \
  /tmp/btfgendemo/btfs/$(basename <span class="hljs-string">"<span class="hljs-variable">$f</span>"</span>) <span class="hljs-variable">$OBJ1</span> <span class="hljs-variable">$OBJ2</span> <span class="hljs-variable">$OBJ3</span>; \
<span class="hljs-keyword">done</span>

$ ls -lhn /tmp/btfgendemo/btfs | head
total 864K
-rw-r--r-- 1 1000 1000 1,1K Feb 8 14:46 5.11.0-1007-azure.btf
-rw-r--r-- 1 1000 1000 1,1K Feb 8 14:46 5.11.0-1009-aws.btf
-rw-r--r-- 1 1000 1000 1,1K Feb 8 14:46 5.11.0-1009-gcp.btf
-rw-r--r-- 1 1000 1000 1,1K Feb 8 14:46 5.11.0-1012-azure.btf
-rw-r--r-- 1 1000 1000 1,1K Feb 8 14:46 5.11.0-1013-azure.btf
-rw-r--r-- 1 1000 1000 1,1K Feb 8 14:46 5.11.0-1014-aws.btf
-rw-r--r-- 1 1000 1000 1,1K Feb 8 14:46 5.11.0-1014-gcp.btf
-rw-r--r-- 1 1000 1000 1,1K Feb 8 14:46 5.11.0-1015-azure.btf
-rw-r--r-- 1 1000 1000 1,1K Feb 8 14:46 5.11.0-1016-aws.btf</code></pre></div>
<p>精简后生成的 BTF 文件大约为 1.1KB，Ubuntu Focal 对应的所有文件的大小为 864KB，将其与程序一起打包完全可行。</p>
<p>如果我们对生成的文件进一步进行压缩，其大小还可以大幅缩减：</p>
<div><pre class="hljs"><code>$ <span class="hljs-built_in">cd</span> /tmp/btfgendemo/btfs
$ tar cvfJ compressed.tar.xz *.btf
$ ls -lhn compressed.tar.xz
-rw-r--r-- 1 1000 1000 2,5K Feb 17 15:19 compressed.tar.xz</code></pre></div>
<p>压缩率如此之高是因为许多生成的文件相同，我们将在下文中进一步讨论。</p>
<h4 id="验证">验证</h4>
<p>为了验证，我们需要运行一台装有 Ubuntu Focal 的机器。这里提供的 Vagrant 文件可以用来创建对应的虚拟机。请注意，Ubuntu Focal 从内核 5.4.0-92-generic 版本开始启用 BTF 支持，所以我们需要运行其早期的版本进行验证。我们使用 <code>bento/ubuntu-20.04 Vagrant</code> 虚拟机中的 <code>202012.21.0</code> 版本，内核为 5.4.0-58-generic。</p>
<p>本文使用 <code>sshfs</code> 在主机和虚拟机之间共享文件，需要我们确保已经安装了 <a title="https://github.com/dustymabe/vagrant-sshfs" href="https://github.com/dustymabe/vagrant-sshfs">vagrant-sshfs</a> 插件。</p>
<div><pre class="hljs"><code>$ sudo vagrant plugin install vagrant-sshfs</code></pre></div>
<div><pre class="hljs"><code><span class="hljs-comment"># /tmp/btfgendemo/Vagrantfile</span>
Vagrant.configure(<span class="hljs-string">"2"</span>) <span class="hljs-keyword">do</span> | config |
  config.vm.box = <span class="hljs-string">"bento/ubuntu-20.04"</span>
  config.vm.box_version = <span class="hljs-string">"= 202012.21.0"</span>
  config.vm.synced_folder <span class="hljs-string">"/tmp/btfgendemo"</span>, <span class="hljs-string">"/btfgendemo"</span>, <span class="hljs-built_in">type</span>: <span class="hljs-string">"sshfs"</span>

  config.vm.provider <span class="hljs-string">"virtualbox"</span> <span class="hljs-keyword">do</span> | vb |
    vb.gui = <span class="hljs-literal">false</span>
    vb.cpus = 4
    vb.memory = <span class="hljs-string">"4096"</span>
  end
end</code></pre></div>
<p>启动虚拟机并使用 ssh 登录：</p>
<div><pre class="hljs"><code>$ vagrant up
$ vagrant ssh</code></pre></div>
<p>后续的命令必须在虚拟机内执行。检查内核版本：</p>
<div><pre class="hljs"><code>$ uname -a
Linux vagrant 5.4.0-58-generic <span class="hljs-comment">#64-Ubuntu SMP Wed Dec 9 08:16:25 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span>
</code></pre></div>
<p>让我们检查内核是否启用了<code>CONFIG_DEBUG_INFO_BTF</code>：</p>
<div><pre class="hljs"><code>$ cat /boot/config-$(uname -r) | grep CONFIG_DEBUG_INFO_BTF
CONFIG_DEBUG_INFO_BTF is not <span class="hljs-built_in">set</span></code></pre></div>
<p>在把 BTF 文件复制到正确路径之前，我们尝试运行以下这些工具：</p>
<div><pre class="hljs"><code>$ sudo /btfgendemo/bcc/libbpf-tools/execsnoop
libbpf: failed to parse target BTF: -2
libbpf: failed to perform CO-RE relocations: -2
libbpf: failed to load object <span class="hljs-string">'execsnoop_bpf'</span>
libbpf: failed to load BPF skeleton <span class="hljs-string">'execsnoop_bpf'</span>: -2
failed to load BPF object: -2</code></pre></div>
<p>正如预期，我们运行工具失败，因为工具不能找到执行 CO-RE 重定位所需的 BTF 信息。</p>
<p>接着，我们将该内核版本的 BTF 文件复制到对应目录：</p>
<div><pre class="hljs"><code>$ cp /btfgendemo/btfs/$(uname -r).btf /tmp/vmlinux.btf</code></pre></div>
<p>将复制 BTF 到指定目录后，工具运行正常：</p>
<div><pre class="hljs"><code>
$ sudo /btfgendemo/bcc/libbpf-tools/execsnoop
PCOMM PID PPID RET ARGS
^C

$ sudo /btfgendemo/bcc/libbpf-tools/bindsnoop
PID COMM RET PROTO OPTS IF PORT ADDR
^C

$ sudo /btfgendemo/bcc/libbpf-tools/opensnoop
PID COMM FD ERR PATH
^C</code></pre></div>
<p>当然这只是为了演示工具工作流程的样例。真正的集成需要负责基于主机的内核版本自动提供对应的 BTF 文件。下面的部分通过两个例子展示了对应的集成。</p>
<h3 id="43-集成样例">4.3 集成样例</h3>
<p>在本节中，我们将介绍 Inspektor Gadget 和 Tracee 项目是如何使用 BTFGen。</p>
<h4 id="inspektor-gadget">Inspektor Gadget</h4>
<p><a title="https://github.com/kinvolk/inspektor-gadget" href="https://github.com/kinvolk/inspektor-gadget">Inspektor Gadget</a> 是一个用于调试/检查 Kubernetes 资源和应用程序的工具集。由于Inspektor Gadget 是以容器镜像的形式发布的，我们选择在其中为不同的 Linux发行版搭载 BTF 文件。我们在 Docker 文件中添加了一个<a title="https://github.com/kinvolk/inspektor-gadget/blob/v0.4.2/gadget.Dockerfile#L42-L46" href="https://github.com/kinvolk/inspektor-gadget/blob/v0.4.2/gadget.Dockerfile#L42-L46">步骤</a>，使其可以在构建容器镜像时生成 BTF 文件：</p>
<div><pre class="hljs"><code>RUN <span class="hljs-built_in">set</span> -ex; \
    <span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">$ENABLE_BTFGEN</span>"</span> = <span class="hljs-literal">true</span> ]; <span class="hljs-keyword">then</span> \
        <span class="hljs-built_in">cd</span> /btf-tools &amp;&amp; \
        LIBBPFTOOLS=/objs BTFHUB=/tmp/btfhub INSPEKTOR_GADGET=/gadget ./btfgen.sh; \
    <span class="hljs-keyword">fi</span></code></pre></div>
<p>辅助脚本 <a title="https://github.com/kinvolk/inspektor-gadget/blob/v0.4.2/tools/btfgen.sh" href="https://github.com/kinvolk/inspektor-gadget/blob/v0.4.2/tools/btfgen.sh">btfgen.sh</a> 调用 bpftool 为 BTFHub 支持的所有内核生成 BTF 文件。</p>
<p>我们修改 <a title="https://github.com/kinvolk/inspektor-gadget/blob/v0.4.2/gadget-container/entrypoint.sh#L149-L154" href="https://github.com/kinvolk/inspektor-gadget/blob/v0.4.2/gadget-container/entrypoint.sh#L149-L154">entrypoint</a> 脚本，在容器文件系统上安装正确的 BTF 文件，使对应的工具都能运行。Inspektor 工具被设计成总是在容器中运行，因此我们可以将 BTF 文件安装在系统路径（<code>/boot/vmlinux-$(uname -r)</code>），而不影响主机。通过这样做，我们还可以避免修改不同的 BCC 工具的源代码（就像我们在上面的例子中做的那样）：</p>
<div><pre class="hljs"><code>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"Kernel provided BTF is not available: Trying shipped BTF files"</span>
SOURCE_BTF=/btfs/<span class="hljs-variable">$ID</span>/<span class="hljs-variable">$VERSION_ID</span>/<span class="hljs-variable">$ARCH</span>/<span class="hljs-variable">$KERNEL</span>.btf
<span class="hljs-keyword">if</span> [-f <span class="hljs-variable">$SOURCE_BTF</span>]; <span class="hljs-keyword">then</span>
        objcopy --input binary --output elf64-little --rename-section .data=.BTF <span class="hljs-variable">$SOURCE_BTF</span> /boot/vmlinux-<span class="hljs-variable">$KERNEL</span>
        <span class="hljs-built_in">echo</span> <span class="hljs-string">"shipped BTF available. Installed at /boot/vmlinux-<span class="hljs-variable">$KERNEL</span>"</span>
<span class="hljs-keyword">else</span>
...</code></pre></div>
<p>PR 完整实现参见 <a title="https://github.com/kinvolk/inspektor-gadget/pull/387" href="https://github.com/kinvolk/inspektor-gadget/pull/387">inspektor-gadget/pull/387</a></p>
<h4 id="tracee">Tracee</h4>
<p><a title="https://github.com/aquasecurity/tracee" href="https://github.com/aquasecurity/tracee">Tracee</a> 是用于 Linux 的运行时安全和取证工具。这里，生成的 BTF 文件可被嵌入到应用程序的二进制文件中。Makefile 有一个 <a title="https://github.com/aquasecurity/tracee/blob/add1efa7934dcf46be67ea2be54ac0d139a94804/Makefile.one#L507" href="https://github.com/aquasecurity/tracee/blob/add1efa7934dcf46be67ea2be54ac0d139a94804/Makefile.one#L507">btfhub</a> 目标，然后调用 <a title="https://github.com/aquasecurity/tracee/blob/add1efa7934dcf46be67ea2be54ac0d139a94804/3rdparty/btfhub.sh#L1" href="https://github.com/aquasecurity/tracee/blob/add1efa7934dcf46be67ea2be54ac0d139a94804/3rdparty/btfhub.sh#L1">btfhub.sh</a>。脚本克隆 BTFHub 仓库，并调用<a title="https://github.com/aquasecurity/tracee/blob/add1efa7934dcf46be67ea2be54ac0d139a94804/3rdparty/btfhub.sh#L112" href="https://github.com/aquasecurity/tracee/blob/add1efa7934dcf46be67ea2be54ac0d139a94804/3rdparty/btfhub.sh#L112">btfgen.sh</a>  来生成 BTF 文件。这些文件被移到 ./dist/btfhub 目录中。</p>
<div><pre class="hljs"><code><span class="hljs-comment"># generate tailored BTFs</span>

[ ! -f ./tools/btfgen.sh ] &amp;&amp; die <span class="hljs-string">"could not find btfgen.sh"</span>
./tools/btfgen.sh -a <span class="hljs-variable">${ARCH}</span> -o <span class="hljs-variable">$TRACEE_BPF_CORE</span>

<span class="hljs-comment"># move tailored BTFs to dist</span>

[ ! -d <span class="hljs-variable">${BASEDIR}</span>/dist ] &amp;&amp; die <span class="hljs-string">"could not find dist directory"</span>
[ ! -d <span class="hljs-variable">${BASEDIR}</span>/dist/btfhub ] &amp;&amp; mkdir <span class="hljs-variable">${BASEDIR}</span>/dist/btfhub

rm -rf <span class="hljs-variable">${BASEDIR}</span>/dist/btfhub/*
mv ./custom-archive/* <span class="hljs-variable">${BASEDIR}</span>/dist/btfhub</code></pre></div>
<p>然后，使用 <a title="https://github.com/aquasecurity/tracee/blob/add1efa7934dcf46be67ea2be54ac0d139a94804/embedded-ebpf.go#L11" href="https://github.com/aquasecurity/tracee/blob/add1efa7934dcf46be67ea2be54ac0d139a94804/embedded-ebpf.go#L11">go:embed</a> 指令将 BTF 文件嵌入到 Go 二进制中。</p>
<div><pre class="hljs"><code><span class="hljs-comment">//go:build ebpf</span>
<span class="hljs-comment">// +build ebpf</span>

<span class="hljs-keyword">package</span> tracee

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"embed"</span>
)

<span class="hljs-comment">//go:embed "dist/tracee.bpf.core.o"</span>
<span class="hljs-comment">//go:embed "dist/btfhub/*"</span>

<span class="hljs-keyword">var</span> BPFBundleInjected embed.FS</code></pre></div>
<p>在运行时，当前内核的对应的 BTF文件被<a title="https://github.com/aquasecurity/tracee/blob/add1efa7934dcf46be67ea2be54ac0d139a94804/cmd/tracee-ebpf/main.go#L367" href="https://github.com/aquasecurity/tracee/blob/add1efa7934dcf46be67ea2be54ac0d139a94804/cmd/tracee-ebpf/main.go#L367">解压</a>，其路径传递给 <a title="https://github.com/aquasecurity/tracee/blob/add1efa7934dcf46be67ea2be54ac0d139a94804/cmd/tracee-ebpf/main.go#L373" href="https://github.com/aquasecurity/tracee/blob/add1efa7934dcf46be67ea2be54ac0d139a94804/cmd/tracee-ebpf/main.go#L373">libbpf-go</a>，用于 CO-RE 重定位。</p>
<h3 id="44-限制">4.4 限制</h3>
<p>内核中的 BTF 支持不仅仅是关于导出 BTF 类型。部分 eBPF 程序如 fentry/fexit 和 LSM 钩子需要内核导出 BTF 信息。这些程序将不能使用 BTFGen，唯一的选择是启用 CONFIG_DEBUG_INFO_BTF 的内核。</p>
<h3 id="45-未来发展">4.5 未来发展</h3>
<p>当然，我们知道 BTFGen 是一个临时的解决方案，直到大多数系统更新到默认导出 BTF 信息的内核版本。然而，我们认为这需要几年的时间，在这期间，BTFGen 可以帮助填补这一空白。</p>
<p>以下是我们可以近期考虑的一些改进。</p>
<h4 id="与其他项目的整合">与其他项目的整合</h4>
<p>部分项目如 BCC 及其基于 libbpf 的工具都可以与 BTFGen 整合获益。 我们提交了一个 <a title="https://github.com/iovisor/bcc/pull/3889" href="https://github.com/iovisor/bcc/pull/3889">PR</a>，通过使用 BTFGen 使上述工具可以在更多的 Linux 发行版中使用。</p>
<h4 id="删除重复的文件">删除重复的文件</h4>
<p>eBPF 程序通常访问很少的内核类型，因此，两个不同的内核版本生成的文件很有可能是相同的，这对于同一 Linux 发行版的小版本内核来说尤其如此。对 BTFGen 的进一步改进是基于此，通过使用符号链接或类似的方法来避免创建重复的文件。</p>
<p>这也可以直接在 BTFHub 上进行，因为有些源 BTF 文件是重复的，就像<a title="https://github.com/aquasecurity/btfhub/issues/17" href="https://github.com/aquasecurity/btfhub/issues/17">这个</a>问题中所指出的那样，但即使在这种情况下，出现重复文件的机会还是较低。</p>
<h4 id="在线-api">在线 API</h4>
<p>BTFHub 仓库体积很大，而且由于新内核的发布，它的规模还在不断增加。Seekret 创建了一个 <a title="https://github.com/seek-ret/btfhub-online" href="https://github.com/seek-ret/btfhub-online">API</a>，使用 BTFGen 和 BTFHub 为用户提供的 eBPF 对象按需生成 “精简版” BTF 文件。</p>
<h2 id="5-更多信息">5. 更多信息</h2>
<p>如果你想了解更多关于 eBPF、BTF、CO-RE、BTFHub 和 BTFGen 的信息，以下资料无疑是优秀的参考：</p>
<ul>
<li><a title="https://nakryiko.com/posts/bpf-core-reference-guide/" href="https://nakryiko.com/posts/bpf-core-reference-guide/">BPF CO-RE参考指南</a>：从开发者的角度解释了如何使用 CO-RE。</li>
<li><a title="https://nakryiko.com/posts/bpf-portability-and-co-re/" href="https://nakryiko.com/posts/bpf-portability-and-co-re/">BPF CO-RE (Compile Once - Run Everywhere)</a>：解释了 CO-RE和该机制中涉及的不同组件。</li>
<li><a title="https://github.com/aquasecurity/btfhub/blob/main/docs/btfgen-internals.md" href="https://github.com/aquasecurity/btfhub/blob/main/docs/btfgen-internals.md">eBPF BTF 生成器：通往真正的可移植 CO-RE eBPF 程序之路</a>：深入探讨 BTFGen 的实现。</li>
<li><a title="https://www.kernel.org/doc/html/latest/bpf/btf.html" href="https://www.kernel.org/doc/html/latest/bpf/btf.html">BPF类型格式(BTF)</a>：BTF的内核文档。</li>
</ul>
<h2 id="6-致谢">6. 致谢</h2>
<p>功能从已经存在的项目中获得了灵感，并由不同的公司联合实现。</p>
<p>首先，我们要感谢 Aqua Security 团队在 BTFHub 上所做的出色工作，这是我们的基础项目。</p>
<p>其次，我们要感谢在这个功能的开发过程中做出贡献的人员。Aqua Security 的 Rafael David Tinoco 和 Elastic 的 Lorenzo Fontana 和 Leonardo Di Donato。</p>
<p>最后，libbpf 的维护者 Andrii Nakryiko 和 Alexei Starovoitov 以及 bpftool 的维护者 Quentin Monnet，他们为实现该功能提供了大量宝贵的反馈和指导。</p>
<blockquote>
<p>原文作者：DavidDi<br />
原文链接：<a title="https://www.ebpf.top/post/btfgen-one-step-closer-to-truly-portable-ebpf-programs/" href="https://www.ebpf.top/post/btfgen-one-step-closer-to-truly-portable-ebpf-programs/">https://www.ebpf.top/post/btfgen-one-step-closer-to-truly-portable-ebpf-programs/</a><br />
版权声明：本作品采用知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</p>
</blockquote>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[eBPF总结]]></title>
            <guid>6659d0caaa3a4ab6a39850daca737519</guid>
            <pubDate>Wed, 21 Dec 2022 05:54:20 GMT</pubDate>
            <content:encoded><![CDATA[<p>我希望这篇简短的报告能让你了解 eBPF 以及它为何如此强大。我真正希望的是你已经准备好自己尝试一些基于 eBPF 的工具了！</p>
<p>如果你想更深入地了解技术方面，一个不错的起点是 <a title="https://ebpf.io/" href="https://ebpf.io/">ebpf.io</a>，你可以在其中找到更多有关该技术和 eBPF 基金会的信息。对于编程示例，<a title="https://github.com/lizrice/ebpf-beginners" href="https://github.com/lizrice/ebpf-beginners">我的 GitHub 上的 ebpf-beginners 存储库</a> 中有一些资源。</p>
<p>要了解其他人如何利用 eBPF 工具，可以参加 <a title="https://twitter.com/ebpfsummit" href="https://twitter.com/ebpfsummit">eBPF 峰会</a> 和 <a title="https://events.linuxfoundation.org/cloud-native-ebpf-day-europe/" href="https://events.linuxfoundation.org/cloud-native-ebpf-day-europe/">云原生 eBPF Day</a> 等活动 ，用户在这里分享他们的成功案例和学习经验。你可以从 <a title="https://ebpf.io/slack" href="https://ebpf.io/slack">ebpf.io/slack</a> 访问一个活动的 Slack 频道。 我希望能在那里看到你！</p>
]]></content:encoded>
        </item>
    </channel>
</rss>