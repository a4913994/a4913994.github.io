<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title></title>
        <link>undefined</link>
        <description>undefined</description>
        <lastBuildDate>Tue, 11 Apr 2023 14:13:20 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>Joplin Pages Publisher</generator>
        <item>
            <title><![CDATA[嵌入式时间序列数据库的具体时间]]></title>
            <guid>d13a4eb729314e1bb452bd2842e9f785</guid>
            <pubDate>Tue, 11 Apr 2023 13:54:46 GMT</pubDate>
            <content:encoded><![CDATA[<p>Here's an example of a simple embedded time series database using BoltDB as the storage engine in a Golang program:</p>
<ol>
<li>First, install the BoltDB package:</li>
</ol>
<div><pre class="hljs"><code>go get github.com/boltdb/bolt</code></pre></div>
<ol start="2">
<li>Create a new file, timeseries.go, and import the required packages:</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"bytes"</span>
    <span class="hljs-string">"encoding/binary"</span>
    <span class="hljs-string">"encoding/gob"</span>
    <span class="hljs-string">"log"</span>
    <span class="hljs-string">"time"</span>

    <span class="hljs-string">"github.com/boltdb/bolt"</span>
)</code></pre></div>
<ol start="3">
<li>Define the data structures for the time series data point:</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-keyword">type</span> DataPoint <span class="hljs-keyword">struct</span> {
    Timestamp time.Time
    Value     <span class="hljs-keyword">float64</span>
}</code></pre></div>
<ol start="4">
<li>Initialize the BoltDB database:</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initDB</span><span class="hljs-params">()</span> *<span class="hljs-title">bolt</span>.<span class="hljs-title">DB</span></span> {
    db, err := bolt.Open(<span class="hljs-string">"timeseries.db"</span>, <span class="hljs-number">0600</span>, <span class="hljs-literal">nil</span>)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        log.Fatal(err)
    }
    <span class="hljs-keyword">return</span> db
}</code></pre></div>
<ol start="5">
<li>Create a bucket for storing time series data:</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createBucket</span><span class="hljs-params">(db *bolt.DB, bucketName <span class="hljs-keyword">string</span>)</span></span> {
    err := db.Update(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(tx *bolt.Tx)</span> <span class="hljs-title">error</span></span> {
        _, err := tx.CreateBucketIfNotExists([]<span class="hljs-keyword">byte</span>(bucketName))
        <span class="hljs-keyword">return</span> err
    })

    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        log.Fatal(err)
    }
}</code></pre></div>
<ol start="6">
<li>Implement the <code>writeDataPoint</code> function:</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeDataPoint</span><span class="hljs-params">(db *bolt.DB, bucketName <span class="hljs-keyword">string</span>, dataPoint DataPoint)</span></span> {
    err := db.Update(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(tx *bolt.Tx)</span> <span class="hljs-title">error</span></span> {
        b := tx.Bucket([]<span class="hljs-keyword">byte</span>(bucketName))

        <span class="hljs-comment">// Serialize the DataPoint</span>
        buf := bytes.NewBuffer(<span class="hljs-literal">nil</span>)
        err := gob.NewEncoder(buf).Encode(dataPoint)
        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
            <span class="hljs-keyword">return</span> err
        }

        <span class="hljs-comment">// Write the serialized DataPoint to the bucket</span>
        key := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">8</span>)
        binary.BigEndian.PutUint64(key, <span class="hljs-keyword">uint64</span>(dataPoint.Timestamp.UnixNano()))
        <span class="hljs-keyword">return</span> b.Put(key, buf.Bytes())
    })

    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        log.Fatal(err)
    }
}</code></pre></div>
<ol start="7">
<li>Implement the <code>readDataPoints</code> function:</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readDataPoints</span><span class="hljs-params">(db *bolt.DB, bucketName <span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">DataPoint</span></span> {
    <span class="hljs-keyword">var</span> dataPoints []DataPoint

    err := db.View(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(tx *bolt.Tx)</span> <span class="hljs-title">error</span></span> {
        b := tx.Bucket([]<span class="hljs-keyword">byte</span>(bucketName))

        c := b.Cursor()
        <span class="hljs-keyword">for</span> k, v := c.First(); k != <span class="hljs-literal">nil</span>; k, v = c.Next() {
            <span class="hljs-keyword">var</span> dataPoint DataPoint
            err := gob.NewDecoder(bytes.NewReader(v)).Decode(&amp;dataPoint)
            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
                <span class="hljs-keyword">return</span> err
            }
            dataPoints = <span class="hljs-built_in">append</span>(dataPoints, dataPoint)
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
    })

    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        log.Fatal(err)
    }

    <span class="hljs-keyword">return</span> dataPoints
}</code></pre></div>
<ol start="8">
<li>Use the database in the <code>main</code> function:</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    db := initDB()
    <span class="hljs-keyword">defer</span> db.Close()

    bucketName := <span class="hljs-string">"timeseries"</span>

    createBucket(db, bucketName)

    dataPoint := DataPoint{
        Timestamp: time.Now(),
        Value:     <span class="hljs-number">42.0</span>,
    }
    writeDataPoint(db, bucketName, dataPoint)

    dataPoints := readDataPoints(db, bucketName)
    log.Println(dataPoints)
}</code></pre></div>
<p>This example demonstrates a very basic embedded time series database in Golang using BoltDB. You can extend this code to implement more advanced features like data partitioning, indexing, querying capabilities, and data management strategies as needed.</p>
<h2 id="索引的设计">索引的设计</h2>
<p>为时间序列数据库设计索引有助于提高数据检索效率和查询性能。在提供的使用BoltDB的示例中，您可以使用时间戳本身作为键，这已经提供了一种简单的索引形式。然而，如果你需要更高级的索引策略，你可以考虑以下方法:</p>
<ol>
<li>Time-based partitioning:<br />
根据时间戳将时间序列数据划分为更小的分区或bucket。每个分区可以表示一个固定的时间范围，例如一个小时、一天或一周。将每个分区单独存储在一个BoltDB桶中，可以提高数据的组织性和查询性能。</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partitionKey</span><span class="hljs-params">(timestamp time.Time)</span> <span class="hljs-title">string</span></span> {
    <span class="hljs-comment">// Example: create partitions by day</span>
    <span class="hljs-keyword">return</span> timestamp.Format(<span class="hljs-string">"2006-01-02"</span>)
}</code></pre></div>
<ol start="2">
<li>Secondary indexing:<br />
如果时间序列数据具有附加属性，例如标记或标签，则可以创建辅助索引以加快基于这些属性的查询速度。要实现二级索引，您可以创建额外的BoltDB桶来存储对主数据点的引用。</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeSecondaryIndex</span><span class="hljs-params">(db *bolt.DB, indexBucketName <span class="hljs-keyword">string</span>, dataPointKey []<span class="hljs-keyword">byte</span>, indexValue <span class="hljs-keyword">string</span>)</span></span> {
    err := db.Update(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(tx *bolt.Tx)</span> <span class="hljs-title">error</span></span> {
        b := tx.Bucket([]<span class="hljs-keyword">byte</span>(indexBucketName))

        <span class="hljs-comment">// Store the data point key with the index value</span>
        <span class="hljs-keyword">return</span> b.Put([]<span class="hljs-keyword">byte</span>(indexValue), dataPointKey)
    })

    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        log.Fatal(err)
    }
}</code></pre></div>
<ol start="3">
<li>Time-based indexing:<br />
创建一个额外的索引，以加快需要特定时间范围或聚合的查询。例如，您可以创建一个索引来存储每个分区的最小值、最大值或平均值。这有助于加快需要在给定时间范围内计算汇总统计信息的查询。</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-keyword">type</span> TimeRangeSummary <span class="hljs-keyword">struct</span> {
    Min <span class="hljs-keyword">float64</span>
    Max <span class="hljs-keyword">float64</span>
    Avg <span class="hljs-keyword">float64</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeTimeRangeIndex</span><span class="hljs-params">(db *bolt.DB, indexBucketName <span class="hljs-keyword">string</span>, partitionKey <span class="hljs-keyword">string</span>, summary TimeRangeSummary)</span></span> {
    err := db.Update(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(tx *bolt.Tx)</span> <span class="hljs-title">error</span></span> {
        b := tx.Bucket([]<span class="hljs-keyword">byte</span>(indexBucketName))

        <span class="hljs-comment">// Serialize the summary</span>
        buf := bytes.NewBuffer(<span class="hljs-literal">nil</span>)
        err := gob.NewEncoder(buf).Encode(summary)
        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
            <span class="hljs-keyword">return</span> err
        }

        <span class="hljs-comment">// Write the serialized summary to the index bucket</span>
        <span class="hljs-keyword">return</span> b.Put([]<span class="hljs-keyword">byte</span>(partitionKey), buf.Bytes())
    })

    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        log.Fatal(err)
    }
}</code></pre></div>
<ol start="4">
<li>Updating and maintaining indexes:<br />
在添加新数据点或修改现有数据点时，请确保相应更新相应的索引。这可能需要更新二级索引或基于时间的索引结构，例如时间范围摘要统计信息。</li>
</ol>
<p>记住，建立索引是有代价的。虽然它可以显著提高查询性能，但也会增加数据库设计的复杂性，并增加写入操作的开销。必须分析应用程序的查询模式和需求，以确定最合适的索引策略。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[如何设计嵌入式时间序列数据库]]></title>
            <guid>e51232f5bfe94e348d8ed41115243834</guid>
            <pubDate>Tue, 11 Apr 2023 13:48:29 GMT</pubDate>
            <content:encoded><![CDATA[<p>在Golang程序中设计嵌入式时间序列数据库涉及一系列步骤，从选择合适的存储引擎到实现数据管理策略。下面是一个高级指南，帮助您在Golang中设计和实现嵌入式时间序列数据库:</p>
<ul>
<li>
<p>选择存储引擎: 对于嵌入式时间序列数据库，可以考虑使用嵌入式键值存储引擎，如BoltDB、Badger或LevelDB。这些引擎轻量级、快速且易于集成到Golang应用程序中。</p>
</li>
<li>
<p>定义数据模型: 设计一个有效地表示时间序列数据的数据模型。使用<code>structs</code>或<code>protobuf</code>这样的结构来定义数据模式。考虑使用时间戳作为键，使用序列化的数据点作为值，以实现高效的存储和检索。</p>
</li>
<li>
<p>设置存储引擎:</p>
<ul>
<li>将选择的存储引擎库导入到Golang程序中。</li>
<li>配置和初始化存储引擎，创建数据库实例。</li>
<li>实现打开、关闭和管理数据库连接的方法。</li>
</ul>
</li>
<li>
<p>实现数据存储和检索:</p>
<ul>
<li>创建从存储引擎写入和读取数据点的方法。</li>
<li>使用编码技术(如协议缓冲区、JSON或MessagePack)序列化和反序列化数据点。</li>
<li>使用批写和压缩优化存储和写性能。</li>
</ul>
</li>
<li>
<p>设计索引和分区:</p>
<ul>
<li>通过根据数据点的时间戳将数据点分组到桶中，实现基于时间的分区。</li>
<li>创建索引以实现高效的数据检索和查询。</li>
<li>利用存储引擎的内置索引功能或实现自定义索引解决方案。</li>
</ul>
</li>
<li>
<p>实现查询功能:</p>
<ul>
<li>设计一个简单的查询API或语言来与时间序列数据交互。</li>
<li>实现过滤、聚合和基于时间的操作的查询功能。</li>
<li>使用缓存、物化视图或预计算聚合优化查询性能。</li>
</ul>
</li>
<li>
<p>数据管理策略:</p>
<ul>
<li>实现数据保留策略，自动删除旧数据点或downsample数据，节省存储空间。</li>
<li>使用数据压缩技术可以减小存储空间大小并提高性能。</li>
</ul>
</li>
<li>
<p>测试和基准测试:</p>
<ul>
<li>为所有主要功能编写测试，以确保嵌入式时间序列数据库的正确性和可靠性。</li>
<li>对时间序列数据库的性能进行基准测试，以确定潜在的瓶颈和需要改进的领域。</li>
</ul>
</li>
</ul>
<p>通过执行这些步骤，您可以在Golang程序中设计和实现高效的嵌入式时间序列数据库。确保持续监控、优化和维护数据库，以确保其可靠性和性能</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[如何大规模配置裸机电信云平台]]></title>
            <guid>df4af15487b943e5938ac6f9cfc97490</guid>
            <pubDate>Wed, 01 Feb 2023 16:39:35 GMT</pubDate>
            <content:encoded><![CDATA[<blockquote>
<p>使用通过 OpenShift 实施的 Kubernetes 大规模通过和配置裸机集群。</p>
</blockquote>
<p>自动化系统供应对于 IT 或网络系统管理员来说至关重要。许多技术和标准试图解决这个问题；有些是供应商中立的，有些是特定于供应商的。后者在无线网络中尤其如此，其中每个网络设备提供商都需要其关联的元素/网络管理系统来控制其网络元素。</p>
<p>鉴于无线电接入网络 (RAN) 分解和解聚的兴起，Open RAN 等标准机构专注于定义 RAN 组件无线电单元 (RU)、分布式单元 (DU) 和中央单元 (CU) 之间的可互操作接口。与此同时，在 O-RAN 联盟的领导下，行业推动 RAN 组件虚拟化和云化，因此它们的生命周期可以独立于运行它们的平台进行管理。这种由商用现成 (COTS) 服务器组成的平台需要高度配置才能发挥 5G 的优势。</p>
<p><img src="/_resources/480c1db4ac474a9fad80ca3db516e577.png" /></p>
<center style="font-size:14px;color:#C0C0C0;text-decoration:underline" class="jop-noMdConv">Alexis de Talhouët &amp; Federico Rossi, CC BY-SA 4.0</center>
<p>这带来的挑战之一是大规模供应和配置该平台的能力；一个电信服务提供商可能有数千个 RAN 部署。该平台包括服务器和管理程序或容器编排系统。</p>
<p>本文将使用OpenShift实现的容器编排系统Kubernetes；特别是 Red Hat OpenShift 4.11。</p>
<h2 id="解决方案概述">解决方案概述</h2>
<p>与 Red Hat 和合作伙伴一起部署云原生 5G 开放式 RAN 提出了要求和高级方法。它包含三个主要元素：</p>
<ul>
<li>用于大规模部署的云原生平台</li>
<li>GitOps 的自动化和操作</li>
<li>蓬勃发展的合作伙伴生态系统</li>
</ul>
<p>该解决方案旨在通过利用 Red Hat OpenShift 提供的一组广为采用的通用 API（无论是在中央、区域还是边缘区域）在整个环境中提供相同的管理、操作和用户体验。该水平平台不一定是一个实例，而是一组共同管理的实例。</p>
<p>这些 RAN 部署模型使用一个管理环境来控制其他模型，将它们视为牛而不是宠物。它被称为管理集群或中心集群。远程环境称为托管集群。</p>
<p>下图描述了由 Red Hat Advanced Cluster Management (RHACM) 启用的中央实体如何配置和操作由以下任何一项组成的远程环境：</p>
<ul>
<li>一个完整的 OpenShift 集群（三个控制平面和至少两个计算节点）</li>
<li>一个紧凑的 OpenShift 集群（三个节点同时充当控制和计算）</li>
<li>由一个节点组成的单节点OpenShift</li>
<li>远程工作节点（远程连接到控制平面，托管在管理集群中，或远程）</li>
</ul>
<p><img src="/_resources/95b6c8a6deb2409da084e89c743082a2.png" /></p>
<p>最后，要定义一次，随处部署，并持续协调运行状态与真实来源，请遵循 GitOps 方法，例如 Red Hat OpenShift GitOps。</p>
<p>大规模采用 GitOps 存在不同的实施模型，但这些不是本文的主题。</p>
<p><img src="/_resources/84aa23769b3640ce89928c8fb45f5958.png" /></p>
<h2 id="远程裸机集群生命周期管理">远程裸机集群生命周期管理</h2>
<p>OpenStack 社区首先通过 Ironic 项目解决了这一需求。目标是通过通用（预引导执行环境 [PXE] 和智能平台管理接口 [IPMI]）和特定于供应商的远程管理协议（底板管理控制器 [BMC]）来管理硬件。该项目成为 <a title="https://metal3.io/" href="https://metal3.io/">Metal3</a> 的垫脚石，为 Kubernetes 启用了此类功能。</p>
<p>使用<a title="https://console.redhat.com/openshift/assisted-installer/clusters" href="https://console.redhat.com/openshift/assisted-installer/clusters">红帽 SaaS 辅助安装程序平台</a>在红帽混合云控制台上部署第一个集群非常简单，即使您使用自己的映像注册表也是如此。阅读<a title="https://cloud.redhat.com/blog/making-openshift-on-bare-metal-easy" href="https://cloud.redhat.com/blog/making-openshift-on-bare-metal-easy">使裸机上的 OpenShift 变得简单</a>，以全面了解该过程。</p>
<p>主要要求是出站互联网访问；不需要入站连接。辅助安装程序是一项服务：</p>
<ul>
<li>允许基础架构管理员生成发现图像</li>
<li>发现基础架构管理员使用发现映像启动的主机</li>
<li>允许集群创建者从可用主机定义集群</li>
<li>在开始之前验证安装</li>
<li>监控装置</li>
<li>收集日志</li>
<li>发布指标供内部使用</li>
<li>允许集群创建者将主机添加到现有集群</li>
</ul>
<p>创建第一个集群后，您必须安装 RHACM 和 Red Hat OpenShift GitOps。接下来，您可以按照 GitOps 方法论来创建和配置后续集群。</p>
<p><a title="https://cloud.redhat.com/blog/zero-touch-provisioning-for-factory-workflows" href="https://cloud.redhat.com/blog/zero-touch-provisioning-for-factory-workflows">工厂工作流程的零接触配置</a>是了解启用裸机服务器远程配置以实现全自动集群安装的策略的好方法。它在引擎盖下使用 Metal3 并严重依赖 BMC 和配置接口 MAC 地址。</p>
<p>在高层次上，您将使用工厂集群部署一个独立的集群，如下所示：</p>
<ol>
<li>安装工厂集群：创建工厂集群（管理）创建OpenShift集群。</li>
<li>创建边缘集群：使用工厂集群在 OEM 硬件上创建完全可操作的 OpenShift 集群（辐射）。</li>
<li>配置边缘集群：在最终客户站点（边缘）解压并配置 OpenShift 集群。</li>
</ol>
<p>此外，RHACM 还提供站点规划和策略模板，支持大规模部署和配置集群。</p>
<p>在<a title="https://docs.openshift.com/container-platform/4.11/scalability_and_performance/ztp-deploying-disconnected.html" href="https://docs.openshift.com/container-platform/4.11/scalability_and_performance/ztp-deploying-disconnected.html">文档</a>中查找更多详细信息。</p>
<p><img src="/_resources/8c611371be344eb88c49de5a88b8fa5d.png" /></p>
<p>##. 拓扑感知生命周期管理</p>
<p>需要一个强大的基础设施生命周期管理工具来满足在整个生命周期内大规模管理基础设施的技术和业务需求。</p>
<p>它应该考虑以下几点：</p>
<ol>
<li>定义最低可用性要求的服务级别协议 (SLA)</li>
<li>需要逐步向队列推出的操作程序（例如，作为初始冒烟测试升级的金丝雀集群）</li>
<li>大规模自动化要求</li>
</ol>
<p>拓扑感知生命周期操作员 （TALO） 在操作环境中大规模管理这些事件。</p>
<p><a title="https://www.redhat.com/en/engage/discover-automating-edge-20220510?intcmp=7013a0000025wJwAAI" href="https://www.redhat.com/en/engage/discover-automating-edge-20220510?intcmp=7013a0000025wJwAAI">Automating the last mile: Ensuring consistency and scalability at the edge</a></p>
<p>一个示例用例是具有 RAN 覆盖范围的大型集群 （DU） 队列。更新分波次应用，以确保保持足够的 RAN 覆盖范围。SLA 指定覆盖区域内维护事件期间不可用群集的最大数量。</p>
<p><img src="/_resources/c3702dd1798242aebddf8376878c10df.png" /></p>
<ul>
<li>绿色和蓝色集群（集群组升级 [CGU] 1 和 CGU 2）配对以提供服务覆盖范围重叠。</li>
<li>操作程序规定可以更新三个集群（最多）。</li>
<li>CGU 1 以 3 个为批次更新绿色簇。</li>
<li>CGU 2 与 CGU 1 链接，并在 CGU 1 完成时以三个为一组更新蓝色集群。</li>
</ul>
<p>TALO 通过提供集成的备份和恢复（回滚）功能，将维护窗口期间的风险降至最低。此功能可创建升级前备份，并提供在升级失败时快速恢复单节点 OpenShift （SNO） 的过程。如果升级失败，此功能允许将 SNO 恢复到以前版本的 OpenShift 的工作状态，而无需重新配置应用程序。</p>
<p>群集升级需要在维护时段内完成。该窗口还需要包括解决失败升级的时间。必须将 OpenShift 版本工件下载到集群才能进行升级。某些群集托管注册表的中心群集的带宽可能有限，因此很难在所需时间内完成升级。在升级之前，群集上必须存在所需的项目，以确保升级适合维护时段。</p>
<p>为了实现这些操作过程，TALO 以声明性方式管理一个或多个 OpenShift 集群的 RHACM 策略部署。</p>
<h2 id="云原生平台配置">云原生平台配置</h2>
<p>该方法可以大规模部署和管理群集。查看每个群集的较低级别组件以启用性能调整。这些是构成上述政策的要素。</p>
<p>目标是使用 Kubernetes 资源模型完成 100% 的硬件配置，支持将预期配置声明为代码，并通过 GitOps 促进操作管理。</p>
<p>下图显示了节点操作系统和所有支持的运算符，启用了特定的节点配置。</p>
<p><img src="/_resources/fa48f03b23a94197ac92586764c46514.png" /></p>
<p>以下是5G核心网应用最重要的运营商：</p>
<ul>
<li><a title="https://docs.openshift.com/container-platform/4.11/nodes/nodes/nodes-node-tuning-operator.html" href="https://docs.openshift.com/container-platform/4.11/nodes/nodes/nodes-node-tuning-operator.html">Node Tuning Operator</a>可用于优化基础操作系统以减少延迟。它使用性能配置文件，并负责：
<ul>
<li>HugePages</li>
<li>Topology manager policy (NUMA)</li>
<li>CPU reservation and isolation</li>
<li>Power consumption scheme</li>
<li>Real-time kernel</li>
<li>Network interface controller (NIC) queues tuning (DPDK)</li>
<li>IRQ dynamic load-balancing</li>
</ul>
</li>
<li><a title="https://docs.openshift.com/container-platform/4.11/hardware_enablement/psap-special-resource-operator.html" href="https://docs.openshift.com/container-platform/4.11/hardware_enablement/psap-special-resource-operator.html">Special Resource Operator</a> 允许您加载特定的内核模块和设备驱动程序。此组件仍处于技术预览阶段，这意味着不应在生产中使用它。如果要使用它，建议获取指导。</li>
<li><a title="https://docs.openshift.com/container-platform/4.11/networking/k8s_nmstate/k8s-nmstate-about-the-k8s-nmstate-operator.html" href="https://docs.openshift.com/container-platform/4.11/networking/k8s_nmstate/k8s-nmstate-about-the-k8s-nmstate-operator.html">NMState Operator</a> 启用接口配置，无论其类型如何。它通常用于定义绑定接口以及 VLAN 子接口。</li>
<li><a title="https://docs.openshift.com/container-platform/4.11/networking/hardware_networks/about-sriov.html" href="https://docs.openshift.com/container-platform/4.11/networking/hardware_networks/about-sriov.html">SR-IOV Operator</a>允许通过 SriovNetworkNodePolicy 配置 SR-IOV 支持的网卡，该策略配置：
<ul>
<li>MTU</li>
<li>Number of VFs</li>
<li>NIC selector</li>
<li>Device type (whether vfio-pci or netdev)<br />
需要 SriovNetwork 才能使用创建的设备。这将产生一个 NetworkAttachmentDefinition，然后 Pod 可以通过注释使用该定义。</li>
</ul>
</li>
</ul>
<p>5G RAN 或其他类型的工作负载还有其他几个运营商，例如Precision Time Protocol Operator, Intel Device Plugin Operator, FEC Operator, NVIDIA GPU Operator, and Network Operator.。每个都旨在抽象特定于硬件的功能，并使用 Kubernetes 资源模型启用其配置。</p>
<p>注意：许多operator支持告警、监控、服务保障、远程管理、证书管理等。</p>
<p>按应用程序和基础架构类型定义性能配置文件是释放性能的关键。</p>
<p>下图是 DU 性能配置文件所需的运算符示例。</p>
<p><img src="/_resources/cb79ca5609c94a50b6850813dca7dd0b.png" /></p>
<h2 id="展望未来">展望未来</h2>
<p>大规模预置和配置裸机集群的能力现已成为现实。但其他挑战依然存在，包括：</p>
<ul>
<li>使用统一的管理平台观察所有这些环境进行操作</li>
<li>实现自主系统（平台和网络），促进服务水平保证的可持续性</li>
<li>用于无缝应用通信的多集群网络（跨中央和边缘集群的分布式 SBA 5G 核心网）</li>
<li>增强调度能力，实现可持续计算</li>
</ul>
<p>请继续关注更多信息。同时，请随时查看我们在 <a title="https://www.redhat.com/en/events/red-hat-kubecon-cloudnativecon-na-2022" href="https://www.redhat.com/en/events/red-hat-kubecon-cloudnativecon-na-2022">KubeCon NA 2022</a> 上完成和展示的一些进展。</p>
<p><a title="https://www.redhat.com/architect/cloud-provisioning-scale" href="https://www.redhat.com/architect/cloud-provisioning-scale">原文连接</a></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[6. 文档系统 ---- 关于结构]]></title>
            <guid>02ed0149cb0a4c5b865364a20e2fd29d</guid>
            <pubDate>Tue, 31 Jan 2023 16:31:31 GMT</pubDate>
            <content:encoded><![CDATA[<h2 id="为什么这不明显">为什么这不明显？</h2>
<p>这种结构很清晰，也很有效，但它不那么明显是有原因的，那就是文档的每个象限的特征与方案中相邻象限的特征重叠的方式。</p>
<p><img src="/_resources/c0b13b70118040068123301e5f90ba40.png" /></p>
<p>每个象限都与其相邻的两个象限相似：</p>
<ul>
<li>教程和操作指南都与描述实际步骤有关</li>
<li>操作指南和技术参考都是我们在工作、编码时所需要的</li>
<li>参考指南和解释都涉及理论知识</li>
<li>教程和解释在我们学习时最有用，而不是实际工作</li>
</ul>
<h2 id="崩溃的趋势">崩溃的趋势</h2>
<p>鉴于这些重叠，不同类型的文档相互混淆和混合也就不足为奇了。事实上，这些不同类型的文档相互之间有一种自然的引力，而且很难抗拒。它的作用是破坏结构，这就是为什么这么多文档看起来像这样：</p>
<p><img src="/_resources/4beabf32276340ae978dd4ea8e7f4daf.png" /></p>
<h2 id="系统的采用">系统的采用</h2>
<p>虽然很少能找到充分使用它的清晰示例，但大量文档以不同的方式识别这四个功能中的每一个。</p>
<p>该计划在重大项目中的良好示例包括：</p>
<ul>
<li><a title="https://docs.divio.com/" href="https://docs.divio.com/">Divio Developer Handbook</a></li>
<li><a title="https://docs.djangoproject.com/en/3.0/#how-the-documentation-is-organized" href="https://docs.djangoproject.com/en/3.0/#how-the-documentation-is-organized">Django’s documentation</a></li>
<li><a title="http://docs.django-cms.org/" href="http://docs.django-cms.org/">django CMS’s documentation</a></li>
</ul>
<p>即使在非常少的文档中也可以使用该系统，例如 <a title="https://docs.coreport.ch/" href="https://docs.coreport.ch/">CoReport（一个开源 COVID-19 报告项目）</a>。在这里，应用该系统为未来的文档创建了一个框架，有助于确保新材料符合要求。</p>
<p>有时文档非常少，以至于并非所有象限都准备好呈现，例如 <a title="https://github.com/flavours/getting-started-with-spring-boot/blob/master/README.md" href="https://github.com/flavours/getting-started-with-spring-boot/blob/master/README.md">Java 和 Spring-boot 入门</a>，它只包括教程、操作方法和参考资料。</p>
<p>尽管在每种情况下，无论多么微小甚至不完整，系统都受到尊重，各部分及其目的之间的明确区分将立即使作者和用户受益，并有助于指导材料在未来发展时的扩展。</p>
<h2 id="关于分析及其应用">关于分析及其应用</h2>
<p>本文中对文档的分析基于多年编写和维护文档的经验，并花费了大量时间考虑如何改进它。</p>
<p>它还基于来自各种学科的合理原则。例如，它的教程概念具有教学基础；它设定了一位导师和一位学习者，并将使用软件视为一门手艺，其中对一般原则的抽象理解来自于处理细节的具体步骤。</p>
<p>该系统定期在会谈和互动研讨会上展示。该分析已应用于众多项目，包括大型内部文档集，并在非常广泛的技术主题中多次获得可用性和可维护性的好处。</p>
<h2 id="参考">参考</h2>
<p><a title="https://documentation.divio.com/adoption/" href="https://documentation.divio.com/adoption/">https://documentation.divio.com/adoption/</a></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[5. 文档系统 ---- 说明]]></title>
            <guid>d8e8b58f4e1f419cbbae1c5494b4a542</guid>
            <pubDate>Tue, 31 Jan 2023 16:28:41 GMT</pubDate>
            <content:encoded><![CDATA[<blockquote>
<p>解释或讨论，澄清和阐明特定主题。它们扩大了文档对某个主题的覆盖范围。</p>
</blockquote>
<p>他们以理解为导向。</p>
<p>解释同样可以描述为讨论；它们本质上是散漫的。它们是文档放松和从软件退后一步的机会，从更广阔的视野，从更高的层次甚至从不同的角度阐明它。您可能会想象一个讨论文档是在闲暇时阅读的，而不是阅读代码。</p>
<p>这部分文档很少明确创建，相反，解释片段散布在其他部分中。有时，该部分存在，但有一个名称，例如背景或其他注释或关键主题 - 这些名称并不总是有用的。</p>
<p>创建讨论并不像看起来那么容易 - 当您有某人问题的起点时，可以直接解释的事情在您有空白页并且必须写下一些相关内容时就不那么容易了。</p>
<p>主题不是由您想要完成的特定任务定义的，例如操作指南，或者您希望用户学习的内容，例如教程。它不是由一台机器定义的，比如参考资料。它是由您认为一次尝试涵盖的合理区域来定义的，因此讨论主题的划分有时可能有点武断。</p>
<h2 id="烹饪类比">烹饪类比</h2>
<p>想想一部在历史、科学和技术背景下讨论食物和烹饪的作品。这是关于烹饪和厨房的。</p>
<p>它不教授，它不是食谱的集合，它不只是描述。</p>
<p>相反，它从多个角度分析、考虑事物。它可能会解释为什么我们现在按照自己的方式做事，甚至可以描述糟糕的做事方式，或模糊的替代方案。</p>
<p>它加深了我们的知识并使它更丰富，即使它不是我们可以在任何实际意义上实际应用的知识——但它不需要是，为了有价值。</p>
<p>当我们想在更高层次上思考烹饪，并想更多地了解这个主题时，我们可能会在闲暇时阅读它，远离厨房本身。</p>
<h2 id="如何写出好的解释">如何写出好的解释</h2>
<h3 id="提供上下文">提供上下文</h3>
<p>解释是背景和上下文的地方——例如，Web 表单以及它们在 Django 中的处理方式，或在 Django CMS 中的搜索。</p>
<p>他们还可以解释为什么会这样——设计决策、历史原因、技术限制。</p>
<h3 id="讨论备选方案和意见">讨论备选方案和意见</h3>
<p>解释可以考虑替代方案，或针对同一问题的多种不同方法。例如，在一篇关于 Django 部署的文章中，考虑和评估不同的 Web 服务器选项是合适的，</p>
<p>讨论甚至可以考虑和权衡相反的意见——例如，测试模块是否应该在包目录中。</p>
<h3 id="不指导不提供技术参考">不指导，不提供技术参考</h3>
<p>解释应该做文档其他部分做不到的事情。这不是指导用户如何做某事的解释的地方。也不应提供技术说明。文档的这些功能已经在其他部分中得到了处理。</p>
<h2 id="divio-文档中的示例">Divio 文档中的示例</h2>
<p>看看我们的<a title="https://docs.divio.com/en/latest/reference/divio-cli" href="https://docs.divio.com/en/latest/reference/divio-cli">解释部分</a>（标题为“背景” - 只要目的明确，名称并不重要）。</p>
<p>这些文章没有教任何东西。他们不会告诉用户该做什么。它们不是参考指南。他们只是讨论特定的话题。用户不需要了解（例如）缓存或 CDN 或我们如何管理环境变量来使用平台或完成任何特定任务，但时间很可能会到来，届时某人的经验和平台使用将成为通过对这些事情有更清晰、更好、更深入的理解而得到改善。</p>
<p>这些文章提供了更大的图景和背景。用户是人；也许他们不需要严格地知道我们为什么以某种方式做某事，但知道这很可能会给他们带来一种满足感和舒适感，使他们成为更快乐的产品用户。</p>
<p><img src="/_resources/c72ddba88f2145d49101e1ecc623e823.png" /></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[4. 文档系统 ---- 参考指南]]></title>
            <guid>d8969ada7b974ff5b02a21aa203533c6</guid>
            <pubDate>Tue, 31 Jan 2023 16:24:57 GMT</pubDate>
            <content:encoded><![CDATA[<blockquote>
<p>参考指南是对机器及其操作方法的技术说明。</p>
</blockquote>
<p>参考指南只有一项工作：描述。它们是由代码决定的，因为最终这就是它们描述的内容：关键类、函数、API，因此它们应该列出函数、字段、属性和方法等内容，并说明如何使用它们。</p>
<p>参考资料以信息为导向。</p>
<p>无论如何，技术参考可以包含示例来说明用法，但不应试图解释基本概念或如何实现常见任务。</p>
<p>参考资料应该简明扼要。</p>
<p>请注意，描述确实包括如何使用机器的基本描述 - 例如，如何实例化特定类或调用特定方法，或将某些内容传递给函数时必须采取的预防措施。然而，这只是其技术参考功能的一部分，强调不要与操作指南混淆 - 描述软件的正确使用（技术参考）与展示如何使用它来实现特定目的不同（操作文档）。</p>
<p>对于一些开发人员来说，参考指南是他们唯一能想到的文档。他们已经了解他们的软件，他们知道如何使用它。他们所能想到的其他人可能需要的只是有关它的技术信息。</p>
<p>参考资料往往写得很好。它甚至可以 - 在某种程度上 - 自动生成，但这本身是不够的。</p>
<h2 id="烹饪类比">烹饪类比</h2>
<p>考虑一篇关于某种成分的百科全书文章，比如生姜。</p>
<p>当您在参考书中查找生姜时，您需要的是有关该成分的信息——描述其来源、行为、化学成分以及烹饪方法的信息。</p>
<p>您希望无论查找什么成分，信息都会以类似的方式呈现。您希望了解基本事实，例如生姜是姜黄和豆蔻家族的一员。</p>
<p>这也是您希望收到有关潜在问题的警报的地方，例如：已知生姜会引起某些人的胃灼热或：生姜可能会干扰抗凝剂的作用，例如华法林或阿司匹林。</p>
<h2 id="如何写出好的参考指南">如何写出好的参考指南</h2>
<h3 id="围绕代码构建文档">围绕代码构建文档</h3>
<p>为参考文档提供与代码库相同的结构，以便用户可以同时浏览代码和文档。这也将帮助维护者查看参考文档丢失或需要更新的地方。</p>
<h3 id="始终如一">始终如一</h3>
<p>在参考指南中，结构、语气、格式都必须保持一致——就像百科全书或字典一样。</p>
<h3 id="除了描述什么都不做">除了描述什么都不做</h3>
<p>技术参考的唯一工作就是描述，尽可能清楚和完整。其他任何事情（解释、讨论、指导、推测、意见）不仅会分散注意力，而且会使它更难使用和维护。在适当的时候提供示例来说明描述。</p>
<p>避免使用参考资料来指导如何实现事物的诱惑，超出使用软件的基本范围，并且不允许对概念进行解释或对主题进行讨论。取而代之的是，链接到操作指南、解释和介绍性教程。</p>
<h3 id="准确">准确</h3>
<p>这些描述必须准确并保持最新。机器与您的描述之间的任何差异都将不可避免地导致用户误入歧途。</p>
<h3 id="divio-文档中的示例">Divio 文档中的示例</h3>
<p>查看我们的<a title="https://docs.divio.com/en/latest/reference/divio-cli" href="https://docs.divio.com/en/latest/reference/divio-cli">技术参考</a>部分中的示例。</p>
<p>这是一个典型的参考指南（在本例中，针对我们的 Divio CLI）。</p>
<p>本文所做的就是描述，以完整和准确的形式列出该工具的功能、命令和选项。</p>
<p>这不是一本友好或引人入胜的读物，但它的目的是尽可能快速和无干扰地查找有关功能的信息。</p>
<p><img src="/_resources/39dbb70411b14b989589918e6e9cc290.png" /></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[3. 文档系统 ---- 操作指南]]></title>
            <guid>3bd5b0fd198c4934bc32b1b464f28a33</guid>
            <pubDate>Tue, 31 Jan 2023 16:20:44 GMT</pubDate>
            <content:encoded><![CDATA[<p>操作指南引导读者完成解决现实世界问题所需的步骤。</p>
<p>它们是实现特定目标的秘诀和指导——例如：如何创建网络表单；如何绘制三维数据集；如何启用 LDAP 身份验证。</p>
<p>他们完全以目标为导向。</p>
<p>操作指南与教程完全不同，切勿与它们混淆：</p>
<ul>
<li>教程是您决定初学者需要了解的内容。</li>
<li>操作指南是对只有具有一定经验的用户才能提出的问题的答案。</li>
</ul>
<p>在操作指南中，您可以假设一些知识和理解。您可以假设用户已经知道如何做基本的事情和使用基本的工具。</p>
<p>与教程不同，软件文档中的操作指南往往做得相当好。它们也很有趣且易于编写。</p>
<h2 id="烹饪类比">烹饪类比</h2>
<p><img src="/_resources/64b5ff532d70498891941154b75179a0.png" /></p>
<p>想想一个食谱，准备吃的东西。</p>
<p>食谱有一个明确、明确的结局。它解决了一个特定的问题。它向某人展示 - 可以假设他们已经具备一些基本知识 - 如何取得成就。</p>
<p>不能指望以前从未做过饭的人成功地遵循食谱，因此食谱不能代替烹饪课。同时，阅读食谱的人会很生气地发现它试图教授他们已经知道的基础知识，或者包含与成分无关的讨论。</p>
<h2 id="如何编写好的操作指南">如何编写好的操作指南</h2>
<h3 id="提供一系列步骤">提供一系列步骤</h3>
<p>操作指南必须包含一系列步骤，需要按顺序执行（就像教程一样）。您不必从头开始，只需从一个合理的起点开始。操作指南应该是可靠的，但它们不需要像教程那样具有铁一般的可重复性。</p>
<h3 id="注重结果">注重结果</h3>
<p>操作指南必须侧重于实现实际目标。其他任何事情都会让人分心。与教程一样，详细的解释在这里是不合适的。</p>
<h3 id="解决特定问题">解决特定问题</h3>
<p>操作指南必须解决特定问题：我如何……？</p>
<p>这是操作指南不同于教程的一种方式：当涉及到操作指南时，可以假设读者知道他们应该实现什么，但还不知道如何实现 - 而在教程中，您有责任决定读者需要了解哪些内容。</p>
<h3 id="不解释概念">不解释概念</h3>
<p>操作指南不应解释任何事情。这不是进行此类讨论的场所；他们只会妨碍行动。如果解释很重要，请链接到它们。</p>
<h3 id="允许一些灵活性">允许一些灵活性</h3>
<p>操作指南应该允许使用略有不同的方法来做同样的事情。它只需要足够的灵活性，以便用户可以看到它将如何应用于与您描述的示例略有不同的示例，或者了解如何使其适应与您假设的系统或配置略有不同的系统或配置。不要太具体以至于指南除了你心中的确切目的之外没有任何用处。</p>
<h3 id="把事情留在外面">把事情留在外面</h3>
<p>实用性比完整性更有价值。教程需要是完整的、端到端的指南；操作指南没有。他们可以在您认为合适的地方开始和结束。他们也不需要提及该提及的所有内容，只是因为它与主题相关。臃肿的操作指南无法帮助用户快速找到他们的解决方案。</p>
<h3 id="名字很好引导">名字很好引导</h3>
<p>操作文档的标题应该告诉用户它到底做了什么。 How to create a class-based view 这个标题不错。创建基于类的视图或更糟的是，基于类的视图不是。</p>
<h3 id="divio-文档中的示例">Divio 文档中的示例</h3>
<p>看看我们的<a title="https://docs.divio.com/en/latest/how-to/" href="https://docs.divio.com/en/latest/how-to/">操作指南</a>。</p>
<p>其中每一个都是对一个问题的回答：我如何……？每个标题前面都可以清楚地加上“How to”字样。每一个都是一个秘诀，引导您完成完成特定任务所需的步骤。</p>
<p>尽管教程和操作指南都是为用户服务的，但是教程是由知道用户需要知道什么的作者主导的，而操作指南是由提出问题的用户引导的。</p>
<p><img src="/_resources/740543613b8d409e9e9293a2c371cb6a.png" /></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[2. 文档系统 ---- 教程]]></title>
            <guid>0b3fe84173924c459ed57b3b36078e88</guid>
            <pubDate>Tue, 31 Jan 2023 16:10:58 GMT</pubDate>
            <content:encoded><![CDATA[<p>教程是指导读者通过一系列步骤完成某种项目的课程。它们是您的项目所需要的，以便向初学者展示他们可以用它取得一些成就。</p>
<p>他们完全以学习为导向，具体来说，他们以学习如何做而不是学习那个为导向。</p>
<p>您是老师，您要对学生的行为负责。在您的指导下，学生将执行一系列操作以达到某个目的。</p>
<p>结局和行动取决于你，但决定它们应该是什么可能是一项艰苦的工作。结束必须是有意义的，但对于一个完全的初学者来说也是可以实现的。</p>
<p>重要的是完成教程后，学习者能够理解文档的其余部分以及软件本身。</p>
<p>大多数软件项目都有非常糟糕的——或者根本不存在的——教程。教程将把你的学习者变成用户。糟糕或缺失的教程将阻止您的项目获得新用户。</p>
<p>在描述四种文档的部分中，这是迄今为止最长的 - 这是因为教程最容易被误解，也最难做好。最好的教学方式是有老师在场，与学生互动。这几乎不可能，我们的书面教程充其量只是一个远非完美的替代品。这就是特别关注它们的更多理由。</p>
<p>教程需要对初学者有用，易于理解，有意义且极其强大，并保持最新。您可能会发现编写和维护教程所占用的时间和精力与其他三个部分加在一起所占用的时间和精力一样多。</p>
<h2 id="烹饪类比">烹饪类比</h2>
<p>考虑一个教孩子做饭的类比。</p>
<p>你教孩子做什么并不重要。重要的是孩子觉得它很有趣，并获得信心，并想再做一次。</p>
<p>通过孩子所做的事情，他将学习有关烹饪的重要知识。它将了解在厨房、使用器具和处理食物时的感觉。</p>
<p>这是因为使用软件就像烹饪一样是一门手艺。它是知识——但它是实践知识，而不是理论知识。</p>
<p>当我们学习一门新手艺或技能时，我们总是边做边学。</p>
<h2 id="如何写出好的教程">如何写出好的教程</h2>
<h3 id="允许用户边做边学">允许用户边做边学</h3>
<p><strong>一开始，我们只能通过实践来学习任何东西</strong>——这就是我们学习说话或走路的方式。</p>
<p>在您的软件教程中，您的学习者需要做一些事情。他们在按照您的教程进行操作时所做的不同事情需要涵盖广泛的工具和操作，从一开始最简单的工具和更复杂的工具和操作。</p>
<h3 id="让用户开始">让用户开始</h3>
<p>如果您的初学者的第一步是手持婴儿学步，那是完全可以接受的。如果您让初学者做的事情不是有经验的人会做的，或者即使这不是“正确”的方式，这也是完全可以接受的——初学者教程与最佳实践手册不同。</p>
<p>教程的目的是让您的学习者开始他们的旅程，而不是让他们到达最终目的地。</p>
<h3 id="确保您的教程有效">确保您的教程有效</h3>
<p>作为导师，你的工作之一是激发初学者的信心：对软件、对教程、对导师，当然还有对他们自己实现要求的能力的信心。</p>
<p>有很多因素促成了这一点。友好的语气会有所帮助，语言的一致使用以及材料的逻辑进展也会有所帮助。但最重要的一点是，你要求初学者做的事情必须奏效。学习者需要看到您要求他们采取的行动会产生您所说的效果。</p>
<p>如果学习者的操作产生错误或意外结果，那么您的教程就失败了——即使这不是您的错。当你的学生和你在一起时，你可以拯救他们；如果他们自己阅读你的文档，你就不能——所以你必须提前防止这种情况发生。毫无疑问，这说起来容易做起来难。</p>
<h3 id="确保用户立即看到结果">确保用户立即看到结果</h3>
<p>学习者所做的每一件事都应该完成一些可以理解的事情，无论多么小。如果您的学生在看到结果之前必须在两页纸上做一些奇怪且难以理解的事情，那就太长了。每个动作的效果都应该尽快可见和明显，并且与动作的联系应该清楚。</p>
<p>教程的每个部分或整个教程的结论必须是有意义的成就。</p>
<h3 id="让您的教程可重复">让您的教程可重复</h3>
<p>您的教程必须可靠地可重复。这并不容易实现：人们将使用不同的操作系统、经验水平和工具来实现它。更重要的是，他们使用的任何软件或资源很可能同时发生变化。</p>
<p>本教程每次都必须适用于所有人。</p>
<p>不幸的是，教程需要定期和详细的测试以确保它们仍然有效。</p>
<h3 id="关注具体步骤而不是抽象概念">关注具体步骤，而不是抽象概念</h3>
<p>教程需要具体，围绕具体的、特定的行动和结果构建。</p>
<p>引入抽象的诱惑是巨大的；毕竟，大多数计算都是通过这种方式获得其能力的。但是所有的学习都是从具体和具体到一般和抽象的，要求学习者在他们甚至有机会掌握具体之前欣赏抽象层次是糟糕的教学。</p>
<h3 id="提供最少的必要解释">提供最少的必要解释</h3>
<p>不要解释学习者为了完成教程不需要知道的任何事情。扩展讨论很重要——只是不在教程中。在教程中，它是一种障碍和干扰。只有最低限度是合适的。相反，链接到文档中其他地方的解释。</p>
<h3 id="只关注用户需要采取的步骤">只关注用户需要采取的步骤</h3>
<p>您的教程需要专注于手头的任务。也许您要介绍的命令还有许多其他选项，或者可能有不同的方式来访问某个 API。没关系：现在，您的学习者不需要了解这些就可以取得进步。</p>
<h3 id="divio-文档中的示例">Divio 文档中的示例</h3>
<p>看看我们的<a title="https://docs.divio.com/en/latest/introduction/" href="https://docs.divio.com/en/latest/introduction/">教程</a>。</p>
<p>特别是，请参阅 Django 教程。本教程做出的承诺是：如果您具备学习本教程所需的基本知识，并且按照它的指示进行操作，您最终将得到一个可用的 Django Web 应用程序，其中包含 Postgres 数据库、S3 媒体存储等.为了作为教程工作，它必须履行该承诺。</p>
<p>请注意，它不会告诉您将学习什么，而只会告诉您将做什么。学习来自于那样做。本教程对您将要执行的操作以及执行顺序负全部责任。</p>
<p><img src="/_resources/89080eae08bf40d58fc1a1ef6f780f9d.png" /></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[1. 文档系统 ---- 介绍]]></title>
            <guid>a2e5226395d2413dbeec0ff7c99ddcfc</guid>
            <pubDate>Tue, 31 Jan 2023 15:52:16 GMT</pubDate>
            <content:encoded><![CDATA[<blockquote>
<p>为了编写好的软件文档，需要了解一个秘密：没有一种叫做文档的东西，而是有四种。</p>
</blockquote>
<p>它们是：<strong>教程</strong>、<strong>操作指南</strong>、<strong>技术参考</strong>和<strong>解释</strong>。它们代表四种不同的目的或功能，所以需要四种不同的创建方法。理解这一点的含义将有助于改进大多数文档。</p>
<p><img src="/_resources/edacd9c6002b4530bc8bb2197a145e51.png" /></p>
<center style="font-size:14px;color:#C0C0C0;text-decoration:underline;margin-top:-20px" class="jop-noMdConv">文档系统</center>
<p>此处概述的文档系统是一个简单、全面且几乎普遍适用的方案。它在广泛的领域和应用中得到了实践证明。</p>
<p>如果你能将这些原则付诸实践，它会让你的文档变得更好，你的项目、产品或团队会更成功。</p>
<h2 id="介绍">介绍</h2>
<h3 id="问题与解决方案">问题与解决方案</h3>
<h4 id="解决的问题">解决的问题</h4>
<p>你的产品有多好并不重要，因为如果它的文档不够好，人们就不会使用它。即使他们因为别无选择而不得不使用它，如果没有良好的文档，他们也不会有效地或按照您希望的方式使用它。</p>
<p>几乎每个人都明白这一点。几乎每个人都知道他们需要好的文档，而且大多数人都试图创建好的文档。大多数人都失败了。</p>
<p>通常，这不是因为他们不够努力。通常，这是因为他们没有以正确的方式做事。</p>
<p>这个系统是一种让你的文档变得更好的方法，不是通过更努力地工作，而是通过正确的方式来做。正确的方法是更简单的方法——更容易编写，也更容易维护。</p>
<h4 id="原理">原理</h4>
<p>这实际上不是秘密，当然也不应该是秘密：文档需要包括并围绕其四个不同功能构建：<strong>教程、操作指南、技术参考和解释</strong>。他们每个都需要一种独特的写作方式。使用软件的人在不同的时间、不同的情况下需要这四种不同的文档——所以软件通常都需要它们，而且它们都应该集成到您的文档中。</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">教程</th>
<th style="text-align:left">操作指南</th>
<th style="text-align:left">参考</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">面向</td>
<td style="text-align:left">学习</td>
<td style="text-align:left">一个目标</td>
<td style="text-align:left">信息</td>
<td style="text-align:left">理解</td>
</tr>
<tr>
<td style="text-align:left">必须</td>
<td style="text-align:left">让新人开始</td>
<td style="text-align:left">展示如何解决特定问题</td>
<td style="text-align:left">描述原理</td>
<td style="text-align:left">诠释</td>
</tr>
<tr>
<td style="text-align:left">它的形式</td>
<td style="text-align:left">一堂课</td>
<td style="text-align:left">一系列步骤</td>
<td style="text-align:left">尝试描述</td>
<td style="text-align:left">话语解释</td>
</tr>
<tr>
<td style="text-align:left">比如</td>
<td style="text-align:left">教小孩做饭</td>
<td style="text-align:left">烹饪书中的食谱</td>
<td style="text-align:left">参考百科文章</td>
<td style="text-align:left">一篇关于烹饪社会史的文章</td>
</tr>
</tbody>
</table>
<p>这种划分使作者和读者都清楚什么材料，什么样的材料，去哪里。它告诉作者如何写，写什么，写在哪里。它使作者免于浪费大量时间试图将他们想要传达的信息拼凑成有意义的形式，因为这些类型的文档中的每一种都只有一项工作。</p>
<p>事实上，如果不隐式或明确地识别此方案的象限，则很难维护良好的文档。每种类型的需求都与其他类型的需求不同，因此任何未能保持这种结构的文档尝试都会受到影响，因为它会同时被拉向不同的方向。</p>
<p>一旦您理解了结构，它就成为分析现有文档以及理解需要做什么来改进它的非常有用的工具。</p>
<p>在以下各节中，将详细介绍这四个部分中的每一个。</p>
<h4 id="使文档工作">使文档工作</h4>
<h4 id="对于作者">对于作者</h4>
<p>文档维护者必须处理的最令人头疼的问题之一是不清楚他们应该做什么。他们写了又改，但发现很难以令人满意的方式将它们组合在一起。</p>
<p>这种结构通过明确区分和分离解决了这些问题。他们制作的文档更易于编写和维护，更易于使用和使用。</p>
<p>该文档不会自行编写 - 但现在可以编写它，而不必为不合适、范围不明确或对应包含的内容或采用的样式产生疑问而苦苦挣扎。写什么、怎么写、放在哪里都变得清晰多了。</p>
<h4 id="对于读者">对于读者</h4>
<p>它更好地为用户服务，因为在他们与软件交互的周期的所有不同阶段，他们会找到合适的文档类型，满足当时的需求。</p>
<p>编写明确和明确地解决四个象限中每一个的文档有助于软件吸引和留住更多用户，他们将更有效地使用它——这是软件创建者最想要的事情之一。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Golang错误处理]]></title>
            <guid>6cd2eaf95f824f7d9f74885783dd6547</guid>
            <pubDate>Tue, 31 Jan 2023 14:53:47 GMT</pubDate>
            <content:encoded><![CDATA[<h2 id="最佳实践">最佳实践</h2>
<h3 id="panic">panic</h3>
<ol>
<li>在程序启动的时候，如果有强依赖的服务出现故障时<code>panic</code>退出</li>
<li>在程序启动的时候，如果发现有配置明显不符合要求， 可以<code>panic</code>退出（防御编程）</li>
<li>其他情况下只要不是不可恢复的程序错误，都不应该直接<code>panic</code>应该返回<code>error</code></li>
<li>在程序入口处，例如<code>gin</code>中间件需要使用<code>recover</code>预防<code>panic</code>程序退出</li>
<li>在程序中我们应该避免使用野生的<code>goroutine</code>
<ol>
<li>如果是在请求中需要执行异步任务，应该使用异步<code>worker</code>，消息通知的方式进行处理，避免请求量大时大量<code>goroutine</code>创建</li>
<li>如果需要使用<code>goroutine</code>时，应该使用统一的<code>Go</code>函数进行创建，这个函数中会进行<code>recover</code>，避免因为野生<code>goroutine panic</code>导致主进程退出</li>
</ol>
</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Go</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>()</span>)</span>{
    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>{
            <span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> {
                log.Printf(<span class="hljs-string">"panic: %+v"</span>, err)
            }
        }()

        f()
    }()
}</code></pre></div>
<h3 id="error">error</h3>
<ol>
<li>我们在应用程序中使用<code>github.com/pkg/errors</code>处理应用错误，注意在公共库当中，<strong>一般不使用这个</strong></li>
<li><code>error</code>应该是函数的最后一个返回值，当<code>error</code>不为<code>nil</code>时，函数的其他返回值是不可用的状态，不应该对其他返回值做任何期待
<ol>
<li><code>func f() (io.Reader, *S1, error)</code>在这里，我们不知道<code>io.Reader</code>中是否有数据，可能有，也有可能有一部分</li>
</ol>
</li>
<li>错误处理的时候应该先判断错误， <code>if err != nil</code>出现错误及时返回，使代码是一条流畅的直线，避免过多的嵌套.</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-comment">// good case</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> {
    a, err := A()
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> err
    }

    <span class="hljs-comment">// ... 其他逻辑</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}

<span class="hljs-comment">// bad case</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> {
    a, err := A()
    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> {
    	<span class="hljs-comment">// 其他逻辑</span>
    }

    <span class="hljs-keyword">return</span> err
}</code></pre></div>
<ol start="4">
<li>在应用程序中出现错误时，使用<code>errors.New</code>或者<code>errors.Errorf</code>返回错误</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *usecese)</span> <span class="hljs-title">usecase1</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> {
    money := u.repo.getMoney(uid)
    <span class="hljs-keyword">if</span> money &lt; <span class="hljs-number">10</span> {
        errors.Errorf(<span class="hljs-string">"用户余额不足, uid: %d, money: %d"</span>, uid, money)
    }
    <span class="hljs-comment">// 其他逻辑</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}</code></pre></div>
<ol start="5">
<li>如果是调用应用程序的其他函数出现错误，请直接返回，如果需要携带信息，请使用 <code>errors.WithMessage</code></li>
</ol>
<div><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *usecese)</span> <span class="hljs-title">usecase2</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> {
    name, err := u.repo.getUserName(uid)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> errors.WithMessage(err, <span class="hljs-string">"其他附加信息"</span>)
    }

    <span class="hljs-comment">// 其他逻辑</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}</code></pre></div>
<ol start="5">
<li>如果是调用其他库（标准库、企业公共库、开源第三方库等）获取到错误时，请使用<code>errors.Wrap</code>添加堆栈信息
<ol>
<li>切记，不要每个地方都是用<code>errors.Wrap</code>只需要在错误第一次出现时进行 <code>errors.Wrap</code>即可</li>
<li>根据场景进行判断是否需要将其他库的原始错误吞掉，例如可以把 <code>repository</code>层的数据库相关错误吞掉，返回业务错误码，避免后续我们分割微服务或者更换 ORM  库时需要去修改上层代码</li>
<li>注意我们在基础库，被大量引入的第三方库编写时一般不使用 <code>errors.Wrap</code> 避免堆栈信息重复</li>
</ol>
</li>
<li><strong>禁止每个出错的地方都打日志</strong>，只需要在进程的最开始的地方使用 %+v  进行统一打印，例如 http/rpc 服务的中间件</li>
<li>错误判断使用<code>errors.Is</code>进行比较</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> {
    err := A()
    <span class="hljs-keyword">if</span> errors.Is(err, io.EOF){
    	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
    }

    <span class="hljs-comment">// 其他逻辑</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}</code></pre></div>
<ol start="8">
<li>错误类型判断，使用 errors.As  进行赋值</li>
</ol>
<div><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> {
    err := A()

    <span class="hljs-keyword">var</span> errA errorA
    <span class="hljs-keyword">if</span> errors.As(err, &amp;errA){
    	<span class="hljs-comment">// ...</span>
    }

    <span class="hljs-comment">// 其他逻辑</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}</code></pre></div>
<ol start="9">
<li>如何判定错误的信息是否足够，想一想当你的代码出现问题需要排查的时候你的错误信息是否可以帮助你快速的定位问题，例如我们在请求中一般会输出参数信息，用于辅助判断错误</li>
<li>对于业务错误，推荐在一个统一的地方创建一个错误字典，错误字典里面应该包含错误的 code，并且在日志中作为独立字段打印，方便做业务告警的判断，错误必须有清晰的错误文档</li>
<li>不需要返回，被忽略的错误必须输出日志信息</li>
<li>同一个地方不停的报错，最好不要不停输出错误日志，这样可能会导致被大量的错误日志信息淹没，无法排查问题，比较好的做法是打印一次错误详情，然后打印出错误出现的次数</li>
<li>对同一个类型的错误，采用相同的模式，例如参数错误，不要有的返回 404 有的返回 200</li>
<li><strong>处理错误的时候，需要处理已分配的资源</strong>，使用<code>defer</code>进行清理，例如文件句柄</li>
</ol>
<h2 id="panic-or-error">panic or error?</h2>
<ol>
<li>在 Go 中<code>panic</code>会导致程序直接退出，是一个致命的错误，如果使用<code>panic  recover</code>进行处理的话，会存在很多问题
<ol>
<li>性能问题，频繁<code>panic recover</code>性能不好</li>
<li>容易导致程序异常退出，只要有一个地方没有处理到就会导致程序进程整个退出</li>
<li>不可控，一旦<code>panic</code>就将处理逻辑移交给了外部，我们并不能预设外部包一定会进行处理</li>
</ol>
</li>
<li>什么时候使用<code>panic</code>呢？
<ol>
<li>对于真正意外的情况，那些表示不可恢复的程序错误，例如索引越界、不可恢复的环境问题、栈溢出，我们才使用 panic</li>
</ol>
</li>
<li>使用 error 处理有哪些好处？
<ol>
<li>简单</li>
<li>考虑失败，而不是成功(Plan for failure, not success)</li>
<li>没有隐藏的控制流</li>
<li>完全交给你来控制 error</li>
<li>Error are values</li>
</ol>
</li>
</ol>
<h2 id="为什么标准库中-errorsnew-会返回一个指针">为什么标准库中 errors.New 会返回一个指针</h2>
<p>翻看标准库的源代码我们可以发现，<code> errors</code>  库中的 <code>errorString</code>  结构体实现了<code> error</code>  接口，为什么在 <code>New</code>  一个 <code>error</code> 的时候会返回一个结构体的指针呢？</p>
<div><pre class="hljs"><code><span class="hljs-comment">// New returns an error that formats as the given text.</span>
<span class="hljs-comment">// Each call to New returns a distinct error value even if the text is identical.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(text <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> {
    <span class="hljs-keyword">return</span> &amp;errorString{text}
}

<span class="hljs-comment">// errorString is a trivial implementation of error.</span>
<span class="hljs-keyword">type</span> errorString <span class="hljs-keyword">struct</span> {
    s <span class="hljs-keyword">string</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *errorString)</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> {
    <span class="hljs-keyword">return</span> e.s
}</code></pre></div>
<p>我们先来看一个例子，我们同样创建了 <code>errorString</code> 的结构体，我们自定义的和标准库中的唯一不同就是，自建的这个返回的是值，而不是指针。</p>
<p>在<code>main</code>函数的对比中我们就可以发现，我们自定义的<code>errorString</code>在对比的时候只要对应的字符串相同就会返回 <code>true</code>，但是标准库的包不会。</p>
<p>这是因为，在对比两个 <code>struct</code> 是否相同的时候，会去对比，这两个 <code>struct</code> 里面的各个字段是否是相同的，如果相同就返回 <code>true</code>，但是对比指针的时候会去判断两个指针的地址是否一致。</p>
<p><strong>如果字符串相等就返回 true 会导致什么问题呢？</strong></p>
<p>如果我有两个包，定义了两个错误，他们其实是两个相同的字符串，在其他库调用对比的时候，可能会由于不同的书写顺序，走进不同的分支导致一些奇奇怪怪的错误</p>
<div><pre class="hljs"><code><span class="hljs-keyword">type</span> errorString <span class="hljs-keyword">struct</span> {
    text <span class="hljs-keyword">string</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e errorString)</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> {
    <span class="hljs-keyword">return</span> e.text
}

<span class="hljs-comment">// New 创建一个自定义错误</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> {
    <span class="hljs-keyword">return</span> errorString{text: s}
}

<span class="hljs-keyword">var</span> errorString1 = New(<span class="hljs-string">"test a"</span>)
<span class="hljs-keyword">var</span> err1 = errors.New(<span class="hljs-string">"test b"</span>)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">if</span> errorString1 == New(<span class="hljs-string">"test a"</span>) {
        fmt.Println(<span class="hljs-string">"err string a"</span>) <span class="hljs-comment">// 会输出</span>
    }

    <span class="hljs-keyword">if</span> err1 == errors.New(<span class="hljs-string">"test b"</span>) {
        fmt.Println(<span class="hljs-string">"err b"</span>) <span class="hljs-comment">// 不会输出</span>
    }
}</code></pre></div>
<h2 id="error-type-错误定义与判断">error type: 错误定义与判断</h2>
<h3 id="sentinel-error">Sentinel Error</h3>
<p>哨兵错误，就是定义一些包级别的错误变量，然后在调用的时候外部包可以直接对比变量进行判定，在标准库当中大量的使用了这种方式</p>
<p>例如下方 <code>io</code>  库中定义的错误</p>
<div><pre class="hljs"><code><span class="hljs-comment">// EOF is the error returned by Read when no more input is available.</span>
<span class="hljs-comment">// Functions should return EOF only to signal a graceful end of input.</span>
<span class="hljs-comment">// If the EOF occurs unexpectedly in a structured data stream,</span>
<span class="hljs-comment">// the appropriate error is either ErrUnexpectedEOF or some other error</span>
<span class="hljs-comment">// giving more detail.</span>
<span class="hljs-keyword">var</span> EOF = errors.New(<span class="hljs-string">"EOF"</span>)

<span class="hljs-comment">// ErrUnexpectedEOF means that EOF was encountered in the</span>
<span class="hljs-comment">// middle of reading a fixed-size block or data structure.</span>
<span class="hljs-keyword">var</span> ErrUnexpectedEOF = errors.New(<span class="hljs-string">"unexpected EOF"</span>)

<span class="hljs-comment">// ErrNoProgress is returned by some clients of an io.Reader when</span>
<span class="hljs-comment">// many calls to Read have failed to return any data or error,</span>
<span class="hljs-comment">// usually the sign of a broken io.Reader implementation.</span>
<span class="hljs-keyword">var</span> ErrNoProgress = errors.New(<span class="hljs-string">"multiple Read calls return no data or error"</span>)
</code></pre></div>
<p>我们在外部判定的时候一般使用等值判定或者使用<code> errors.Is</code>  进行判断</p>
<div><pre class="hljs"><code><span class="hljs-keyword">if</span> err == io.EOF {
    <span class="hljs-comment">//...</span>
}

<span class="hljs-keyword">if</span> errors.Is(err, io.EOF){
    <span class="hljs-comment">//...</span>
}</code></pre></div>
<p>这种错误处理方式有一个问题是，将<code>error</code>当做包的<code>API</code>暴露给了第三方，这样会导致在做重构或者升级的时候很麻烦，并且这种方式包含的错误信息会十分的有限</p>
<h3 id="error-types">error types</h3>
<p>这个就类似我们前面定义的<code>errorString</code>一样实现了<code>error</code> 的接口，然后在外部是否类型断言来判断是否是这种错误类型</p>
<div><pre class="hljs"><code><span class="hljs-keyword">type</span> MyStruct <span class="hljs-keyword">struct</span> {
    s <span class="hljs-keyword">string</span>
    name <span class="hljs-keyword">string</span>
    path <span class="hljs-keyword">string</span>
}



<span class="hljs-comment">// 使用的时候</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">switch</span> err.(<span class="hljs-keyword">type</span>) {
        <span class="hljs-keyword">case</span> *MyStruct:
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">case</span> others:
        <span class="hljs-comment">// ...</span>
    }
}</code></pre></div>
<p>这种方式相对于哨兵来说，可以包含更加丰富的信息，但是同样也将错误的类型暴露给了外部，例如标准库中的<code>os.PathError</code></p>
<h3 id="opaque-errors">Opaque errors</h3>
<p>不透明的错误处理，这种方式最大的特点就是只返回错误，暴露错误判定接口，不返回类型，这样可以减少 API 的暴露，后续的处理会比较灵活，这个一般用在公共库会比较好</p>
<div><pre class="hljs"><code><span class="hljs-keyword">type</span> temporary <span class="hljs-keyword">interface</span> {
    Temporary() <span class="hljs-keyword">bool</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsTemporary</span><span class="hljs-params">(err error)</span> <span class="hljs-title">bool</span></span> {
    te, ok := err.(temporary)
    <span class="hljs-keyword">return</span> ok &amp;&amp; te.Temporary()
}</code></pre></div>
<h2 id="error-handle-错误处理优化">error handle: 错误处理优化</h2>
<p>在 go 中常常会存在大量的 <code>if err</code>代码，下面介绍两种常见的减少这种代码的方式</p>
<h3 id="bufioscan">bufio.scan</h3>
<p>对比下面两个函数的处理我们可以发现，<code>count2</code>  使用<code>sc.Scan</code>  之后一个 <code>if err</code> 的判断都没有，极大的简化了代码，这是因为在<code>sc.Scan</code>做了很多处理，像很多类似的，需要循环读取的都可以考虑像这样包装之后进行处理，这样外部包调用的时候就会非常简洁</p>
<div><pre class="hljs"><code><span class="hljs-comment">// 统计文件行数</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">count</span><span class="hljs-params">(r io.Reader)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span> {
    <span class="hljs-keyword">var</span> (
        br    = bufio.NewReader(r)
        lines <span class="hljs-keyword">int</span>
        err   error
    )

    <span class="hljs-keyword">for</span> {
        <span class="hljs-comment">// 读取到换行符就说明是一行</span>
        _, err = br.ReadString(<span class="hljs-string">'\n'</span>)
        lines++
        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
            <span class="hljs-keyword">break</span>
        }
    }

    <span class="hljs-comment">// 当错误是 EOF 的时候说明文件读取完毕了</span>
    <span class="hljs-keyword">if</span> err != io.EOF {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, err
    }

    <span class="hljs-keyword">return</span> lines, err
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">count2</span><span class="hljs-params">(r io.Reader)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span> {
    <span class="hljs-keyword">var</span> (
        sc    = bufio.NewScanner(r)
        lines <span class="hljs-keyword">int</span>
    )

    <span class="hljs-keyword">for</span> sc.Scan() {
        lines++
    }

    <span class="hljs-keyword">return</span> lines, sc.Err()
}</code></pre></div>
<h3 id="error-writer">error writer</h3>
<p>看一个来自 go blog 的例子：<a title="https://blog.golang.org/errors-are-values" href="https://blog.golang.org/errors-are-values">https://blog.golang.org/errors-are-values</a></p>
<p>一般代码：</p>
<div><pre class="hljs"><code>_, err = fd.Write(p0[a:b])
<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
    <span class="hljs-keyword">return</span> err
}
_, err = fd.Write(p1[c:d])
<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
    <span class="hljs-keyword">return</span> err
}
_, err = fd.Write(p2[e:f])
<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
    <span class="hljs-keyword">return</span> err
}
<span class="hljs-comment">// and so on</span></code></pre></div>
<p>errWriter</p>
<div><pre class="hljs"><code><span class="hljs-keyword">type</span> errWriter <span class="hljs-keyword">struct</span> {
    w   io.Writer
    err error
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ew *errWriter)</span> <span class="hljs-title">write</span><span class="hljs-params">(buf []<span class="hljs-keyword">byte</span>)</span></span> {
    <span class="hljs-keyword">if</span> ew.err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span>
    }
    _, ew.err = ew.w.Write(buf)
}

<span class="hljs-comment">// 使用时</span>
ew := &amp;errWriter{w: fd}
ew.write(p0[a:b])
ew.write(p1[c:d])
ew.write(p2[e:f])
<span class="hljs-comment">// and so on</span>
<span class="hljs-keyword">if</span> ew.err != <span class="hljs-literal">nil</span> {
    <span class="hljs-keyword">return</span> ew.err
}</code></pre></div>
<p>如果去翻 标准库中<code>bufio.Writer</code> 的源代码，你会发现也有这种用法，这种就是将重复的逻辑进行了封装，然后把<code>error</code>暂存，然后我们就只需要在最后判断一下<code>error</code>就行了</p>
<h2 id="wrap-error-错误包装">wrap error: 错误包装</h2>
<h3 id="errorswrap-有何作用为什么不用标准库的-fmterrorfw">errors.wrap 有何作用，为什么不用标准库的 fmt.Errorf("%w")</h3>
<p>我们先看一下标准库的源码，我们可以发现当<code>p.wrappedErr != nil</code> 的时候（也就是有 <code>%w</code>）的时候，会使用一个 <code>wrapError</code>  将错误包装，看 <code>wrapError</code>  的源码可以发现，这个方法只是包装了一下原始错误，并且可以做到附加一些文本信息，但是没有堆栈信息。</p>
<div><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Errorf</span><span class="hljs-params">(format <span class="hljs-keyword">string</span>, a ...<span class="hljs-keyword">interface</span>{})</span> <span class="hljs-title">error</span></span> {
    p := newPrinter()
    p.wrapErrs = <span class="hljs-literal">true</span>
    p.doPrintf(format, a)
    s := <span class="hljs-keyword">string</span>(p.buf)
    <span class="hljs-keyword">var</span> err error
    <span class="hljs-keyword">if</span> p.wrappedErr == <span class="hljs-literal">nil</span> {
        err = errors.New(s)
    } <span class="hljs-keyword">else</span> {
        err = &amp;wrapError{s, p.wrappedErr}
    }
    p.free()
    <span class="hljs-keyword">return</span> err
}

<span class="hljs-keyword">type</span> wrapError <span class="hljs-keyword">struct</span> {
    msg <span class="hljs-keyword">string</span>
    err error
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *wrapError)</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> {
    <span class="hljs-keyword">return</span> e.msg
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *wrapError)</span> <span class="hljs-title">Unwrap</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> {
    <span class="hljs-keyword">return</span> e.err
}</code></pre></div>
<p>再看一下 <code>pkg/errors</code> 的源码，我肯可以发现除了使用 <code>withMessage</code>  附加了错误信息之外还使用<code> withStack</code>  附加了堆栈信息，这样我们在程序入口处打印日志信息的时候就可以将堆栈信息一并打出了</p>
<div><pre class="hljs"><code><span class="hljs-comment">// Wrap returns an error annotating err with a stack trace</span>
<span class="hljs-comment">// at the point Wrap is called, and the supplied message.</span>
<span class="hljs-comment">// If err is nil, Wrap returns nil.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Wrap</span><span class="hljs-params">(err error, message <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> {
    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
    }
    err = &amp;withMessage{
        cause: err,
        msg:   message,
    }
    <span class="hljs-keyword">return</span> &amp;withStack{
        err,
        callers(),
    }
}</code></pre></div>
<h3 id="为什么不允许处处使用-errorswrap">为什么不允许处处使用 errors.Wrap</h3>
<p>因为每一次 <code>errors.Wrap</code> 的调用都会为错误添加堆栈信息，如果处处调用那会有大量的无用堆栈<br />
我们先看一下只有一处<code> wrap</code></p>
<div><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    fmt.Printf(<span class="hljs-string">"err: %+v"</span>, c())
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> {
    <span class="hljs-keyword">return</span> errors.Wrap(fmt.Errorf(<span class="hljs-string">"xxx"</span>), <span class="hljs-string">"test"</span>)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> {
    <span class="hljs-keyword">return</span> a()
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">c</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> {
    <span class="hljs-keyword">return</span> b()
}</code></pre></div>
<p>看结果我们可以发现已经可以打印出全部的堆栈信息了</p>
<div><pre class="hljs"><code>err: xxx
test
main.a
        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">14</span>
main.b
        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">18</span>
main.c
        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">22</span>
main.main
        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>
runtime.main
        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/proc.<span class="hljs-keyword">go</span>:<span class="hljs-number">204</span>
runtime.goexit
        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/asm_amd64.s:<span class="hljs-number">1374</span></code></pre></div>
<p>再看多处 wrap 的现象</p>
<div><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    fmt.Printf(<span class="hljs-string">"err: %+v"</span>, c())
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> {
    <span class="hljs-keyword">return</span> errors.Wrap(fmt.Errorf(<span class="hljs-string">"xxx"</span>), <span class="hljs-string">"a"</span>)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> {
    <span class="hljs-keyword">return</span> errors.Wrap(a(), <span class="hljs-string">"b"</span>)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">c</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> {
    <span class="hljs-keyword">return</span> errors.Wrap(b(), <span class="hljs-string">"c"</span>)
}</code></pre></div>
<p>可以看到每一处<code>wrap</code>都添加了一次堆栈信息</p>
<div><pre class="hljs"><code>err: xxx
a
main.a
        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">14</span>
main.b
        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">18</span>
main.c
        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">22</span>
main.main
        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>
runtime.main
        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/proc.<span class="hljs-keyword">go</span>:<span class="hljs-number">204</span>
runtime.goexit
        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/asm_amd64.s:<span class="hljs-number">1374</span>
b
main.b
        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">18</span>
main.c
        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">22</span>
main.main
        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>
runtime.main
        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/proc.<span class="hljs-keyword">go</span>:<span class="hljs-number">204</span>
runtime.goexit
        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/asm_amd64.s:<span class="hljs-number">1374</span>
c
main.c
        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">22</span>
main.main
        /home/ll/project/Go<span class="hljs-number">-000</span>/Week02/blog/wrap.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>
runtime.main
        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/proc.<span class="hljs-keyword">go</span>:<span class="hljs-number">204</span>
runtime.goexit
        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/asm_amd64.s:<span class="hljs-number">1374</span></code></pre></div>
<h2 id="标准库-errorsis-as-怎么判断错误">标准库 errors.Is / As 怎么判断错误</h2>
<h3 id="errorsis">errors.Is</h3>
<div><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Is</span><span class="hljs-params">(err, target error)</span> <span class="hljs-title">bool</span></span> {
    <span class="hljs-keyword">if</span> target == <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> err == target
    }
    <span class="hljs-comment">// 通过反射判读 target 是否可以被比较</span>
    isComparable := reflectlite.TypeOf(target).Comparable()
    <span class="hljs-keyword">for</span> {
        <span class="hljs-comment">// 循环判断是否相等</span>
        <span class="hljs-keyword">if</span> isComparable &amp;&amp; err == target {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
        }
        <span class="hljs-comment">// 判断是否实现了 is 接口，如果有实现就直接判断</span>
        <span class="hljs-keyword">if</span> x, ok := err.(<span class="hljs-keyword">interface</span>{ Is(error) <span class="hljs-keyword">bool</span> }); ok &amp;&amp; x.Is(target) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
        }

        <span class="hljs-comment">// 去判断是否实现了 unwrap 的接口，如果实现了就进行 unwrap</span>
        <span class="hljs-keyword">if</span> err = Unwrap(err); err == <span class="hljs-literal">nil</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        }
    }
}</code></pre></div>
<h3 id="errorsas">errors.As</h3>
<p>和 is 的逻辑类似，就是不断的进行 unwrap 进行比较，只要有一个相同就返回，如果一直到底都不行就返回 false</p>
<div><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">As</span><span class="hljs-params">(err error, target <span class="hljs-keyword">interface</span>{})</span> <span class="hljs-title">bool</span></span> {
    <span class="hljs-keyword">if</span> target == <span class="hljs-literal">nil</span> {
        <span class="hljs-built_in">panic</span>(<span class="hljs-string">"errors: target cannot be nil"</span>)
    }
    val := reflectlite.ValueOf(target)
    typ := val.Type()
    <span class="hljs-keyword">if</span> typ.Kind() != reflectlite.Ptr || val.IsNil() {
        <span class="hljs-built_in">panic</span>(<span class="hljs-string">"errors: target must be a non-nil pointer"</span>)
    }
    <span class="hljs-keyword">if</span> e := typ.Elem(); e.Kind() != reflectlite.Interface &amp;&amp; !e.Implements(errorType) {
        <span class="hljs-built_in">panic</span>(<span class="hljs-string">"errors: *target must be interface or implement error"</span>)
    }
    targetType := typ.Elem()
    <span class="hljs-keyword">for</span> err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">if</span> reflectlite.TypeOf(err).AssignableTo(targetType) {
            val.Elem().Set(reflectlite.ValueOf(err))
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
        }
        <span class="hljs-keyword">if</span> x, ok := err.(<span class="hljs-keyword">interface</span>{ As(<span class="hljs-keyword">interface</span>{}) <span class="hljs-keyword">bool</span> }); ok &amp;&amp; x.As(target) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
        }
        err = Unwrap(err)
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
}</code></pre></div>
]]></content:encoded>
        </item>
    </channel>
</rss>